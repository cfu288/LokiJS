{
  "version": 3,
  "sources": ["../src/storage-adapter/indexeddb-adapter.ts", "../src/storage-adapter/fs-adapter.ts", "../src/utils/deep-property.ts", "../src/utils/clone-object-array.ts", "../src/utils/clone.ts", "../src/utils/icebox.ts", "../src/utils/utils.ts", "../src/utils/math.ts", "../src/utils/containsCheckFn.ts", "../src/utils/dotSubScan.ts", "../src/utils/sort.ts", "../src/utils/ops.ts", "../src/utils/precompile-query.ts", "../src/modules/result-set.ts", "../src/modules/sylvie-event-emitter.ts", "../src/modules/dynamic-view.ts", "../src/modules/index/exact-index.ts", "../src/modules/index/unique-index.ts", "../src/utils/parse-base-10.ts", "../src/modules/collection.ts", "../src/utils/binary-search.ts", "../src/modules/key-value-store.ts", "../src/utils/localStorageAvailable.ts", "../src/storage-adapter/local-storage-adapter.ts", "../src/storage-adapter/memory-adapter.ts", "../src/storage-adapter/partitioning-adapter.ts", "../src/modules/sylvie.ts", "../src/sylviejs.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/no-empty-interface */\n/* eslint-disable @typescript-eslint/no-this-alias */\n/*\n  Loki IndexedDb Adapter (need to include this script to use it)\n\n  Console Usage can be used for management/diagnostic, here are a few examples :\n  adapter.getDatabaseList(); // with no callback passed, this method will log results to console\n  adapter.saveDatabase('UserDatabase', JSON.stringify(myDb));\n  adapter.loadDatabase('UserDatabase'); // will log the serialized db to console\n  adapter.deleteDatabase('UserDatabase');\n*/\n// @ts-nocheck\nimport { SyncPersistenceAdapter } from \"./persistence-adapter\";\n\n// @ts-ignore\nconst DEBUG = typeof window !== \"undefined\" && !!window.__loki_idb_debug;\n\nif (DEBUG) {\n  console.log(\"DEBUG: Running indexeddb-adapter in DEBUG mode\");\n}\n\ninterface IndexedAdapterOptions {\n  closeAfterSave: boolean;\n}\n/**\n * Loki persistence adapter class for indexedDb.\n *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n *     Utilizes the included LokiCatalog app/key/value database for actual database persistence.\n *     Indexeddb is highly async, but this adapter has been made 'console-friendly' as well.\n *     Anywhere a callback is omitted, it should return results (if applicable) to console.\n *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n *     allow separate contexts for separate apps within a domain.\n *\n * @example\n * var idbAdapter = new LokiIndexedAdapter('finance');\n *\n * @constructor LokiIndexedAdapter\n *\n * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, 'loki' by default\n * @param {object=} options Configuration options for the adapter\n * @param {boolean} options.closeAfterSave Whether the indexedDB database should be closed after saving.\n */\nclass IndexedDBAdapter implements SyncPersistenceAdapter {\n  app: string;\n  options: Partial<IndexedAdapterOptions>;\n  catalog: SylvieCatalog;\n  mode: string;\n  loadKey: (dbname: any, callback: any) => void;\n  saveKey: (dbname: any, dbstring: any, callback: any) => void;\n  deleteKey: (dbname: any, callback: any) => void;\n  getKeyList: (callback: any) => void;\n\n  constructor(appname: string, options?: Partial<IndexedAdapterOptions>) {\n    this.app = \"loki\";\n    this.options = options || {};\n\n    if (typeof appname !== \"undefined\") {\n      this.app = appname;\n    }\n\n    // keep reference to catalog class for base AKV operations\n    this.catalog = null;\n\n    if (!this.checkAvailability()) {\n      throw new Error(\n        \"IndexedDB does not seem to be supported for your environment\",\n      );\n    }\n  }\n\n  /**\n   * Used for closing the indexeddb database.\n   */\n  closeDatabase() {\n    if (this.catalog && this.catalog.db) {\n      this.catalog.db.close();\n      this.catalog.db = null;\n    }\n  }\n\n  /**\n   * Used to check if adapter is available\n   *\n   * @returns {boolean} true if indexeddb is available, false if not.\n   */\n  checkAvailability() {\n    if (typeof indexedDB !== \"undefined\" && indexedDB) return true;\n    return false;\n  }\n\n  /**\n   * Retrieves a serialized db string from the catalog.\n   *\n   * @example\n   * // LOAD\n   * var idbAdapter = new LokiIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   *   db.loadDatabase(function(result) {\n   *   console.log('done');\n   * });\n   *\n   * @param {string} dbname - the name of the database to retrieve.\n   * @param {function} callback - callback should accept string param containing serialized db string.\n   */\n  loadDatabase(dbname: string, callback: (serialized: string) => void) {\n    const appName = this.app;\n    const adapter: IndexedDBAdapter = this;\n\n    // lazy open/create db reference so dont -need- callback in constructor\n    if (this.catalog === null || this.catalog.db === null) {\n      this.catalog = new SylvieCatalog((catalog) => {\n        adapter.catalog = catalog;\n        adapter.loadDatabase(dbname, callback);\n      });\n      return;\n    }\n\n    // lookup up db string in AKV db\n    this.catalog.getAppKey(appName, dbname, ({ id, val }) => {\n      if (typeof callback === \"function\") {\n        if (id === 0) {\n          callback(null);\n          return;\n        }\n        callback(val);\n      } else {\n        // support console use of api\n        console.log(val);\n      }\n    });\n  }\n\n  /**\n   * Saves a serialized db to the catalog.\n   *\n   * @example\n   * // SAVE : will save App/Key/Val as 'finance'/'test'/{serializedDb}\n   * var idbAdapter = new LokiIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   * var coll = db.addCollection('testColl');\n   * coll.insert({test: 'val'});\n   * db.saveDatabase();  // could pass callback if needed for async complete\n   *\n   * @param {string} dbname - the name to give the serialized database within the catalog.\n   * @param {string} dbstring - the serialized db string to save.\n   * @param {function} callback - (Optional) callback passed obj.success with true or false\n   * @memberof LokiIndexedAdapter\n   */\n  saveDatabase(\n    dbname: string,\n    dbstring: string,\n    callback?: (err: Error) => void,\n  ) {\n    const appName = this.app;\n    const adapter = this;\n\n    function saveCallback(result) {\n      if (result && result.success === true) {\n        callback(null);\n      } else {\n        callback(new Error(\"Error saving database\"));\n      }\n\n      if (adapter.options.closeAfterSave) {\n        adapter.closeDatabase();\n      }\n    }\n\n    // lazy open/create db reference so dont -need- callback in constructor\n    if (this.catalog === null || this.catalog.db === null) {\n      this.catalog = new SylvieCatalog(() => {\n        adapter.saveDatabase(dbname, dbstring, saveCallback);\n      });\n\n      return;\n    }\n\n    // set (add/update) entry to AKV database\n    this.catalog.setAppKey(appName, dbname, dbstring, saveCallback);\n  }\n\n  /**\n   * Deletes a serialized db from the catalog.\n   *\n   * @example\n   * // DELETE DATABASE\n   * // delete 'finance'/'test' value from catalog\n   * idbAdapter.deleteDatabase('test', function {\n   *   // database deleted\n   * });\n   *\n   * @param {string} dbname - the name of the database to delete from the catalog.\n   * @param {function=} callback - (Optional) executed on database delete\n   * @memberof LokiIndexedAdapter\n   */\n  deleteDatabase(dbname: string, callback?: (_: any) => any) {\n    const appName = this.app;\n    const adapter = this;\n\n    // lazy open/create db reference and pass callback ahead\n    if (this.catalog === null || this.catalog.db === null) {\n      this.catalog = new SylvieCatalog((catalog) => {\n        adapter.catalog = catalog;\n        adapter.deleteDatabase(dbname, callback);\n      });\n\n      return;\n    }\n\n    // catalog was already initialized, so just lookup object and delete by id\n    this.catalog.getAppKey(appName, dbname, (result) => {\n      const id = result.id;\n\n      if (id !== 0) {\n        adapter.catalog.deleteAppKey(id, callback);\n      } else if (typeof callback === \"function\") {\n        callback({ success: true });\n      }\n    });\n  }\n\n  /**\n   * Removes all database partitions and pages with the base filename passed in.\n   * This utility method does not (yet) guarantee async deletions will be completed before returning\n   *\n   * @param {string} dbname - the base filename which container, partitions, or pages are derived\n   * @memberof LokiIndexedAdapter\n   */\n  deleteDatabasePartitions(dbname) {\n    const self = this;\n    this.getDatabaseList((result) => {\n      result.forEach((str) => {\n        if (str.startsWith(dbname)) {\n          self.deleteDatabase(str);\n        }\n      });\n    });\n  }\n\n  /**\n   * Retrieves object array of catalog entries for current app.\n   *\n   * @example\n   * idbAdapter.getDatabaseList(function(result) {\n   *   // result is array of string names for that appcontext ('finance')\n   *   result.forEach(function(str) {\n   *     console.log(str);\n   *   });\n   * });\n   *\n   * @param {function} callback - should accept array of database names in the catalog for current app.\n   * @memberof LokiIndexedAdapter\n   */\n  getDatabaseList(callback) {\n    const appName = this.app;\n    const adapter = this;\n\n    // lazy open/create db reference so dont -need- callback in constructor\n    if (this.catalog === null || this.catalog.db === null) {\n      this.catalog = new SylvieCatalog((cat) => {\n        adapter.catalog = cat;\n\n        adapter.getDatabaseList(callback);\n      });\n\n      return;\n    }\n\n    // catalog already initialized\n    // get all keys for current appName, and transpose results so just string array\n    this.catalog.getAppKeys(appName, (results) => {\n      const names = [];\n\n      for (let idx = 0; idx < results.length; idx++) {\n        names.push(results[idx].key);\n      }\n\n      if (typeof callback === \"function\") {\n        callback(names);\n      } else {\n        names.forEach((obj) => {\n          console.log(obj);\n        });\n      }\n    });\n  }\n\n  /**\n   * Allows retrieval of list of all keys in catalog along with size\n   *\n   * @param {function} callback - (Optional) callback to accept result array.\n   * @memberof LokiIndexedAdapter\n   */\n  getCatalogSummary(callback) {\n    const appName = this.app;\n    const adapter = this;\n\n    // lazy open/create db reference\n    if (this.catalog === null || this.catalog.db === null) {\n      this.catalog = new SylvieCatalog((cat) => {\n        adapter.catalog = cat;\n\n        adapter.getCatalogSummary(callback);\n      });\n\n      return;\n    }\n\n    // catalog already initialized\n    // get all keys for current appName, and transpose results so just string array\n    this.catalog.getAllKeys((results) => {\n      const entries = [];\n      let obj;\n      let size;\n      let oapp;\n      let okey;\n      let oval;\n\n      for (let idx = 0; idx < results.length; idx++) {\n        obj = results[idx];\n        oapp = obj.app || \"\";\n        okey = obj.key || \"\";\n        oval = obj.val || \"\";\n\n        // app and key are composited into an appkey column so we will mult by 2\n        size = oapp.length * 2 + okey.length * 2 + oval.length + 1;\n\n        entries.push({ app: obj.app, key: obj.key, size: size });\n      }\n\n      if (typeof callback === \"function\") {\n        callback(entries);\n      } else {\n        entries.forEach((obj) => {\n          console.log(obj);\n        });\n      }\n    });\n  }\n}\n\n// alias\nIndexedDBAdapter.prototype.loadKey = IndexedDBAdapter.prototype.loadDatabase;\n\n// alias\nIndexedDBAdapter.prototype.saveKey = IndexedDBAdapter.prototype.saveDatabase;\n\n// alias\nIndexedDBAdapter.prototype.deleteKey =\n  IndexedDBAdapter.prototype.deleteDatabase;\n\n// alias\nIndexedDBAdapter.prototype.getKeyList =\n  IndexedDBAdapter.prototype.getDatabaseList;\n\n/**\n * LokiCatalog - underlying App/Key/Value catalog persistence\n *    This non-interface class implements the actual persistence.\n *    Used by the IndexedDBAdapter class.\n */\nclass SylvieCatalog {\n  db: IDBDatabase;\n  constructor(callback) {\n    this.db = null;\n    this.initializeLokiCatalog(callback);\n  }\n\n  initializeLokiCatalog(callback) {\n    const openRequest = indexedDB.open(\"SylvieCatalog\", 1);\n    const cat = this;\n\n    // If database doesn't exist yet or its version is lower than our version specified above (2nd param in line above)\n    openRequest.onupgradeneeded = ({ target }) => {\n      const thisDB = (target as any).result;\n      if (thisDB.objectStoreNames.contains(\"SylvieAKV\")) {\n        thisDB.deleteObjectStore(\"SylvieAKV\");\n      }\n\n      if (!thisDB.objectStoreNames.contains(\"SylvieAKV\")) {\n        const objectStore = thisDB.createObjectStore(\"SylvieAKV\", {\n          keyPath: \"id\",\n          autoIncrement: true,\n        });\n        objectStore.createIndex(\"app\", \"app\", { unique: false });\n        objectStore.createIndex(\"key\", \"key\", { unique: false });\n        // hack to simulate composite key since overhead is low (main size should be in val field)\n        // user (me) required to duplicate the app and key into comma delimited appkey field off object\n        // This will allow retrieving single record with that composite key as well as\n        // still supporting opening cursors on app or key alone\n        objectStore.createIndex(\"appkey\", \"appkey\", { unique: true });\n      }\n    };\n\n    openRequest.onsuccess = ({ target }) => {\n      cat.db = (target as any).result;\n\n      if (typeof callback === \"function\") callback(cat);\n    };\n\n    openRequest.onerror = (e) => {\n      throw e;\n    };\n  }\n\n  getAppKey(app, key, callback) {\n    const transaction = this.db.transaction([\"SylvieAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"SylvieAKV\");\n    const index = store.index(\"appkey\");\n    const appkey = `${app},${key}`;\n    const request = index.get(appkey);\n\n    request.onsuccess = (\n      (usercallback) =>\n      ({ target }) => {\n        let lres = (target as any).result;\n\n        if (lres === null || typeof lres === \"undefined\") {\n          lres = {\n            id: 0,\n            success: false,\n          };\n        }\n\n        if (typeof usercallback === \"function\") {\n          usercallback(lres);\n        } else {\n          console.log(lres);\n        }\n      }\n    )(callback);\n\n    request.onerror = ((usercallback) => (e) => {\n      if (typeof usercallback === \"function\") {\n        usercallback({ id: 0, success: false });\n      } else {\n        throw e;\n      }\n    })(callback);\n  }\n\n  getAppKeyById(id, callback, data) {\n    const transaction = this.db.transaction([\"SylvieAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"SylvieAKV\");\n    const request = store.get(id);\n\n    request.onsuccess = (\n      (data, usercallback) =>\n      ({ target }) => {\n        if (typeof usercallback === \"function\") {\n          usercallback((target as any).result, data);\n        } else {\n          console.log((target as any).result);\n        }\n      }\n    )(data, callback);\n  }\n\n  setAppKey(app, key, val, callback) {\n    const transaction = this.db.transaction([\"SylvieAKV\"], \"readwrite\");\n    const store = transaction.objectStore(\"SylvieAKV\");\n    const index = store.index(\"appkey\");\n    const appkey = `${app},${key}`;\n    const request = index.get(appkey);\n\n    // first try to retrieve an existing object by that key\n    // need to do this because to update an object you need to have id in object, otherwise it will append id with new autocounter and clash the unique index appkey\n    request.onsuccess = ({ target }) => {\n      let res = (target as any).result;\n\n      if (res === null || res === undefined) {\n        res = {\n          app,\n          key,\n          appkey: `${app},${key}`,\n          val,\n        };\n      } else {\n        res.val = val;\n      }\n\n      const requestPut = store.put(res);\n\n      requestPut.onerror = ((usercallback) => (e) => {\n        if (typeof usercallback === \"function\") {\n          usercallback({ success: false });\n        } else {\n          console.error(\"SylvieCatalog.setAppKey (set) onerror\");\n          console.error(request.error);\n        }\n      })(callback);\n\n      requestPut.onsuccess = ((usercallback) => (e) => {\n        if (typeof usercallback === \"function\") {\n          usercallback({ success: true });\n        }\n      })(callback);\n    };\n\n    request.onerror = ((usercallback) => (e) => {\n      if (typeof usercallback === \"function\") {\n        usercallback({ success: false });\n      } else {\n        console.error(\"SylvieCatalog.setAppKey (get) onerror\");\n        console.error(request.error);\n      }\n    })(callback);\n  }\n\n  deleteAppKey(id, callback: (result: { success: boolean }) => void) {\n    const transaction = this.db.transaction([\"SylvieAKV\"], \"readwrite\");\n    const store = transaction.objectStore(\"SylvieAKV\");\n    const request = store.delete(id);\n\n    request.onsuccess = ((usercallback) => (evt) => {\n      if (typeof usercallback === \"function\") usercallback({ success: true });\n    })(callback);\n\n    request.onerror = ((usercallback) => (evt) => {\n      if (typeof usercallback === \"function\") {\n        usercallback({ success: false });\n      } else {\n        console.error(\"SylvieCatalog.deleteAppKey raised onerror\");\n        console.error(request.error);\n      }\n    })(callback);\n  }\n\n  getAppKeys(app, callback) {\n    const transaction = this.db.transaction([\"SylvieAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"SylvieAKV\");\n    const index = store.index(\"app\");\n\n    // We want cursor to all values matching our (single) app param\n    const singleKeyRange = IDBKeyRange.only(app);\n\n    // To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n    const cursor = index.openCursor(singleKeyRange);\n\n    // cursor internally, pushing results into this.data[] and return\n    // this.data[] when done (similar to service)\n    const localdata = [];\n\n    cursor.onsuccess = (\n      (data, callback) =>\n      ({ target }) => {\n        const cursor = target.result;\n        if (cursor) {\n          const currObject = cursor.value;\n\n          data.push(currObject);\n\n          cursor.continue();\n        } else {\n          if (typeof callback === \"function\") {\n            callback(data);\n          } else {\n            console.log(data);\n          }\n        }\n      }\n    )(localdata, callback);\n\n    cursor.onerror = ((usercallback) => (e) => {\n      if (typeof usercallback === \"function\") {\n        usercallback(null);\n      } else {\n        console.error(\"SylvieCatalog.getAppKeys raised onerror\");\n        console.error(e);\n      }\n    })(callback);\n  }\n\n  // Hide 'cursoring' and return array of { id: id, key: key }\n  getAllKeys(callback) {\n    const transaction = this.db.transaction([\"SylvieAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"SylvieAKV\");\n    const cursor = store.openCursor();\n\n    const localdata = [];\n\n    cursor.onsuccess = (\n      (data, callback) =>\n      ({ target }) => {\n        const cursor = target.result;\n        if (cursor) {\n          const currObject = cursor.value;\n\n          data.push(currObject);\n\n          cursor.continue();\n        } else {\n          if (typeof callback === \"function\") {\n            callback(data);\n          } else {\n            console.log(data);\n          }\n        }\n      }\n    )(localdata, callback);\n\n    cursor.onerror = ((usercallback) => (e) => {\n      if (typeof usercallback === \"function\") usercallback(null);\n    })(callback);\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  Object.assign(window, { IndexedDBAdapter: IndexedDBAdapter });\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n/**\n * A loki persistence adapter which persists using node fs module\n * @constructor LokiFsAdapter\n */\n\nimport Sylvie from \"../modules/sylvie\";\nimport { NormalSyncPersistenceAdapter } from \"./persistence-adapter\";\n\nexport class FsAdapter implements NormalSyncPersistenceAdapter {\n  fs: any;\n  constructor() {\n    try {\n      this.fs = require(\"fs\");\n    } catch (e) {\n      this.fs = null;\n    }\n  }\n  mode: \"normal\";\n\n  /** loadDatabase() - Load data from file, will throw an error if the file does not exist\n   * @param {string} dbname - the filename of the database to load\n   * @param {function} callback - the callback to handle the result\n   * @memberof LokiFsAdapter\n   */\n  loadDatabase(dbname: string, callback: (value: any) => void): void {\n    const self = this;\n\n    this.fs.stat(dbname, (err, stats) => {\n      if (!err && stats.isFile()) {\n        self.fs.readFile(\n          dbname,\n          {\n            encoding: \"utf8\",\n          },\n          function readFileCallback(err, data) {\n            if (err) {\n              callback(new Error(err));\n            } else {\n              callback(data);\n            }\n          },\n        );\n      } else {\n        callback(null);\n      }\n    });\n  }\n\n  /**\n   * saveDatabase() - save data to file, will throw an error if the file can't be saved\n   * might want to expand this to avoid dataloss on partial save\n   * @param {string} dbname - the filename of the database to load\n   * @param {function} callback - the callback to handle the result\n   * @memberof LokiFsAdapter\n   */\n  saveDatabase(dbname, dbstring, callback) {\n    const self = this;\n    const tmpdbname = `${dbname}~`;\n    this.fs.writeFile(tmpdbname, dbstring, function writeFileCallback(err) {\n      if (err) {\n        callback(new Error(err));\n      } else {\n        self.fs.rename(tmpdbname, dbname, callback);\n      }\n    });\n  }\n\n  /**\n   * deleteDatabase() - delete the database file, will throw an error if the\n   * file can't be deleted\n   * @param {string} dbname - the filename of the database to delete\n   * @param {function} callback - the callback to handle the result\n   * @memberof LokiFsAdapter\n   */\n  deleteDatabase(dbname, callback) {\n    this.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n      if (err) {\n        callback(new Error(err));\n      } else {\n        callback();\n      }\n    });\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n\"use strict\";\n\nexport function deepProperty(obj, property, isDeep) {\n  if (isDeep === false) {\n    // pass without processing\n    return obj[property];\n  }\n  let pieces = property.split(\".\"),\n    root = obj;\n  while (pieces.length > 0) {\n    root = root[pieces.shift()];\n  }\n  return root;\n}\n", "/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\nimport { CloneMethods, clone } from \"./clone\";\n\nexport function cloneObjectArray(objarray: object[], method: CloneMethods) {\n  if (method == \"parse-stringify\") {\n    return clone(objarray, method);\n  }\n  var result = [];\n  for (var i = 0, len = objarray.length; i < len; i++) {\n    result[i] = clone(objarray[i], method);\n  }\n  return result;\n}\n", "/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\n\nimport { cloneObjectArray } from \"./clone-object-array\";\n\nexport type CloneMethods =\n  | \"parse-stringify\"\n  | \"shallow\"\n  | \"shallow-assign\"\n  | \"shallow-recurse-objects\";\n\nexport function clone<T = object>(data: T, method: CloneMethods): T {\n  if (data === null || data === undefined) {\n    return null;\n  }\n\n  var cloneMethod = method || \"parse-stringify\",\n    cloned;\n\n  switch (cloneMethod) {\n    case \"parse-stringify\":\n      cloned = JSON.parse(JSON.stringify(data));\n      break;\n    case \"shallow\":\n      // more compatible method for older browsers\n      cloned = Object.create(data.constructor.prototype);\n      Object.keys(data).map(function (i) {\n        cloned[i] = data[i];\n      });\n      break;\n    case \"shallow-assign\":\n      // should be supported by newer environments/browsers\n      cloned = Object.create(data.constructor.prototype);\n      Object.assign(cloned, data);\n      break;\n    case \"shallow-recurse-objects\":\n      // shallow clone top level properties\n      cloned = clone(data, \"shallow\");\n      var keys = Object.keys(data);\n      // for each of the top level properties which are object literals, recursively shallow copy\n      keys.forEach(function (key) {\n        if (\n          typeof data[key] === \"object\" &&\n          data[key].constructor.name === \"Object\"\n        ) {\n          cloned[key] = clone(data[key], \"shallow-recurse-objects\");\n        } else if (Array.isArray(data[key])) {\n          cloned[key] = cloneObjectArray(data[key], \"shallow-recurse-objects\");\n        }\n      });\n      break;\n    default:\n      break;\n  }\n\n  return cloned;\n}\n", "/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\nimport { clone } from \"./clone\";\n\nexport function freeze<T = object>(obj: T): void {\n  if (!Object.isFrozen(obj)) {\n    Object.freeze(obj);\n  }\n}\n\nexport function deepFreeze<T = object>(obj: T) {\n  var prop, i;\n  if (Array.isArray(obj)) {\n    for (i = 0; i < obj.length; i++) {\n      deepFreeze(obj[i]);\n    }\n    freeze(obj);\n  } else if (obj !== null && typeof obj === \"object\") {\n    for (prop in obj) {\n      if (Object.hasOwn(obj, prop)) {\n        deepFreeze(obj[prop]);\n      }\n    }\n    freeze(obj);\n  }\n}\n\nexport function unFreeze<T = object>(obj: T) {\n  if (!Object.isFrozen(obj)) {\n    return obj;\n  }\n  return clone(obj, \"shallow\");\n}\n", "import { clone } from \"./clone\";\nimport { Utils } from \"./index\";\n\n/* eslint-disable no-var */\nexport const copyProperties = function (src, dest) {\n  var prop;\n  for (prop in src) {\n    dest[prop] = src[prop];\n  }\n};\n// used to recursively scan hierarchical transform step object for param substitution\nexport const resolveTransformObject = function (\n  subObj,\n  params,\n  depth?: number,\n) {\n  var prop, pname;\n\n  if (typeof depth !== \"number\") {\n    depth = 0;\n  }\n\n  if (++depth >= 10) return subObj;\n\n  for (prop in subObj) {\n    if (\n      typeof subObj[prop] === \"string\" &&\n      subObj[prop].indexOf(\"[%lktxp]\") === 0\n    ) {\n      pname = subObj[prop].substring(8);\n      if (Object.hasOwn(params, pname)) {\n        subObj[prop] = params[pname];\n      }\n    } else if (typeof subObj[prop] === \"object\") {\n      subObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n    }\n  }\n\n  return subObj;\n};\n// top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\nexport const resolveTransformParams = function (transform, params) {\n  var idx,\n    clonedStep,\n    resolvedTransform = [];\n\n  if (typeof params === \"undefined\") return transform;\n\n  // iterate all steps in the transform array\n  for (idx = 0; idx < transform.length; idx++) {\n    // clone transform so our scan/replace can operate directly on cloned transform\n    clonedStep = clone(transform[idx], \"shallow-recurse-objects\");\n    resolvedTransform.push(resolveTransformObject(clonedStep, params));\n  }\n\n  return resolvedTransform;\n};\n\n// By default (if usingDotNotation is false), looks up path in\n// object via `object[path]`\n//\n// If `usingDotNotation` is true, then the path is assumed to\n// represent a nested path. It can be in the form of an array of\n// field names, or a period delimited string. The function will\n// look up the value of object[path[0]], and then call\n// result[path[1]] on the result, etc etc.\n//\n// If `usingDotNotation` is true, this function still supports\n// non nested fields.\n//\n// `usingDotNotation` is a performance optimization. The caller\n// may know that a path is *not* nested. In which case, this\n// function avoids a costly string.split('.')\n//\n// examples:\n// getIn({a: 1}, \"a\") => 1\n// getIn({a: 1}, \"a\", true) => 1\n// getIn({a: {b: 1}}, [\"a\", \"b\"], true) => 1\n// getIn({a: {b: 1}}, \"a.b\", true) => 1\nexport const getIn = function (\n  object: object,\n  path: string | string[],\n  usingDotNotation?: boolean,\n) {\n  if (object == null) {\n    return undefined;\n  }\n  if (!usingDotNotation) {\n    return object[path as string];\n  }\n\n  if (typeof path === \"string\") {\n    path = path.split(\".\");\n  }\n\n  if (!Array.isArray(path)) {\n    throw new Error(\"path must be a string or array. Found \" + typeof path);\n  }\n\n  var index = 0,\n    length = path.length;\n\n  while (object != null && index < length) {\n    object = object[path[index++]];\n  }\n  return index && index == length ? object : undefined;\n};\n", "/**\n * General utils, including statistical functions\n */\nexport function isDeepProperty(field) {\n  return field.indexOf(\".\") !== -1;\n}\n\nexport function add(a, b) {\n  return a + b;\n}\n\nexport function sub(a, b) {\n  return a - b;\n}\n\nexport function average(array) {\n  return array.reduce(add, 0) / array.length;\n}\n\nexport function standardDeviation(values) {\n  const avg = average(values);\n  const squareDiffs = values.map(function (value) {\n    const diff = value - avg;\n    const sqrDiff = diff * diff;\n    return sqrDiff;\n  });\n\n  const avgSquareDiff = average(squareDiffs);\n\n  const stdDev = Math.sqrt(avgSquareDiff);\n  return stdDev;\n}\n", "/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\n\"use strict\";\n\nexport function containsCheckFn(a) {\n  if (typeof a === \"string\" || Array.isArray(a)) {\n    return function (b) {\n      return a.indexOf(b) !== -1;\n    };\n  } else if (typeof a === \"object\" && a !== null) {\n    return function (b) {\n      return Object.hasOwn(a, b);\n    };\n  }\n  return null;\n}\n", "/* eslint-disable no-prototype-builtins */\n\n\"use strict\";\n/**\n * dotSubScan - helper function used for dot notation queries.\n *\n * @param {object} root - object to traverse\n * @param {array} paths - array of properties to drill into\n * @param {function} fun - evaluation function to test with\n * @param {any} value - comparative value to also pass to (compare) fun\n * @param {any} extra - extra arg to also pass to compare fun\n * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n */\n\nexport function dotSubScan(\n  root: object,\n  paths: string[],\n  fun: (_0, _1, _2) => boolean,\n  value,\n  extra,\n  poffset?: number,\n) {\n  const pathOffset = poffset || 0;\n  const path = paths[pathOffset];\n  let valueFound = false;\n  let element;\n  if (root !== null && typeof root === \"object\" && path in root) {\n    element = root[path];\n  }\n  if (pathOffset + 1 >= paths.length) {\n    // if we have already expanded out the dot notation,\n    // then just evaluate the test function and value on the element\n    valueFound = fun(element, value, extra);\n  } else if (Array.isArray(element)) {\n    for (let index = 0, len = element.length; index < len; index += 1) {\n      valueFound = dotSubScan(\n        element[index],\n        paths,\n        fun,\n        value,\n        extra,\n        pathOffset + 1,\n      );\n      if (valueFound === true) {\n        break;\n      }\n    }\n  } else {\n    valueFound = dotSubScan(element, paths, fun, value, extra, pathOffset + 1);\n  }\n\n  return valueFound;\n}\n", "/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\nimport { Utils } from \"./index\";\n\nexport var Comparators = {\n  aeq: aeqHelper,\n  lt: ltHelper,\n  gt: gtHelper,\n};\n\n/** Helper function for determining 'loki' abstract equality which is a little more abstract than ==\n *     aeqHelper(5, '5') === true\n *     aeqHelper(5.0, '5') === true\n *     aeqHelper(new Date(\"1/1/2011\"), new Date(\"1/1/2011\")) === true\n *     aeqHelper({a:1}, {z:4}) === true (all objects sorted equally)\n *     aeqHelper([1, 2, 3], [1, 3]) === false\n *     aeqHelper([1, 2, 3], [1, 2, 3]) === true\n *     aeqHelper(undefined, null) === true\n */\nexport function aeqHelper(\n  prop1: boolean | string | number,\n  prop2: boolean | string | number,\n) {\n  var cv1, cv2, t1, t2;\n\n  if (prop1 === prop2) return true;\n\n  // 'falsy' and Boolean handling\n  if (\n    !prop1 ||\n    !prop2 ||\n    prop1 === true ||\n    prop2 === true ||\n    prop1 !== prop1 ||\n    prop2 !== prop2\n  ) {\n    // dates and NaN conditions (typed dates before serialization)\n    switch (prop1) {\n      case undefined:\n        t1 = 1;\n        break;\n      case null:\n        t1 = 1;\n        break;\n      case false:\n        t1 = 3;\n        break;\n      case true:\n        t1 = 4;\n        break;\n      case \"\":\n        t1 = 5;\n        break;\n      default:\n        t1 = prop1 === prop1 ? 9 : 0;\n        break;\n    }\n\n    switch (prop2) {\n      case undefined:\n        t2 = 1;\n        break;\n      case null:\n        t2 = 1;\n        break;\n      case false:\n        t2 = 3;\n        break;\n      case true:\n        t2 = 4;\n        break;\n      case \"\":\n        t2 = 5;\n        break;\n      default:\n        t2 = prop2 === prop2 ? 9 : 0;\n        break;\n    }\n\n    // one or both is edge case\n    if (t1 !== 9 || t2 !== 9) {\n      return t1 === t2;\n    }\n  }\n\n  // Handle 'Number-like' comparisons\n  cv1 = Number(prop1);\n  cv2 = Number(prop2);\n\n  // if one or both are 'number-like'...\n  if (cv1 === cv1 || cv2 === cv2) {\n    return cv1 === cv2;\n  }\n\n  // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n  cv1 = prop1.toString();\n  cv2 = prop2.toString();\n\n  return cv1 == cv2;\n}\n\n/** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n */\nexport function ltHelper(\n  prop1: number | boolean | string,\n  prop2: number | boolean | string,\n  equal: boolean,\n): boolean {\n  var cv1, cv2, t1, t2;\n\n  // if one of the params is falsy or strictly true or not equal to itself\n  // 0, 0.0, \"\", NaN, null, undefined, not defined, false, true\n  if (\n    !prop1 ||\n    !prop2 ||\n    prop1 === true ||\n    prop2 === true ||\n    prop1 !== prop1 ||\n    prop2 !== prop2\n  ) {\n    switch (prop1) {\n      case undefined:\n        t1 = 1;\n        break;\n      case null:\n        t1 = 1;\n        break;\n      case false:\n        t1 = 3;\n        break;\n      case true:\n        t1 = 4;\n        break;\n      case \"\":\n        t1 = 5;\n        break;\n      // if strict equal probably 0 so sort higher, otherwise probably NaN so sort lower than even null\n      default:\n        t1 = prop1 === prop1 ? 9 : 0;\n        break;\n    }\n\n    switch (prop2) {\n      case undefined:\n        t2 = 1;\n        break;\n      case null:\n        t2 = 1;\n        break;\n      case false:\n        t2 = 3;\n        break;\n      case true:\n        t2 = 4;\n        break;\n      case \"\":\n        t2 = 5;\n        break;\n      default:\n        t2 = prop2 === prop2 ? 9 : 0;\n        break;\n    }\n\n    // one or both is edge case\n    if (t1 !== 9 || t2 !== 9) {\n      return t1 === t2 ? equal : t1 < t2;\n    }\n  }\n\n  // if both are numbers (string encoded or not), compare as numbers\n  cv1 = Number(prop1);\n  cv2 = Number(prop2);\n\n  if (cv1 === cv1 && cv2 === cv2) {\n    if (cv1 < cv2) return true;\n    if (cv1 > cv2) return false;\n    return equal;\n  }\n\n  if (cv1 === cv1 && cv2 !== cv2) {\n    return true;\n  }\n\n  if (cv2 === cv2 && cv1 !== cv1) {\n    return false;\n  }\n\n  if (prop1 < prop2) return true;\n  if (prop1 > prop2) return false;\n  if (prop1 == prop2) return equal;\n\n  // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n  cv1 = prop1.toString();\n  cv2 = prop2.toString();\n\n  if (cv1 < cv2) {\n    return true;\n  }\n\n  if (cv1 == cv2) {\n    return equal;\n  }\n\n  return false;\n}\n\nexport function gtHelper(\n  prop1: number | boolean | string,\n  prop2: number | boolean | string,\n  equal: boolean,\n): boolean {\n  var cv1, cv2, t1, t2;\n\n  // 'falsy' and Boolean handling\n  if (\n    !prop1 ||\n    !prop2 ||\n    prop1 === true ||\n    prop2 === true ||\n    prop1 !== prop1 ||\n    prop2 !== prop2\n  ) {\n    switch (prop1) {\n      case undefined:\n        t1 = 1;\n        break;\n      case null:\n        t1 = 1;\n        break;\n      case false:\n        t1 = 3;\n        break;\n      case true:\n        t1 = 4;\n        break;\n      case \"\":\n        t1 = 5;\n        break;\n      // NaN 0\n      default:\n        t1 = prop1 === prop1 ? 9 : 0;\n        break;\n    }\n\n    switch (prop2) {\n      case undefined:\n        t2 = 1;\n        break;\n      case null:\n        t2 = 1;\n        break;\n      case false:\n        t2 = 3;\n        break;\n      case true:\n        t2 = 4;\n        break;\n      case \"\":\n        t2 = 5;\n        break;\n      default:\n        t2 = prop2 === prop2 ? 9 : 0;\n        break;\n    }\n\n    // one or both is edge case\n    if (t1 !== 9 || t2 !== 9) {\n      return t1 === t2 ? equal : t1 > t2;\n    }\n  }\n\n  // if both are numbers (string encoded or not), compare as numbers\n  cv1 = Number(prop1);\n  cv2 = Number(prop2);\n  if (cv1 === cv1 && cv2 === cv2) {\n    if (cv1 > cv2) return true;\n    if (cv1 < cv2) return false;\n    return equal;\n  }\n\n  if (cv1 === cv1 && cv2 !== cv2) {\n    return false;\n  }\n\n  if (cv2 === cv2 && cv1 !== cv1) {\n    return true;\n  }\n\n  if (prop1 > prop2) return true;\n  if (prop1 < prop2) return false;\n  if (prop1 == prop2) return equal;\n\n  // not strict equal nor less than nor gt so must be dates or mixed types\n  // convert to string and use that to compare\n  cv1 = prop1.toString();\n  cv2 = prop2.toString();\n\n  if (cv1 > cv2) {\n    return true;\n  }\n\n  if (cv1 == cv2) {\n    return equal;\n  }\n\n  return false;\n}\n\n// wrapping in object to expose to default export for potential user override.\n// warning: overriding these methods will override behavior for all loki db instances in memory.\n// warning: if you use binary indices these comparators should be the same for all inserts/updates/removes.\n\nexport function sortHelper(\n  prop1: string | number | boolean,\n  prop2: string | number | boolean,\n  desc: boolean,\n) {\n  if (Comparators.aeq(prop1, prop2)) return 0;\n\n  if (Comparators.lt(prop1, prop2, false)) {\n    return desc ? 1 : -1;\n  }\n\n  if (Comparators.gt(prop1, prop2, false)) {\n    return desc ? -1 : 1;\n  }\n\n  // not lt, not gt so implied equality-- date compatible\n  return 0;\n}\n\n/**\n * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n *\n * @param {array} properties - array of property names, in order, by which to evaluate sort order\n * @param {object} obj1 - first object to compare\n * @param {object} obj2 - second object to compare\n * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n */\nexport function compoundeval(\n  properties: Array<any>,\n  obj1: object,\n  obj2: object,\n): number {\n  var res = 0;\n  var prop, field, val1, val2, arr;\n  for (var i = 0, len = properties.length; i < len; i++) {\n    prop = properties[i];\n    field = prop[0];\n    if (~field.indexOf(\".\")) {\n      arr = field.split(\".\");\n      val1 = Utils.getIn(obj1, arr, true);\n      val2 = Utils.getIn(obj2, arr, true);\n    } else {\n      val1 = obj1[field];\n      val2 = obj2[field];\n    }\n    res = sortHelper(val1, val2, prop[1]);\n    if (res !== 0) {\n      return res;\n    }\n  }\n  return 0;\n}\n", "/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\nimport { containsCheckFn } from \"./containsCheckFn\";\nimport { dotSubScan } from \"./dotSubScan\";\nimport { Comparators } from \"./sort\";\n\nexport function doQueryOp<T>(val, op, record: T) {\n  for (var p in op) {\n    if (Object.hasOwn(op, p)) {\n      return LokiOps[p](val, op[p], record);\n    }\n  }\n  return false;\n}\n\n// comparison operators\n// a is the value in the collection\n// b is the query value\nexport const LokiOps = {\n  $eq: function (a, b) {\n    return a === b;\n  },\n\n  // abstract/loose equality\n  $aeq: function (a, b) {\n    return a == b;\n  },\n\n  $ne: function (a, b) {\n    // ecma 5 safe test for NaN\n    if (b !== b) {\n      // ecma 5 test value is not NaN\n      return a === a;\n    }\n\n    return a !== b;\n  },\n  // date equality / loki abstract equality test\n  $dteq: function (a, b) {\n    return Comparators.aeq(a, b);\n  },\n\n  // loki comparisons: return identical unindexed results as indexed comparisons\n  $gt: function (a, b) {\n    return Comparators.gt(a, b, false);\n  },\n\n  $gte: function (a, b) {\n    return Comparators.gt(a, b, true);\n  },\n\n  $lt: function (a, b) {\n    return Comparators.lt(a, b, false);\n  },\n\n  $lte: function (a, b) {\n    return Comparators.lt(a, b, true);\n  },\n\n  // lightweight javascript comparisons\n  $jgt: function (a, b) {\n    return a > b;\n  },\n\n  $jgte: function (a, b) {\n    return a >= b;\n  },\n\n  $jlt: function (a, b) {\n    return a < b;\n  },\n\n  $jlte: function (a, b) {\n    return a <= b;\n  },\n\n  // ex : coll.find({'orderCount': {$between: [10, 50]}});\n  $between: function (a, vals: [number, number]) {\n    if (a === undefined || a === null) return false;\n    return Comparators.gt(a, vals[0], true) && Comparators.lt(a, vals[1], true);\n  },\n\n  $jbetween: function (a, vals: [number, number]) {\n    if (a === undefined || a === null) return false;\n    return a >= vals[0] && a <= vals[1];\n  },\n\n  $in: function (a, b) {\n    return b.indexOf(a) !== -1;\n  },\n\n  $inSet: function (a, b) {\n    return b.has(a);\n  },\n\n  $nin: function (a, b) {\n    return b.indexOf(a) === -1;\n  },\n\n  $keyin: function (a, b) {\n    return a in b;\n  },\n\n  $nkeyin: function (a, b) {\n    return !(a in b);\n  },\n\n  $definedin: function (a, b) {\n    return b[a] !== undefined;\n  },\n\n  $undefinedin: function (a, b) {\n    return b[a] === undefined;\n  },\n\n  $regex: function (a, b) {\n    return b.test(a);\n  },\n\n  $containsString: function (a, b) {\n    return typeof a === \"string\" && a.indexOf(b) !== -1;\n  },\n\n  $containsNone: function (a, b) {\n    return !LokiOps.$containsAny(a, b);\n  },\n\n  $containsAny: function (a, b) {\n    var checkFn = containsCheckFn(a);\n    if (checkFn !== null) {\n      return Array.isArray(b) ? b.some(checkFn) : checkFn(b);\n    }\n    return false;\n  },\n\n  $contains: function (a, b) {\n    var checkFn = containsCheckFn(a);\n    if (checkFn !== null) {\n      return Array.isArray(b) ? b.every(checkFn) : checkFn(b);\n    }\n    return false;\n  },\n\n  $elemMatch: function (a, b) {\n    if (Array.isArray(a)) {\n      return a.some(function (item) {\n        return Object.keys(b).every(function (property) {\n          var filter = b[property];\n          if (!(typeof filter === \"object\" && filter)) {\n            filter = { $eq: filter };\n          }\n\n          if (property.indexOf(\".\") !== -1) {\n            return dotSubScan(\n              item,\n              property.split(\".\"),\n              doQueryOp,\n              b[property],\n              item,\n            );\n          }\n          return doQueryOp(item[property], filter, item);\n        });\n      });\n    }\n    return false;\n  },\n\n  $type: function <T>(a, b, record: T) {\n    var type: typeof a | \"array\" | \"date\" = typeof a;\n    if (type === \"object\") {\n      if (Array.isArray(a)) {\n        type = \"array\";\n      } else if (a instanceof Date) {\n        type = \"date\";\n      }\n    }\n    return typeof b !== \"object\" ? type === b : doQueryOp(type, b, record);\n  },\n\n  $finite: function (a, b) {\n    return b === isFinite(a);\n  },\n\n  $size: function <T>(a, b, record: T) {\n    if (Array.isArray(a)) {\n      return typeof b !== \"object\"\n        ? a.length === b\n        : doQueryOp(a.length, b, record);\n    }\n    return false;\n  },\n\n  $len: function <T>(a, b, record: T) {\n    if (typeof a === \"string\") {\n      return typeof b !== \"object\"\n        ? a.length === b\n        : doQueryOp(a.length, b, record);\n    }\n    return false;\n  },\n\n  $where: function (a, b) {\n    return b(a) === true;\n  },\n\n  // field-level logical operators\n  // a is the value in the collection\n  // b is the nested query operation (for '$not')\n  //   or an array of nested query operations (for '$and' and '$or')\n  $not: function <T>(a, b, record: T) {\n    return !doQueryOp(a, b, record);\n  },\n\n  $and: function <T>(a, b, record: T) {\n    for (var idx = 0, len = b.length; idx < len; idx += 1) {\n      if (!doQueryOp(a, b[idx], record)) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  $or: function <T>(a, b, record: T) {\n    for (var idx = 0, len = b.length; idx < len; idx += 1) {\n      if (doQueryOp(a, b[idx], record)) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  $exists: function (a, b) {\n    if (b) {\n      return a !== undefined;\n    } else {\n      return a === undefined;\n    }\n  },\n};\n\n// ops that can be used with { $$op: 'column-name' } syntax\nexport const valueLevelOps = <const>[\n  \"$eq\",\n  \"$aeq\",\n  \"$ne\",\n  \"$dteq\",\n  \"$gt\",\n  \"$gte\",\n  \"$lt\",\n  \"$lte\",\n  \"$jgt\",\n  \"$jgte\",\n  \"$jlt\",\n  \"$jlte\",\n  \"$type\",\n];\n\nvalueLevelOps.forEach(function (op) {\n  var fun = LokiOps[op];\n  LokiOps[\"$\" + op] = function <T>(a: any, spec: (_: T) => void, record: T) {\n    if (typeof spec === \"string\") {\n      return (fun as (a: any, b: any) => boolean)(a, record[spec]);\n    } else if (typeof spec === \"function\") {\n      return (fun as (a: any, b: any) => boolean)(a, spec(record));\n    } else {\n      throw new Error(\"Invalid argument to $$ matcher\");\n    }\n  };\n});\n\n// if an op is registered in this object, our 'calculateRange' can use it with our binary indices.\n// if the op is registered to a function, we will run that function/op as a 2nd pass filter on results.\n// those 2nd pass filter functions should be similar to LokiOps functions, accepting 2 vals to compare.\nexport const indexedOps = {\n  $eq: LokiOps.$eq,\n  $aeq: true,\n  $dteq: true,\n  $gt: true,\n  $gte: true,\n  $lt: true,\n  $lte: true,\n  $in: true,\n  $between: true,\n};\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n\"use strict\";\n// precompile recursively\n\nexport function precompileQuery(operator, value) {\n  // for regex ops, precompile\n  if (operator === \"$regex\") {\n    if (Array.isArray(value)) {\n      value = new RegExp(value[0], value[1]);\n    } else if (!(value instanceof RegExp)) {\n      value = new RegExp(value);\n    }\n  } else if (typeof value === \"object\") {\n    for (const key in value) {\n      if (key === \"$regex\" || typeof value[key] === \"object\") {\n        value[key] = precompileQuery(key, value[key]);\n      }\n    }\n  }\n\n  return value;\n}\n", "/* eslint-disable no-var */\n/* eslint-disable @typescript-eslint/no-this-alias */\n/**\n * Resultset class allowing chainable queries.  Intended to be instanced internally.\n *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n *\n * @example\n *    mycollection.chain()\n *      .find({ 'doors' : 4 })\n *      .where(function(obj) { return obj.name === 'Toyota' })\n *      .data();\n *\n * @constructor Resultset\n * @param {Collection} collection - The collection which this Resultset will query against.\n */\n\nimport { hasOwnProperty } from \"../sylviejs\";\nimport { precompileQuery } from \"../utils/precompile-query\";\nimport { CloneMethods, clone } from \"../utils/clone\";\nimport { dotSubScan } from \"../utils/dotSubScan\";\nimport { Utils } from \"../utils/index\";\nimport { indexedOps, LokiOps, valueLevelOps } from \"../utils/ops\";\nimport { sortHelper, compoundeval } from \"../utils/sort\";\nimport { ChainTransform, Collection, CollectionDocument } from \"./collection\";\n\nexport type MongoLikeOps =\n  | (typeof valueLevelOps)[number]\n  | \"$regex\"\n  | \"$in\"\n  | \"$inSet\";\n\nexport class ResultSet<RST extends Partial<CollectionDocument>> {\n  options: Record<string, any>;\n  collection: Collection<RST>;\n  filteredrows: number[];\n  filterInitialized: boolean;\n  disableFreeze: boolean;\n  rightData: RST[];\n\n  constructor(collection: Collection<RST>, options?: Record<string, any>) {\n    this.options = options || {};\n\n    // retain reference to collection we are querying against\n    this.collection = collection;\n    this.filteredrows = [];\n    this.filterInitialized = false;\n\n    return this;\n  }\n\n  /**\n   * reset() - Reset the resultset to its initial state.\n   *\n   * @returns {ResultSet} Reference to this resultset, for future chain operations.\n   */\n  reset(): ResultSet<RST> {\n    if (this.filteredrows.length > 0) {\n      this.filteredrows = [];\n    }\n    this.filterInitialized = false;\n    return this;\n  }\n\n  /**\n   * toJSON() - Override of toJSON to avoid circular references\n   *\n   */\n  toJSON(): ResultSet<RST> {\n    const copy = this.copy();\n    copy.collection = null;\n    return copy;\n  }\n\n  /**\n   * Allows you to limit the number of documents passed to next chain operation.\n   *    A resultset copy() is made to avoid altering original resultset.\n   *\n   * @param {int} qty - The number of documents to return.\n   * @returns {ResultSet} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n   * @memberof Resultset\n   * // find the two oldest users\n   * var result = users.chain().simplesort(\"age\", true).limit(2).data();\n   */\n  limit(qty: number): ResultSet<RST> {\n    // if this has no filters applied, we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    const rscopy = new ResultSet(this.collection);\n    rscopy.filteredrows = this.filteredrows.slice(0, qty);\n    rscopy.filterInitialized = true;\n    return rscopy;\n  }\n\n  /**\n   * Used for skipping 'pos' number of documents in the resultset.\n   *\n   * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n   * @returns {ResultSet} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n   * @memberof Resultset\n   * // find everyone but the two oldest users\n   * var result = users.chain().simplesort(\"age\", true).offset(2).data();\n   */\n  offset(pos: number): ResultSet<RST> {\n    // if this has no filters applied, we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    const rscopy = new ResultSet(this.collection);\n    rscopy.filteredrows = this.filteredrows.slice(pos);\n    rscopy.filterInitialized = true;\n    return rscopy;\n  }\n\n  /**\n   * copy() - To support reuse of resultset in branched query situations.\n   *\n   * @returns {ResultSet} Returns a copy of the resultset (set) but the underlying document references will be the same.\n   * @memberof Resultset\n   */\n  copy(): ResultSet<RST> {\n    const result = new ResultSet(this.collection);\n\n    if (this.filteredrows.length > 0) {\n      result.filteredrows = this.filteredrows.slice();\n    }\n    result.filterInitialized = this.filterInitialized;\n\n    return result;\n  }\n\n  /**\n   * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n   *\n   * @param transform {(string|array)} - name of collection transform or raw transform array\n   * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n   * @returns {ResultSet} either (this) resultset or a clone of of this resultset (depending on steps)\n   * @memberof Resultset\n   * @example\n   * users.addTransform('CountryFilter', [\n   *   {\n   *     type: 'find',\n   *     value: {\n   *       'country': { $eq: '[%lktxp]Country' }\n   *     }\n   *   },\n   *   {\n   *     type: 'simplesort',\n   *     property: 'age',\n   *     options: { desc: false}\n   *   }\n   * ]);\n   * var results = users.chain().transform(\"CountryFilter\", { Country: 'fr' }).data();\n   */\n  transform(\n    transform: ChainTransform,\n    parameters?: Record<string, any>,\n  ): ResultSet<RST> | any {\n    let idx;\n    let step;\n    let rs: ResultSet<RST> = this;\n\n    // if transform is name, then do lookup first\n    if (typeof transform === \"string\") {\n      if (Object.hasOwn(this.collection.transforms, transform)) {\n        transform = this.collection.transforms[transform];\n      }\n    }\n\n    // either they passed in raw transform array or we looked it up, so process\n    if (typeof transform !== \"object\" || !Array.isArray(transform)) {\n      throw new Error(\"Invalid transform\");\n    }\n\n    if (typeof parameters !== \"undefined\") {\n      transform = Utils.resolveTransformParams(transform, parameters);\n    }\n\n    for (idx = 0; idx < transform.length; idx++) {\n      step = transform[idx];\n\n      switch (step.type) {\n        case \"find\":\n          rs.find(step.value);\n          break;\n        case \"where\":\n          rs.where(step.value);\n          break;\n        case \"simplesort\":\n          rs.simplesort(step.property, step.desc || step.options);\n          break;\n        case \"compoundsort\":\n          rs.compoundsort(step.value);\n          break;\n        case \"sort\":\n          rs.sort(step.value);\n          break;\n        case \"limit\":\n          rs = rs.limit(step.value);\n          break; // limit makes copy so update reference\n        case \"offset\":\n          rs = rs.offset(step.value);\n          break; // offset makes copy so update reference\n        case \"map\":\n          rs = rs.map(step.value, step.dataOptions);\n          break;\n        case \"eqJoin\":\n          rs = rs.eqJoin(\n            step.joinData,\n            step.leftJoinKey,\n            step.rightJoinKey,\n            step.mapFun,\n            step.dataOptions,\n          );\n          break;\n        // following cases break chain by returning array data so make any of these last in transform steps\n        case \"mapReduce\":\n          rs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n          break;\n        // following cases update documents in current filtered resultset (use carefully)\n        case \"update\":\n          rs.update(step.value);\n          break;\n        case \"remove\":\n          rs.remove();\n          break;\n        default:\n          break;\n      }\n    }\n\n    return rs as unknown as ResultSet<RST>;\n  }\n\n  /**\n   * User supplied compare function is provided two documents to compare. (chainable)\n   * @example\n   *    rslt.sort(function(obj1, obj2) {\n   *      if (obj1.name === obj2.name) return 0;\n   *      if (obj1.name > obj2.name) return 1;\n   *      if (obj1.name < obj2.name) return -1;\n   *    });\n   *\n   * @param {function} comparefun - A javascript compare function used for sorting.\n   * @returns {ResultSet} Reference to this resultset, sorted, for future chain operations.\n   * @memberof Resultset\n   */\n  sort(comparefun: (a: any, b: any) => number): ResultSet<RST> {\n    // if this has no filters applied, just we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    const wrappedComparer = (\n      (userComparer, data) => (a, b) =>\n        userComparer(data[a], data[b])\n    )(comparefun, this.collection.data);\n\n    this.filteredrows.sort(wrappedComparer);\n\n    return this;\n  }\n\n  /**\n   * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n   *    Sorting based on the same lt/gt helper functions used for binary indices.\n   *\n   * @param {string} propname - name of property to sort by.\n   * @param {object|bool=} options - boolean to specify if isdescending, or options object\n   * @param {boolean} [options.desc=false] - whether to sort descending\n   * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.\n   * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).\n   * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.\n   * @returns {ResultSet} Reference to this resultset, sorted, for future chain operations.\n   * @memberof Resultset\n   * @example\n   * var results = users.chain().simplesort('age').data();\n   */\n  simplesort(\n    propname: string,\n    options?:\n      | Partial<{\n          desc: boolean;\n          disableIndexIntersect: boolean;\n          forceIndexIntersect: boolean;\n          useJavascriptSorting: boolean;\n        }>\n      | boolean,\n  ): ResultSet<RST> {\n    let eff;\n    let targetEff = 10;\n    const dc = this.collection.data.length;\n    const frl = this.filteredrows.length;\n    const hasBinaryIndex = Object.hasOwn(\n      this.collection.binaryIndices,\n      propname,\n    );\n\n    if (typeof options === \"undefined\" || options === false) {\n      options = { desc: false };\n    }\n    if (options === true) {\n      options = { desc: true };\n    }\n\n    // if nothing in filtered rows array...\n    if (frl === 0) {\n      // if the filter is initialized to be empty resultset, do nothing\n      if (this.filterInitialized) {\n        return this;\n      }\n\n      // otherwise no filters applied implies all documents, so we need to populate filteredrows first\n\n      // if we have a binary index, we can just use that instead of sorting (again)\n      if (Object.hasOwn(this.collection.binaryIndices, propname)) {\n        // make sure index is up-to-date\n        this.collection.ensureIndex(propname);\n        // copy index values into filteredrows\n        this.filteredrows =\n          this.collection.binaryIndices[propname].values.slice(0);\n\n        if (options.desc) {\n          this.filteredrows.reverse();\n        }\n\n        // we are done, return this (resultset) for further chain ops\n        return this;\n      }\n      // otherwise initialize array for sort below\n      else {\n        // build full document index (to be sorted subsequently)\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n    }\n    // otherwise we had results to begin with, see if we qualify for index intercept optimization\n    else {\n      // If already filtered, but we want to leverage binary index on sort.\n      // This will use custom array intection algorithm.\n      if (!options.disableIndexIntersect && hasBinaryIndex) {\n        // calculate filter efficiency\n        eff = dc / frl;\n\n        // when javascript sort fallback is enabled, you generally need more than ~17% of total docs in resultset\n        // before array intersect is determined to be the faster algorithm, otherwise leave at 10% for loki sort.\n        if (options.useJavascriptSorting) {\n          targetEff = 6;\n        }\n\n        // anything more than ratio of 10:1 (total documents/current results) should use old sort code path\n        // So we will only use array intersection if you have more than 10% of total docs in your current resultset.\n        if (eff <= targetEff || options.forceIndexIntersect) {\n          let idx;\n          const fr = this.filteredrows;\n          const io = {};\n          // set up hashobject for simple 'inclusion test' with existing (filtered) results\n          for (idx = 0; idx < frl; idx++) {\n            io[fr[idx]] = true;\n          }\n          // grab full sorted binary index array\n          const pv = this.collection.binaryIndices[propname].values;\n\n          // filter by existing results\n          this.filteredrows = pv.filter((n) => io[n]);\n\n          if (options.desc) {\n            this.filteredrows.reverse();\n          }\n\n          return this;\n        }\n      }\n    }\n\n    // at this point, we will not be able to leverage binary index so we will have to do an array sort\n\n    // if we have opted to use simplified javascript comparison function...\n    if (options.useJavascriptSorting) {\n      return this.sort((obj1, obj2) => {\n        if (obj1[propname] === obj2[propname]) return 0;\n        if (obj1[propname] > obj2[propname]) return 1;\n        if (obj1[propname] < obj2[propname]) return -1;\n      });\n    }\n\n    // otherwise use loki sort which will return same results if column is indexed or not\n    const wrappedComparer = ((prop, desc, data) => {\n      let val1;\n      let val2;\n      let arr;\n      return (a, b) => {\n        if (~prop.indexOf(\".\")) {\n          arr = prop.split(\".\");\n          val1 = Utils.getIn(data[a], arr, true);\n          val2 = Utils.getIn(data[b], arr, true);\n        } else {\n          val1 = data[a][prop];\n          val2 = data[b][prop];\n        }\n        return sortHelper(val1, val2, desc);\n      };\n    })(propname, options.desc, this.collection.data);\n\n    this.filteredrows.sort(wrappedComparer);\n\n    return this;\n  }\n\n  /**\n   * Allows sorting a resultset based on multiple columns.\n   * @example\n   * // to sort by age and then name (both ascending)\n   * rs.compoundsort(['age', 'name']);\n   * // to sort by age (ascending) and then by name (descending)\n   * rs.compoundsort(['age', ['name', true]]);\n   *\n   * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n   * @returns {ResultSet} Reference to this resultset, sorted, for future chain operations.\n   * @memberof Resultset\n   */\n  compoundsort(properties: (string | [string, boolean])[]): ResultSet<RST> {\n    if (properties.length === 0) {\n      throw new Error(\n        \"Invalid call to compoundsort, need at least one property\",\n      );\n    }\n\n    let prop;\n    if (properties.length === 1) {\n      prop = properties[0];\n      if (Array.isArray(prop)) {\n        return this.simplesort(prop[0], prop[1]);\n      }\n      return this.simplesort(prop, false);\n    }\n\n    // unify the structure of 'properties' to avoid checking it repeatedly while sorting\n    for (let i = 0, len = properties.length; i < len; i += 1) {\n      prop = properties[i];\n      if (!Array.isArray(prop)) {\n        properties[i] = [prop, false];\n      }\n    }\n\n    // if this has no filters applied, just we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    const wrappedComparer = (\n      (props, data) => (a, b) =>\n        compoundeval(props, data[a], data[b])\n    )(properties, this.collection.data);\n\n    this.filteredrows.sort(wrappedComparer);\n\n    return this;\n  }\n\n  /**\n   * findOr() - oversee the operation of OR'ed query expressions.\n   *    OR'ed expression evaluation runs each expression individually against the full collection,\n   *    and finally does a set OR on each expression's results.\n   *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n   *\n   * @param {array} expressionArray - array of expressions\n   * @returns {ResultSet} this resultset for further chain ops.\n   */\n  findOr(expressionArray: any[]): ResultSet<RST> {\n    let fr = null;\n    let fri = 0;\n    let frlen = 0;\n    const docset = [];\n    const idxset = [];\n    let idx = 0;\n\n    // If filter is already initialized, then we query against only those items already in filter.\n    // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n    for (let ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n      // we need to branch existing query to run each filter separately and combine results\n      fr = this.branch().find(expressionArray[ei]).filteredrows;\n      frlen = fr.length;\n\n      // add any document 'hits'\n      for (fri = 0; fri < frlen; fri++) {\n        idx = fr[fri];\n        if (idxset[idx] === undefined) {\n          idxset[idx] = true;\n          docset.push(idx);\n        }\n      }\n    }\n\n    this.filteredrows = docset;\n    this.filterInitialized = true;\n\n    return this;\n  }\n\n  /**\n   * findAnd() - oversee the operation of AND'ed query expressions.\n   *    AND'ed expression evaluation runs each expression progressively against the full collection,\n   *    internally utilizing existing chained resultset functionality.\n   *    Only the first filter can utilize a binary index.\n   *\n   * @param {array} expressionArray - array of expressions\n   * @returns {ResultSet} this resultset for further chain ops.\n   */\n  findAnd(expressionArray: any[]): ResultSet<RST> {\n    // we have already implementing method chaining in this (our Resultset class)\n    // so lets just progressively apply user supplied and filters\n    for (let i = 0, len = expressionArray.length; i < len; i++) {\n      if (this.count() === 0) {\n        return this;\n      }\n      this.find(expressionArray[i]);\n    }\n    return this;\n  }\n\n  /**\n   * Used for querying via a mongo-style query object.\n   *\n   * @param {object} query - A mongo-style query object used for filtering current results.\n   * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n   * @returns {ResultSet} this resultset for further chain ops.\n   * @memberof Resultset\n   * @example\n   * var over30 = users.chain().find({ age: { $gte: 30 } }).data();\n   */\n  find(query?: Record<string, any>, firstOnly?: boolean): ResultSet<RST> {\n    if (this.collection.data.length === 0) {\n      this.filteredrows = [];\n      this.filterInitialized = true;\n      return this;\n    }\n\n    const queryObject = query || \"getAll\";\n    let p;\n    let property: string;\n    let queryObjectOp;\n    let obj;\n    let operator: MongoLikeOps;\n    let value;\n    let key: string;\n    let searchByIndex = false;\n    const result = [];\n    const filters = [];\n    let index = null;\n\n    // flag if this was invoked via findOne()\n    firstOnly = firstOnly || false;\n\n    if (typeof queryObject === \"object\") {\n      for (p in queryObject) {\n        obj = {};\n        obj[p] = queryObject[p];\n        filters.push(obj);\n\n        if (hasOwnProperty.call(queryObject, p)) {\n          property = p;\n          queryObjectOp = queryObject[p];\n        }\n      }\n      // if more than one expression in single query object,\n      // convert implicit $and to explicit $and\n      if (filters.length > 1) {\n        return this.find({ $and: filters }, firstOnly);\n      }\n    }\n\n    // apply no filters if they want all\n    if (!property || queryObject === \"getAll\") {\n      if (firstOnly) {\n        if (this.filterInitialized) {\n          this.filteredrows = this.filteredrows.slice(0, 1);\n        } else {\n          this.filteredrows = this.collection.data.length > 0 ? [0] : [];\n          this.filterInitialized = true;\n        }\n      }\n\n      return this;\n    }\n\n    // injecting $and and $or expression tree evaluation here.\n    if (property === \"$and\" || property === \"$or\") {\n      this[property](queryObjectOp);\n\n      // for chained find with firstonly,\n      if (firstOnly && this.filteredrows.length > 1) {\n        this.filteredrows = this.filteredrows.slice(0, 1);\n      }\n\n      return this;\n    }\n\n    // see if query object is in shorthand mode (assuming eq operator)\n    if (\n      queryObjectOp === null ||\n      typeof queryObjectOp !== \"object\" ||\n      queryObjectOp instanceof Date\n    ) {\n      operator = \"$eq\";\n      value = queryObjectOp;\n    } else if (typeof queryObjectOp === \"object\") {\n      for (key in queryObjectOp) {\n        if (key in queryObjectOp) {\n          operator = key as MongoLikeOps;\n          value = queryObjectOp[key];\n          break;\n        }\n      }\n    } else {\n      throw new Error(\"Do not know what you want to do.\");\n    }\n\n    if (operator === \"$regex\" || typeof value === \"object\") {\n      value = precompileQuery(operator, value);\n    }\n\n    // if user is deep querying the object such as find('name.first': 'odin')\n    const usingDotNotation = property.includes(\".\");\n\n    // if an index exists for the property being queried against, use it\n    // for now only enabling where it is the first filter applied and prop is indexed\n    const doIndexCheck = !this.filterInitialized;\n\n    if (\n      doIndexCheck &&\n      this.collection.binaryIndices[property] &&\n      indexedOps[operator]\n    ) {\n      // this is where our lazy index rebuilding will take place\n      // basically we will leave all indexes dirty until we need them\n      // so here we will rebuild only the index tied to this property\n      // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n      if (this.collection.adaptiveBinaryIndices !== true) {\n        this.collection.ensureIndex(property);\n      }\n\n      searchByIndex = true;\n      index = this.collection.binaryIndices[property];\n    }\n\n    // opportunistically speed up $in searches from O(n*m) to O(n*log m)\n    if (\n      !searchByIndex &&\n      operator === \"$in\" &&\n      Array.isArray(value) &&\n      typeof Set !== \"undefined\"\n    ) {\n      value = new Set(value);\n      operator = \"$inSet\";\n    }\n\n    // the comparison function\n    const fun = LokiOps[operator];\n\n    // https://github.com/techfort/LokiJS/pull/892\n    if (typeof fun !== \"function\") {\n      throw new TypeError('\"' + operator + '\" is not a valid operator');\n    }\n\n    // \"shortcut\" for collection data\n    const t = this.collection.data;\n\n    // filter data length\n    let i = 0;\n\n    let len = 0;\n\n    // Query executed differently depending on :\n    //    - whether the property being queried has an index defined\n    //    - if chained, we handle first pass differently for initial filteredrows[] population\n    //\n    // For performance reasons, each case has its own if block to minimize in-loop calculations\n\n    let filter;\n\n    let rowIdx = 0;\n    let record;\n\n    // If the filteredrows[] is already initialized, use it\n    if (this.filterInitialized) {\n      filter = this.filteredrows;\n      len = filter.length;\n\n      // currently supporting dot notation for non-indexed conditions only\n      if (usingDotNotation) {\n        const propertyArr = property.split(\".\");\n        for (i = 0; i < len; i++) {\n          rowIdx = filter[i];\n          record = t[rowIdx];\n          if (dotSubScan(record, propertyArr, fun, value, record)) {\n            result.push(rowIdx);\n            if (firstOnly) {\n              this.filteredrows = result;\n              return this;\n            }\n          }\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          rowIdx = filter[i];\n          record = t[rowIdx];\n          if (fun(record[property], value, record)) {\n            result.push(rowIdx);\n            if (firstOnly) {\n              this.filteredrows = result;\n              return this;\n            }\n          }\n        }\n      }\n    }\n    // first chained query so work against data[] but put results in filteredrows\n    else {\n      // if not searching by index\n      if (!searchByIndex) {\n        len = t.length;\n\n        if (usingDotNotation) {\n          const propertyArr = property.split(\".\");\n          for (i = 0; i < len; i++) {\n            record = t[i];\n            if (dotSubScan(record, propertyArr, fun, value, record)) {\n              result.push(i);\n              if (firstOnly) {\n                this.filteredrows = result;\n                this.filterInitialized = true;\n                return this;\n              }\n            }\n          }\n        } else {\n          for (i = 0; i < len; i++) {\n            record = t[i];\n            if (fun(record[property], value, record)) {\n              result.push(i);\n              if (firstOnly) {\n                this.filteredrows = result;\n                this.filterInitialized = true;\n                return this;\n              }\n            }\n          }\n        }\n      } else {\n        // search by index\n        const segm = this.collection.calculateRange(operator, property, value);\n\n        if (operator !== \"$in\") {\n          for (i = segm[0]; i <= segm[1]; i++) {\n            if (indexedOps[operator] !== true) {\n              // must be a function, implying 2nd phase filtering of results from calculateRange\n              if (\n                indexedOps[operator](\n                  Utils.getIn(t[index.values[i]], property, usingDotNotation),\n                  value,\n                )\n              ) {\n                result.push(index.values[i]);\n                if (firstOnly) {\n                  this.filteredrows = result;\n                  this.filterInitialized = true;\n                  return this;\n                }\n              }\n            } else {\n              result.push(index.values[i]);\n              if (firstOnly) {\n                this.filteredrows = result;\n                this.filterInitialized = true;\n                return this;\n              }\n            }\n          }\n        } else {\n          for (i = 0, len = segm.length; i < len; i++) {\n            result.push(index.values[segm[i]]);\n            if (firstOnly) {\n              this.filteredrows = result;\n              this.filterInitialized = true;\n              return this;\n            }\n          }\n        }\n      }\n    }\n\n    this.filteredrows = result;\n    this.filterInitialized = true; // next time work against filteredrows[]\n    return this;\n  }\n\n  /**\n   * where() - Used for filtering via a javascript filter function.\n   *\n   * @param {function} fun - A javascript function used for filtering current results by.\n   * @returns {ResultSet} this resultset for further chain ops.\n   * @memberof Resultset\n   * @example\n   * var over30 = users.chain().where(function(obj) { return obj.age >= 30; }.data();\n   */\n  where(fun: (_: RST) => boolean) {\n    let viewFunction: (_: RST) => boolean;\n    const result: number[] = [];\n\n    if (\"function\" === typeof fun) {\n      viewFunction = fun;\n    } else {\n      throw new TypeError(\"Argument is not a stored view or a function\");\n    }\n    // If the filteredrows[] is already initialized, use it\n    if (this.filterInitialized) {\n      let j = this.filteredrows.length;\n\n      while (j--) {\n        if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n          result.push(this.filteredrows[j]);\n        }\n      }\n\n      this.filteredrows = result;\n\n      return this;\n    }\n    // otherwise this is initial chained op, work against data, push into filteredrows[]\n    else {\n      let k = this.collection.data.length;\n\n      while (k--) {\n        if (viewFunction(this.collection.data[k]) === true) {\n          result.push(k);\n        }\n      }\n\n      this.filteredrows = result;\n      this.filterInitialized = true;\n\n      return this;\n    }\n  }\n\n  /**\n   * count() - returns the number of documents in the resultset.\n   *\n   * @returns {number} The number of documents in the resultset.\n   * @example\n   * var over30Count = users.chain().find({ age: { $gte: 30 } }).count();\n   */\n  count(): number {\n    if (this.filterInitialized) {\n      return this.filteredrows.length;\n    }\n    return this.collection.count();\n  }\n\n  // Resultset.prototype\n  /**\n   * Used to run an update operation on all documents currently in the resultset.\n   *\n   * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n   * @returns {ResultSet} this resultset for further chain ops.\n   * @memberof Resultset\n   * @example\n   * users.chain().find({ country: 'de' }).update(function(user) {\n   *   user.phoneFormat = \"+49 AAAA BBBBBB\";\n   * });\n   */\n  update(updateFunction: (_: RST) => void) {\n    if (typeof updateFunction !== \"function\") {\n      throw new TypeError(\"Argument is not a function\");\n    }\n\n    // if this has no filters applied, we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    let obj;\n    const len = this.filteredrows.length;\n    const rcd = this.collection.data;\n\n    // pass in each document object currently in resultset to user supplied updateFunction\n    for (let idx = 0; idx < len; idx++) {\n      // if we have cloning option specified or are doing differential delta changes, clone object first\n      if (\n        // https://github.com/techfort/LokiJS/pull/918/files\n        !this.collection.disableFreeze ||\n        this.collection.cloneObjects ||\n        !this.collection.disableDeltaChangesApi\n      ) {\n        obj = clone(rcd[this.filteredrows[idx]], this.collection.cloneMethod);\n        updateFunction(obj);\n        this.collection.update(obj);\n      } else {\n        // no need to clone, so just perform update on collection data object instance\n        updateFunction(rcd[this.filteredrows[idx]]);\n        this.collection.update(rcd[this.filteredrows[idx]]);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes all document objects which are currently in resultset from collection (as well as resultset)\n   *\n   * @returns {ResultSet} this (empty) resultset for further chain ops.\n   * @memberof Resultset\n   * @example\n   * // remove users inactive since 1/1/2001\n   * users.chain().find({ lastActive: { $lte: new Date(\"1/1/2001\").getTime() } }).remove();\n   */\n  remove(): ResultSet<RST> {\n    // if this has no filters applied, we need to populate filteredrows first\n    if (!this.filterInitialized && this.filteredrows.length === 0) {\n      this.filteredrows = this.collection.prepareFullDocIndex();\n    }\n\n    this.collection.removeBatchByPositions(this.filteredrows);\n\n    this.filteredrows = [];\n\n    return this;\n  }\n\n  /**\n   * data transformation via user supplied functions\n   *\n   * @param {function} mapFunction - this function accepts a single document for you to transform and return\n   * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n   * @returns {value} The output of your reduceFunction\n   * @example\n   * var db = new loki(\"order.db\");\n   * var orders = db.addCollection(\"orders\");\n   * orders.insert([{ qty: 4, unitCost: 100.00 }, { qty: 10, unitCost: 999.99 }, { qty: 2, unitCost: 49.99 }]);\n   *\n   * function mapfun (obj) { return obj.qty*obj.unitCost };\n   * function reducefun(array) {\n   *   var grandTotal=0;\n   *   array.forEach(function(orderTotal) { grandTotal += orderTotal; });\n   *   return grandTotal;\n   * }\n   * var grandOrderTotal = orders.chain().mapReduce(mapfun, reducefun);\n   * console.log(grandOrderTotal);\n   */\n  mapReduce<U>(\n    mapFunction: (value: RST, index: number, array: RST[]) => U,\n    reduceFunction: (_: U[]) => U,\n  ) {\n    return reduceFunction(this.data().map(mapFunction));\n  }\n\n  /**\n   * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n   * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n   * @param {Array|ResultSet|Collection} joinData - Data array to join to.\n   * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n   * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n   * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n   * @param {object=} dataOptions - options to data() before input to your map function\n   * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun\n   * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n   * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n   * @returns {ResultSet} A resultset with data in the format [{left: leftObj, right: rightObj}]\n   * @memberof Resultset\n   * @example\n   * var db = new loki('sandbox.db');\n   *\n   * var products = db.addCollection('products');\n   * var orders = db.addCollection('orders');\n   *\n   * products.insert({ productId: \"100234\", name: \"flywheel energy storage\", unitCost: 19999.99 });\n   * products.insert({ productId: \"140491\", name: \"300F super capacitor\", unitCost: 129.99 });\n   * products.insert({ productId: \"271941\", name: \"fuel cell\", unitCost: 3999.99 });\n   * products.insert({ productId: \"174592\", name: \"390V 3AH lithium bank\", unitCost: 4999.99 });\n   *\n   * orders.insert({ orderDate : new Date(\"12/1/2017\").getTime(), prodId: \"174592\", qty: 2, customerId: 2 });\n   * orders.insert({ orderDate : new Date(\"4/15/2016\").getTime(), prodId: \"271941\", qty: 1, customerId: 1 });\n   * orders.insert({ orderDate : new Date(\"3/12/2017\").getTime(), prodId: \"140491\", qty: 4, customerId: 4 });\n   * orders.insert({ orderDate : new Date(\"7/31/2017\").getTime(), prodId: \"100234\", qty: 7, customerId: 3 });\n   * orders.insert({ orderDate : new Date(\"8/3/2016\").getTime(), prodId: \"174592\", qty: 3, customerId: 5 });\n   *\n   * var mapfun = function(left, right) {\n   *   return {\n   *     orderId: left.$loki,\n   *     orderDate: new Date(left.orderDate) + '',\n   *     customerId: left.customerId,\n   *     qty: left.qty,\n   *     productId: left.prodId,\n   *     prodName: right.name,\n   *     prodCost: right.unitCost,\n   *     orderTotal: +((right.unitCost * left.qty).toFixed(2))\n   *   };\n   * };\n   *\n   * // join orders with relevant product info via eqJoin\n   * var orderSummary = orders.chain().eqJoin(products, \"prodId\", \"productId\", mapfun).data();\n   *\n   * console.log(orderSummary);\n   */\n  eqJoin(\n    joinData: RST[] | ResultSet<RST> | Collection<RST>,\n    leftJoinKey: string | ((...args: any[]) => string),\n    rightJoinKey: string | ((...args: any[]) => string),\n    mapFun: ((...args: any[]) => any) | undefined,\n    dataOptions: {\n      removeMeta: boolean;\n      forceClones: boolean;\n      forceCloneMethod: CloneMethods;\n    },\n  ): ResultSet<RST> {\n    let leftData = [];\n    let rightData = [];\n    let key;\n    const result = [];\n    const leftKeyisFunction = typeof leftJoinKey === \"function\";\n    const rightKeyisFunction = typeof rightJoinKey === \"function\";\n    const joinMap = {};\n\n    //get the left data\n    leftData = this.data(dataOptions);\n    const leftDataLength = leftData.length;\n\n    //get the right data\n    if (joinData instanceof Collection) {\n      rightData = joinData.chain().data(dataOptions);\n    } else if (joinData instanceof ResultSet) {\n      const x = new ResultSet(new Collection<RST>(\"\"));\n      x.rightData = joinData.data(dataOptions);\n    } else if (Array.isArray(joinData)) {\n      rightData = joinData;\n    } else {\n      throw new TypeError(\"joinData needs to be an array or result set\");\n    }\n    const rightDataLength = rightData.length;\n\n    //construct a lookup table\n\n    for (let i = 0; i < rightDataLength; i++) {\n      key = rightKeyisFunction\n        ? rightJoinKey(rightData[i])\n        : rightData[i][rightJoinKey];\n      joinMap[key] = rightData[i];\n    }\n\n    if (!mapFun) {\n      mapFun = (left, right) => ({\n        left,\n        right,\n      });\n    }\n    //Run map function over each object in the resultset\n    for (let j = 0; j < leftDataLength; j++) {\n      key = leftKeyisFunction\n        ? leftJoinKey(leftData[j])\n        : leftData[j][leftJoinKey];\n      result.push(mapFun(leftData[j], joinMap[key] || {}));\n    }\n\n    //return return a new resultset with no filters\n    this.collection = new Collection(\"joinData\");\n    this.collection.insert(result);\n    this.filteredrows = [];\n    this.filterInitialized = false;\n\n    return this;\n  }\n\n  /**\n   * Terminates the chain and returns array of filtered documents\n   *\n   * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n   * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n   *        the collection is not configured for clone object.\n   * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n   *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'\n   * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents\n   *\n   * @returns {array} Array of documents in the resultset\n   * @memberof Resultset\n   * @example\n   * var resutls = users.chain().find({ age: 34 }).data();\n   */\n  data(options?: Partial<ResultSetDataOptions>): RST[] {\n    var result = [],\n      data = this.collection.data,\n      obj,\n      len,\n      i,\n      method;\n\n    options = options || {};\n\n    // if user opts to strip meta, then force clones and use 'shallow' if 'force' options are not present\n    if (options.removeMeta && !options.forceClones) {\n      options.forceClones = true;\n      options.forceCloneMethod = options.forceCloneMethod || \"shallow\";\n    }\n\n    // if collection has delta changes active, then force clones and use 'parse-stringify' for effective change tracking of nested objects\n    // if collection is immutable freeze and unFreeze takes care of cloning\n    if (\n      !this.collection.disableDeltaChangesApi &&\n      this.collection.disableFreeze\n    ) {\n      options.forceClones = true;\n      options.forceCloneMethod = \"parse-stringify\";\n    }\n\n    // if this has no filters applied, just return collection.data\n    if (!this.filterInitialized) {\n      if (this.filteredrows.length === 0) {\n        // determine whether we need to clone objects or not\n        if (this.collection.cloneObjects || options.forceClones) {\n          len = data.length;\n          method = options.forceCloneMethod || this.collection.cloneMethod;\n          for (i = 0; i < len; i++) {\n            obj = clone(data[i], method);\n            if (options.removeMeta) {\n              delete obj.$loki;\n              delete obj.meta;\n            }\n            result.push(obj);\n          }\n          return result;\n        }\n        // otherwise we are not cloning so return sliced array with same object references\n        else {\n          return data.slice();\n        }\n      } else {\n        // filteredrows must have been set manually, so use it\n        this.filterInitialized = true;\n      }\n    }\n\n    var fr = this.filteredrows;\n    len = fr.length;\n\n    if (this.collection.cloneObjects || options.forceClones) {\n      method = options.forceCloneMethod || this.collection.cloneMethod;\n      for (i = 0; i < len; i++) {\n        obj = clone(data[fr[i]], method);\n        if (options.removeMeta) {\n          delete obj.$loki;\n          delete obj.meta;\n        }\n        result.push(obj);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        result.push(data[fr[i]]);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Applies a map function into a new collection for further chaining.\n   * @param {function} mapFun - javascript map function\n   * @param {object=} dataOptions - options to data() before input to your map function\n   * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun\n   * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n   * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n   * @memberof Resultset\n   * @example\n   * var orders.chain().find({ productId: 32 }).map(function(obj) {\n   *   return {\n   *     orderId: $loki,\n   *     productId: productId,\n   *     quantity: qty\n   *   };\n   * });\n   */\n  map<U>(\n    mapFun: (value: RST, index: number, array: RST[]) => U,\n    dataOptions?: Partial<ResultSetDataOptions>,\n  ) {\n    const data = this.data(dataOptions).map(mapFun);\n    //return return a new resultset with no filters\n    this.collection = new Collection(\"mappedData\");\n    this.collection.insert(data);\n    this.filteredrows = [];\n    this.filterInitialized = false;\n\n    return this;\n  }\n\n  /**\n   * Alias of copy()\n   * @memberof Resultset\n   */\n  branch = ResultSet.prototype.copy;\n  $or = ResultSet.prototype.findOr;\n  $and = ResultSet.prototype.findAnd;\n}\n\ninterface ResultSetDataOptions {\n  removeMeta: boolean;\n  forceClones: boolean;\n  forceCloneMethod: CloneMethods;\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\n/**\n * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n * constructor that inherits EventEmitter to emit events and trigger\n * listeners that have been added to the event through the on(event, callback) method\n *\n * @constructor LokiEventEmitter\n */\n// function LokiEventEmitter() {}\nexport class SylvieEventEmitter {\n  save: any;\n\n  /**\n   * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n   * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n   * @param {function} listener - callback function of listener to attach\n   * @returns {int} the index of the callback in the array of listeners for a particular event\n   * @memberof LokiEventEmitter\n   */\n  on<F extends (...args: any[]) => any>(\n    eventName: string | string[],\n    listener: F,\n  ): F {\n    let event;\n    var self = this;\n\n    if (Array.isArray(eventName)) {\n      eventName.forEach((currentEventName) => {\n        this.on(currentEventName, listener);\n      });\n      return listener;\n    }\n\n    event = this.events[eventName];\n    if (!event) {\n      event = this.events[eventName] = [];\n    }\n    event.push(listener);\n    return listener;\n  }\n\n  /**\n   * Alias of LokiEventEmitter.prototype.on\n   * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n   * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n   * @param {function} listener - callback function of listener to attach\n   * @returns {int} the index of the callback in the array of listeners for a particular event\n   * @memberof LokiEventEmitter\n   */\n  addListener: SylvieEventEmitter[\"on\"] = this.on;\n\n  /**\n   * emit(eventName, data) - emits a particular event\n   * with the option of passing optional parameters which are going to be processed by the callback\n   * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n   * @param {string} eventName - the name of the event\n   * @param {object=} data - optional object passed with the event\n   * @memberof LokiEventEmitter\n   */\n  emit(eventName: string, data?: unknown, arg?: any): void {\n    let selfArgs;\n    var self = this;\n\n    if (eventName && this.events[eventName]) {\n      if (this.events[eventName].length) {\n        // eslint-disable-next-line prefer-rest-params\n        selfArgs = Array.prototype.slice.call(arguments, 1);\n        this.events[eventName].forEach((listener) => {\n          if (this.asyncListeners) {\n            setTimeout(() => {\n              listener.apply(self, selfArgs);\n            }, 1);\n          } else {\n            listener.apply(self, selfArgs);\n          }\n        });\n      }\n    } else {\n      throw new Error(`No event ${eventName} defined`);\n    }\n  }\n\n  /**\n   * removeListener() - removes the listener at position 'index' from the event 'eventName'\n   * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n   * @param {function} listener - the listener callback function to remove from emitter\n   * @memberof LokiEventEmitter\n   */\n  removeListener(\n    eventName: string | string[],\n    listener: (...args: any[]) => any,\n  ): void {\n    if (Array.isArray(eventName)) {\n      eventName.forEach((currentEventName) => {\n        this.removeListener(currentEventName, listener);\n      });\n\n      return;\n    }\n\n    if (this.events[eventName]) {\n      const listeners = this.events[eventName];\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n  }\n\n  /**\n   * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n   * @memberof LokiEventEmitter\n   */\n  public events: { [eventName: string]: ((...args: any[]) => any)[] } = {};\n\n  /**\n   * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n   * should happen in an async fashion or not\n   * Default is false, which means events are synchronous\n   * @memberof LokiEventEmitter\n   */\n  asyncListeners = false;\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n\"use strict\";\nimport { deepFreeze, freeze } from \"../utils/icebox\";\nimport { Collection, CollectionDocument } from \"./collection\";\nimport { ResultSet } from \"./result-set\";\nimport { SylvieEventEmitter } from \"./sylvie-event-emitter\";\n\n/**\n * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n *\n * @example\n * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n * mydv.applyFind({ 'doors' : 4 });\n * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n * var results = mydv.data();\n *\n * @constructor DynamicView\n * @implements SylvieEventEmitter\n * @param {Collection} collection - A reference to the collection to work against\n * @param {string} name - The name of this dynamic view\n * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'\n * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)\n * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n */\n\nexport interface DynamicViewOptions {\n  persistent: boolean;\n  sortPriority: \"passive\" | \"active\";\n  minRebuildInterval: number;\n}\n\nexport class DynamicView<\n  DT extends Partial<CollectionDocument>,\n> extends SylvieEventEmitter {\n  collection: Collection<DT>;\n  name: string;\n  rebuildPending: boolean;\n  options: Partial<DynamicViewOptions>;\n  resultset: ResultSet<DT>;\n  resultdata: unknown[];\n  resultsdirty: boolean;\n  cachedresultset: ResultSet<DT>;\n  filterPipeline: {\n    type: string;\n    val: unknown;\n    uid: string | number | undefined;\n  }[];\n  sortFunction: (a: any, b: any) => number;\n  sortCriteria: string[];\n  sortCriteriaSimple: {\n    propname: string;\n    options:\n      | Partial<{\n          desc: boolean;\n          disableIndexIntersect: boolean;\n          forceIndexIntersect: boolean;\n          useJavascriptSorting: boolean;\n        }>\n      | boolean;\n  };\n  sortDirty: boolean;\n  events: { rebuild: any[]; filter: any[]; sort: any[] };\n\n  constructor(\n    collection: Collection<DT>,\n    name: string,\n    options?: Partial<DynamicViewOptions>,\n  ) {\n    super();\n    this.collection = collection;\n    this.name = name;\n    this.rebuildPending = false;\n    this.options = options || {};\n\n    if (!Object.hasOwn(this.options, \"persistent\")) {\n      this.options.persistent = false;\n    }\n\n    // 'persistentSortPriority':\n    // 'passive' will defer the sort phase until they call data(). (most efficient overall)\n    // 'active' will sort async whenever next idle. (prioritizes read speeds)\n    if (!Object.hasOwn(this.options, \"sortPriority\")) {\n      this.options.sortPriority = \"passive\";\n    }\n\n    if (!Object.hasOwn(this.options, \"minRebuildInterval\")) {\n      this.options.minRebuildInterval = 1;\n    }\n\n    this.resultset = new ResultSet(collection);\n    this.resultdata = [];\n    this.resultsdirty = false;\n\n    this.cachedresultset = null;\n\n    // keep ordered filter pipeline\n    this.filterPipeline = [];\n    if (!this.collection.disableFreeze) {\n      Object.freeze(this.filterPipeline);\n    }\n\n    // sorting member variables\n    // we only support one active search, applied using applySort() or applySimpleSort()\n    this.sortFunction = null;\n    this.sortCriteria = null;\n    this.sortCriteriaSimple = null;\n    this.sortDirty = false;\n\n    // for now just have 1 event for when we finally rebuilt lazy view\n    // once we refactor transactions, i will tie in certain transactional events\n    this.events = {\n      rebuild: [],\n      filter: [],\n      sort: [],\n    };\n  }\n\n  /**\n   * getSort() - used to get the current sort\n   *\n   * @returns function (sortFunction) or array (sortCriteria) or object (sortCriteriaSimple)\n   */\n  getSort() {\n    return this.sortFunction || this.sortCriteria || this.sortCriteriaSimple;\n  }\n\n  /**\n   * rematerialize() - internally used immediately after deserialization (loading)\n   *    This will clear out and reapply filterPipeline ops, recreating the view.\n   *    Since where filters do not persist correctly, this method allows\n   *    restoring the view to state where user can re-apply those where filters.\n   *\n   * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n   * @returns {DynamicView} This dynamic view for further chained ops.\n   * @memberof DynamicView\n   * @fires DynamicView.rebuild\n   */\n  rematerialize(options) {\n    let fpl;\n    let fpi;\n    let idx: number;\n\n    options = options || {};\n\n    this.resultdata = [];\n    this.resultsdirty = true;\n    this.resultset = new ResultSet(this.collection);\n\n    if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n      this.sortDirty = true;\n    }\n\n    const wasFrozen = Object.isFrozen(this.filterPipeline);\n    if (Object.hasOwn(options, \"removeWhereFilters\")) {\n      // for each view see if it had any where filters applied... since they don't\n      // serialize those functions lets remove those invalid filters\n      if (wasFrozen) {\n        this.filterPipeline = this.filterPipeline.slice();\n      }\n      fpl = this.filterPipeline.length;\n      fpi = fpl;\n      while (fpi--) {\n        if (this.filterPipeline[fpi].type === \"where\") {\n          if (fpi !== this.filterPipeline.length - 1) {\n            this.filterPipeline[fpi] =\n              this.filterPipeline[this.filterPipeline.length - 1];\n          }\n          this.filterPipeline.length--;\n        }\n      }\n    }\n\n    // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n    const ofp = this.filterPipeline;\n    this.filterPipeline = [];\n\n    // now re-apply 'find' filterPipeline ops\n    fpl = ofp.length;\n    for (idx = 0; idx < fpl; idx++) {\n      this.applyFind(ofp[idx].val, ofp[idx].uid);\n    }\n    if (wasFrozen) {\n      Object.freeze(this.filterPipeline);\n    }\n\n    // during creation of unit tests, i will remove this forced refresh and leave lazy\n    this.data();\n\n    // emit rebuild event in case user wants to be notified\n    this.emit(\"rebuild\", this);\n\n    return this;\n  }\n\n  /**\n   * branchResultset() - Makes a copy of the internal resultset for branched queries.\n   *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n   *    so your branched query should be immediately resolved and not held for future evaluation.\n   *\n   * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n   * @param {object=} parameters - optional parameters (if optional transform requires them)\n   * @returns {ResultSet} A copy of the internal resultset for branched queries.\n   * @memberof DynamicView\n   * @example\n   * var db = new loki('test');\n   * var coll = db.addCollection('mydocs');\n   * var dv = coll.addDynamicView('myview');\n   * var tx = [\n   *   {\n   *     type: 'offset',\n   *     value: '[%lktxp]pageStart'\n   *   },\n   *   {\n   *     type: 'limit',\n   *     value: '[%lktxp]pageSize'\n   *   }\n   * ];\n   * coll.addTransform('viewPaging', tx);\n   *\n   * // add some records\n   *\n   * var results = dv.branchResultset('viewPaging', { pageStart: 10, pageSize: 10 }).data();\n   */\n  branchResultset(transform?: string | [], parameters?: Record<string, any>) {\n    const rs = this.resultset.branch();\n\n    if (typeof transform === \"undefined\") {\n      return rs;\n    }\n\n    return rs.transform(transform, parameters);\n  }\n\n  /**\n   * toJSON() - Override of toJSON to avoid circular references\n   *\n   */\n  toJSON() {\n    const copy = new DynamicView(this.collection, this.name, this.options);\n    copy.resultset = this.resultset;\n    copy.resultdata = []; // let's not save data (copy) to minimize size\n    copy.resultsdirty = true;\n    copy.filterPipeline = this.filterPipeline;\n    copy.sortFunction = this.sortFunction;\n    copy.sortCriteria = this.sortCriteria;\n    copy.sortCriteriaSimple = this.sortCriteriaSimple || null;\n    copy.sortDirty = this.sortDirty;\n\n    // avoid circular reference, reapply in db.loadJSON()\n    copy.collection = null;\n\n    return copy;\n  }\n\n  /**\n   * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n   *     Existing options should be retained.\n   * @param {object=} options - configure removeFilter behavior\n   * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n   * @memberof DynamicView\n   */\n  removeFilters(options: Record<string, any> = {}) {\n    this.rebuildPending = false;\n    this.resultset.reset();\n    this.resultdata = [];\n    this.resultsdirty = true;\n\n    this.cachedresultset = null;\n\n    const wasFrozen = Object.isFrozen(this.filterPipeline);\n    const filterChanged = this.filterPipeline.length > 0;\n    // keep ordered filter pipeline\n    this.filterPipeline = [];\n    if (wasFrozen) {\n      Object.freeze(this.filterPipeline);\n    }\n\n    // sorting member variables\n    // we only support one active search, applied using applySort() or applySimpleSort()\n    this.sortFunction = null;\n    this.sortCriteria = null;\n    this.sortCriteriaSimple = null;\n    this.sortDirty = false;\n\n    if (options.queueSortPhase === true) {\n      this.queueSortPhase();\n    }\n\n    if (filterChanged) {\n      this.emit(\"filter\");\n    }\n  }\n\n  /**\n   * applySort() - Used to apply a sort to the dynamic view\n   * @example\n   * dv.applySort(function(obj1, obj2) {\n   *   if (obj1.name === obj2.name) return 0;\n   *   if (obj1.name > obj2.name) return 1;\n   *   if (obj1.name < obj2.name) return -1;\n   * });\n   *\n   * @param {function} comparefun - a javascript compare function used for sorting\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   * @memberof DynamicView\n   */\n  applySort(comparefun) {\n    this.sortFunction = comparefun;\n    this.sortCriteria = null;\n    this.sortCriteriaSimple = null;\n\n    this.queueSortPhase();\n    this.emit(\"sort\");\n\n    return this;\n  }\n\n  /**\n   * applySimpleSort() - Used to specify a property used for view translation.\n   * @example\n   * dv.applySimpleSort(\"name\");\n   *\n   * @param {string} propname - Name of property by which to sort.\n   * @param {object|boolean=} options - boolean for sort descending or options object\n   * @param {boolean} [options.desc=false] - whether we should sort descending.\n   * @param {boolean} [options.disableIndexIntersect=false] - whether we should explicity not use array intersection.\n   * @param {boolean} [options.forceIndexIntersect=false] - force array intersection (if binary index exists).\n   * @param {boolean} [options.useJavascriptSorting=false] - whether results are sorted via basic javascript sort.\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   * @memberof DynamicView\n   */\n  applySimpleSort(\n    propname,\n    options?: Partial<{\n      desc: boolean;\n      disableIndexIntersect: boolean;\n      forceIndexIntersect: boolean;\n      useJavascriptSorting: boolean;\n    }>,\n  ) {\n    this.sortCriteriaSimple = {\n      propname,\n      options: options || false,\n    };\n    if (!this.collection.disableFreeze) {\n      deepFreeze(this.sortCriteriaSimple);\n    }\n    this.sortCriteria = null;\n    this.sortFunction = null;\n\n    this.queueSortPhase();\n    this.emit(\"sort\");\n\n    return this;\n  }\n\n  /**\n   * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n   * @example\n   * // to sort by age and then name (both ascending)\n   * dv.applySortCriteria(['age', 'name']);\n   * // to sort by age (ascending) and then by name (descending)\n   * dv.applySortCriteria(['age', ['name', true]);\n   * // to sort by age (descending) and then by name (descending)\n   * dv.applySortCriteria(['age', true], ['name', true]);\n   *\n   * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n   * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n   * @memberof DynamicView\n   */\n  applySortCriteria(criteria) {\n    this.sortCriteria = criteria;\n    if (!this.collection.disableFreeze) {\n      deepFreeze(this.sortCriteria);\n    }\n    this.sortCriteriaSimple = null;\n    this.sortFunction = null;\n\n    this.queueSortPhase();\n    this.emit(\"sort\");\n    return this;\n  }\n\n  /**\n   * startTransaction() - marks the beginning of a transaction.\n   *\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  startTransaction() {\n    this.cachedresultset = this.resultset.copy();\n\n    return this;\n  }\n\n  /**\n   * commit() - commits a transaction.\n   *\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  commit() {\n    this.cachedresultset = null;\n\n    return this;\n  }\n\n  /**\n   * rollback() - rolls back a transaction.\n   *\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  rollback() {\n    this.resultset = this.cachedresultset;\n\n    if (this.options.persistent) {\n      // for now just rebuild the persistent dynamic view data in this worst case scenario\n      // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n      this.resultdata = this.resultset.data();\n\n      this.emit(\"rebuild\", this);\n    }\n\n    return this;\n  }\n\n  /**\n   * Implementation detail.\n   * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n   *\n   * @param {(string|number)} uid - The unique ID of the filter.\n   * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n   */\n  _indexOfFilterWithId(uid) {\n    if (typeof uid === \"string\" || typeof uid === \"number\") {\n      for (let idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n        if (uid === this.filterPipeline[idx].uid) {\n          return idx;\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Implementation detail.\n   * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n   *\n   * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n   */\n  _addFilter(filter) {\n    const wasFrozen = Object.isFrozen(this.filterPipeline);\n    if (wasFrozen) {\n      this.filterPipeline = this.filterPipeline.slice();\n    }\n    if (!this.collection.disableFreeze) {\n      deepFreeze(filter);\n    }\n    this.filterPipeline.push(filter);\n    if (wasFrozen) {\n      Object.freeze(this.filterPipeline);\n    }\n    this.resultset[filter.type](filter.val);\n  }\n\n  /**\n   * reapplyFilters() - Reapply all the filters in the current pipeline.\n   *\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   */\n  reapplyFilters() {\n    this.resultset.reset();\n\n    this.cachedresultset = null;\n    if (this.options.persistent) {\n      this.resultdata = [];\n      this.resultsdirty = true;\n    }\n\n    const filters = this.filterPipeline;\n    const wasFrozen = Object.isFrozen(filters);\n    this.filterPipeline = [];\n\n    for (let idx = 0, len = filters.length; idx < len; idx += 1) {\n      this._addFilter(filters[idx]);\n    }\n    if (wasFrozen) {\n      Object.freeze(this.filterPipeline);\n    }\n\n    if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n      this.queueSortPhase();\n    } else {\n      this.queueRebuildEvent();\n    }\n    this.emit(\"filter\");\n    return this;\n  }\n\n  /**\n   * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n   *\n   * @param {object} filter - A filter object to add to the pipeline.\n   *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   * @memberof DynamicView\n   */\n  applyFilter(filter) {\n    const idx = this._indexOfFilterWithId(filter.uid);\n    if (idx >= 0) {\n      const wasFrozen = Object.isFrozen(this.filterPipeline);\n      if (wasFrozen) {\n        this.filterPipeline = this.filterPipeline.slice();\n      }\n      this.filterPipeline[idx] = filter;\n      if (wasFrozen) {\n        freeze(filter);\n        Object.freeze(this.filterPipeline);\n      }\n      return this.reapplyFilters();\n    }\n\n    this.cachedresultset = null;\n    if (this.options.persistent) {\n      this.resultdata = [];\n      this.resultsdirty = true;\n    }\n\n    this._addFilter(filter);\n\n    if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n      this.queueSortPhase();\n    } else {\n      this.queueRebuildEvent();\n    }\n\n    this.emit(\"filter\");\n    return this;\n  }\n\n  /**\n   * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n   *\n   * @param {object} query - A mongo-style query object to apply to pipeline\n   * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   * @memberof DynamicView\n   */\n  applyFind(query, uid?: string | number) {\n    this.applyFilter({\n      type: \"find\",\n      val: query,\n      uid,\n    });\n    return this;\n  }\n\n  /**\n   * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n   *\n   * @param {function} fun - A javascript filter function to apply to pipeline\n   * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   * @memberof DynamicView\n   */\n  applyWhere(fun, uid?: string | number) {\n    this.applyFilter({\n      type: \"where\",\n      val: fun,\n      uid,\n    });\n    return this;\n  }\n\n  /**\n   * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n   *\n   * @param {(string|number)} uid - The unique ID of the filter to be removed.\n   * @returns {DynamicView} this DynamicView object, for further chain ops.\n   * @memberof DynamicView\n   */\n  removeFilter(uid) {\n    const idx = this._indexOfFilterWithId(uid);\n    if (idx < 0) {\n      throw new Error(`Dynamic view does not contain a filter with ID: ${uid}`);\n    }\n    const wasFrozen = Object.isFrozen(this.filterPipeline);\n    if (wasFrozen) {\n      this.filterPipeline = this.filterPipeline.slice();\n    }\n    this.filterPipeline.splice(idx, 1);\n    if (wasFrozen) {\n      Object.freeze(this.filterPipeline);\n    }\n    this.reapplyFilters();\n    return this;\n  }\n\n  /**\n   * count() - returns the number of documents representing the current DynamicView contents.\n   *\n   * @returns {number} The number of documents representing the current DynamicView contents.\n   * @memberof DynamicView\n   */\n  count() {\n    // in order to be accurate we will pay the minimum cost (and not alter dv state management)\n    // recurring resultset data resolutions should know internally its already up to date.\n    // for persistent data this will not update resultdata nor fire rebuild event.\n    if (this.resultsdirty) {\n      this.resultdata = this.resultset.data();\n    }\n\n    return this.resultset.count();\n  }\n\n  /**\n   * data() - resolves and pending filtering and sorting, then returns document array as result.\n   *\n   * @param {object=} options - optional parameters to pass to resultset.data() if non-persistent\n   * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n   *        the collection is not configured for clone object.\n   * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n   *        Possible values include 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'\n   * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents\n   * @returns {array} An array of documents representing the current DynamicView contents.\n   * @memberof DynamicView\n   */\n  data(options?: object) {\n    // using final sort phase as 'catch all' for a few use cases which require full rebuild\n    if (this.sortDirty || this.resultsdirty) {\n      this.performSortPhase({\n        suppressRebuildEvent: true,\n      });\n    }\n    return this.options.persistent\n      ? this.resultdata\n      : this.resultset.data(options);\n  }\n\n  /**\n   * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n   *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n   */\n  queueRebuildEvent() {\n    if (this.rebuildPending) {\n      return;\n    }\n    this.rebuildPending = true;\n\n    const self = this;\n    setTimeout(() => {\n      if (self.rebuildPending) {\n        self.rebuildPending = false;\n        self.emit(\"rebuild\", self);\n      }\n    }, this.options.minRebuildInterval);\n  }\n\n  /**\n   * queueSortPhase : If the view is sorted we will throttle sorting to either :\n   *    (1) passive - when the user calls data(), or\n   *    (2) active - once they stop updating and yield js thread control\n   */\n  queueSortPhase() {\n    // already queued? exit without queuing again\n    if (this.sortDirty) {\n      return;\n    }\n    this.sortDirty = true;\n\n    const self = this;\n    if (this.options.sortPriority === \"active\") {\n      // active sorting... once they are done and yield js thread, run async performSortPhase()\n      setTimeout(() => {\n        self.performSortPhase();\n      }, this.options.minRebuildInterval);\n    } else {\n      // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n      // potentially notify user that data has changed.\n      this.queueRebuildEvent();\n    }\n  }\n\n  /**\n   * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n   *\n   */\n  performSortPhase(options?: Record<string, any>) {\n    // async call to this may have been pre-empted by synchronous call to data before async could fire\n    if (!this.sortDirty && !this.resultsdirty) {\n      return;\n    }\n\n    options = options || {};\n\n    if (this.sortDirty) {\n      if (this.sortFunction) {\n        this.resultset.sort(this.sortFunction);\n      } else if (this.sortCriteria) {\n        this.resultset.compoundsort(this.sortCriteria);\n      } else if (this.sortCriteriaSimple) {\n        this.resultset.simplesort(\n          this.sortCriteriaSimple.propname,\n          this.sortCriteriaSimple.options,\n        );\n      }\n\n      this.sortDirty = false;\n    }\n\n    if (this.options.persistent) {\n      // persistent view, rebuild local resultdata array\n      this.resultdata = this.resultset.data();\n      this.resultsdirty = false;\n    }\n\n    if (!options.suppressRebuildEvent) {\n      this.emit(\"rebuild\", this);\n    }\n  }\n\n  /**\n   * evaluateDocument() - internal method for (re)evaluating document inclusion.\n   *    Called by : collection.insert() and collection.update().\n   *\n   * @param {int} objIndex - index of document to (re)run through filter pipeline.\n   * @param {bool} isNew - true if the document was just added to the collection.\n   */\n  evaluateDocument(objIndex, isNew) {\n    // if no filter applied yet, the result 'set' should remain 'everything'\n    if (!this.resultset.filterInitialized) {\n      if (this.options.persistent) {\n        this.resultdata = this.resultset.data();\n      }\n      // need to re-sort to sort new document\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n      return;\n    }\n\n    const ofr = this.resultset.filteredrows;\n    const oldPos = isNew ? -1 : ofr.indexOf(+objIndex);\n    const oldlen = ofr.length;\n\n    // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n    // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n    const evalResultset = new ResultSet(this.collection);\n    evalResultset.filteredrows = [objIndex];\n    evalResultset.filterInitialized = true;\n    let filter;\n    for (let idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n      filter = this.filterPipeline[idx];\n      evalResultset[filter.type](filter.val);\n    }\n\n    // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n    const newPos = evalResultset.filteredrows.length === 0 ? -1 : 0;\n\n    // wasn't in old, shouldn't be now... do nothing\n    if (oldPos === -1 && newPos === -1) return;\n\n    // wasn't in resultset, should be now... add\n    if (oldPos === -1 && newPos !== -1) {\n      ofr.push(objIndex);\n\n      if (this.options.persistent) {\n        this.resultdata.push(this.collection.data[objIndex]);\n      }\n\n      // need to re-sort to sort new document\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n\n      return;\n    }\n\n    // was in resultset, shouldn't be now... delete\n    if (oldPos !== -1 && newPos === -1) {\n      if (oldPos < oldlen - 1) {\n        ofr.splice(oldPos, 1);\n\n        if (this.options.persistent) {\n          this.resultdata.splice(oldPos, 1);\n        }\n      } else {\n        ofr.length = oldlen - 1;\n\n        if (this.options.persistent) {\n          this.resultdata.length = oldlen - 1;\n        }\n      }\n\n      // in case changes to data altered a sort column\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n\n      return;\n    }\n\n    // was in resultset, should still be now... (update persistent only?)\n    if (oldPos !== -1 && newPos !== -1) {\n      if (this.options.persistent) {\n        // in case document changed, replace persistent view data with the latest collection.data document\n        this.resultdata[oldPos] = this.collection.data[objIndex];\n      }\n\n      // in case changes to data altered a sort column\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n\n      return;\n    }\n  }\n\n  /**\n   * removeDocument() - internal function called on collection.delete()\n   * @param {number|number[]} objIndex - index of document to (re)run through filter pipeline.\n   */\n  removeDocument(objIndex) {\n    let idx;\n    let rmidx;\n    const rxo = {};\n    const fxo = {};\n    let adjels = [];\n    const drs = this.resultset;\n    const fr = this.resultset.filteredrows;\n    let frlen = fr.length;\n\n    // if no filter applied yet, the result 'set' should remain 'everything'\n    if (!this.resultset.filterInitialized) {\n      if (this.options.persistent) {\n        this.resultdata = this.resultset.data();\n      }\n      // in case changes to data altered a sort column\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n      return;\n    }\n\n    // if passed single index, wrap in array\n    if (!Array.isArray(objIndex)) {\n      objIndex = [objIndex];\n    }\n\n    const rmlen = objIndex.length;\n    // create intersection object of data indices to remove\n    for (rmidx = 0; rmidx < rmlen; rmidx++) {\n      rxo[objIndex[rmidx]] = true;\n    }\n\n    // pivot remove data indices into remove filteredrows indices and dump in hashobject\n    for (idx = 0; idx < frlen; idx++) {\n      if (rxo[fr[idx]]) fxo[idx] = true;\n    }\n\n    // if any of the removed items were in our filteredrows...\n    if (Object.keys(fxo).length > 0) {\n      // remove them from filtered rows\n      this.resultset.filteredrows = this.resultset.filteredrows.filter(\n        (di, idx) => !fxo[idx],\n      );\n      // if persistent...\n      if (this.options.persistent) {\n        // remove from resultdata\n        this.resultdata = this.resultdata.filter((obj, idx) => !fxo[idx]);\n      }\n\n      // and queue sorts\n      if (this.sortFunction || this.sortCriteria || this.sortCriteriaSimple) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n    }\n\n    // to remove holes, we need to 'shift down' indices, this filter function finds number of positions to shift\n    const filt = (idx) => (di) => di < drs.filteredrows[idx];\n\n    frlen = drs.filteredrows.length;\n    for (idx = 0; idx < frlen; idx++) {\n      // grab subset of removed elements where data index is less than current filtered row data index;\n      // use this to determine how many positions iterated remaining data index needs to be 'shifted down'\n      adjels = objIndex.filter(filt(idx));\n      drs.filteredrows[idx] -= adjels.length;\n    }\n  }\n\n  /**\n   * mapReduce() - data transformation via user supplied functions\n   *\n   * @param {function} mapFunction - this function accepts a single document for you to transform and return\n   * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n   * @returns The output of your reduceFunction\n   * @memberof DynamicView\n   */\n  mapReduce(mapFunction, reduceFunction) {\n    return reduceFunction(this.data().map(mapFunction));\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\n\n/**\n * @class ExactIndex\n * @classdesc\n * ExactIndex is a simple index that allows you to store a value\n * and retrieve it by key. The key must be an exact match.\n * @example\n * var index = new ExactIndex();\n * index.set(\"foo\", 1);\n * index.get(\"foo\"); // [1]\n * index.get(\"bar\"); // undefined\n * index.set(\"foo\", 2);\n * index.get(\"foo\"); // [2]\n * index.remove(\"foo\");\n * index.get(\"foo\"); // undefined\n * index.set(\"foo\", 1);\n * index.clear();\n * index.get(\"foo\"); // undefined\n * @param {string} exactField - The field to index on\n * @returns {ExactIndex} - The ExactIndex object\n */\nexport class ExactIndex<T extends number> {\n  #index: Record<string, T[]>;\n  field: string;\n  constructor(exactField: string) {\n    this.#index = Object.create(null);\n    this.field = exactField;\n  }\n\n  // add the value you want returned to the key in the index\n  set(key: string | number, val: T) {\n    if (this.#index[key]) {\n      this.#index[key].push(val);\n    } else {\n      this.#index[key] = [val];\n    }\n  }\n\n  // remove the value from the index, if the value was the last one, remove the key\n  remove(key: string | number, val: T) {\n    const idxSet = this.#index[key];\n    for (const indexKey in idxSet) {\n      if (idxSet[indexKey] === val) {\n        idxSet.splice(parseInt(indexKey), 1);\n      }\n    }\n    if (idxSet.length < 1) {\n      this.#index[key] = undefined;\n    }\n  }\n\n  // get the values related to the key, could be more than one\n  get(key: string | number) {\n    return this.#index[key];\n  }\n\n  // clear will zap the index\n  clear() {\n    this.#index = {};\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\n\nexport class UniqueIndex {\n  field: any;\n  keyMap: any;\n  lokiMap: any;\n  constructor(uniqueField) {\n    this.field = uniqueField;\n    this.keyMap = Object.create(null);\n    this.lokiMap = Object.create(null);\n  }\n\n  set(obj) {\n    const fieldValue = obj[this.field];\n    if (fieldValue !== null && typeof fieldValue !== \"undefined\") {\n      if (this.keyMap[fieldValue]) {\n        throw new Error(\n          `Duplicate key for property ${this.field}: ${fieldValue}`\n        );\n      } else {\n        this.keyMap[fieldValue] = obj;\n        this.lokiMap[obj.$loki] = fieldValue;\n      }\n    }\n  }\n\n  get(key) {\n    return this.keyMap[key];\n  }\n\n  byId(id) {\n    return this.keyMap[this.lokiMap[id]];\n  }\n\n  /**\n   * Updates a document's unique index given an updated object.\n   * @param  {Object} obj Original document object\n   * @param  {Object} doc New document object (likely the same as obj)\n   */\n  update(obj, doc) {\n    if (this.lokiMap[obj.$loki] !== doc[this.field]) {\n      const old = this.lokiMap[obj.$loki];\n      this.set(doc);\n      // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n      this.keyMap[old] = undefined;\n    } else {\n      this.keyMap[obj[this.field]] = doc;\n    }\n  }\n\n  remove(key) {\n    const obj = this.keyMap[key];\n    if (obj !== null && typeof obj !== \"undefined\") {\n      // avoid using `delete`\n      this.keyMap[key] = undefined;\n      this.lokiMap[obj.$loki] = undefined;\n    } else {\n      throw new Error(`Key is not in unique index: ${this.field}`);\n    }\n  }\n\n  clear() {\n    this.keyMap = Object.create(null);\n    this.lokiMap = Object.create(null);\n  }\n}\n\nUniqueIndex.prototype.keyMap = {};\nUniqueIndex.prototype.lokiMap = {};\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n\"use strict\";\n/**\n * General utils, including statistical functions\n */\n\nexport function parseBase10(num) {\n  return parseInt(num, 10);\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n\"use strict\";\nimport { hasOwnProperty } from \"../sylviejs\";\nimport { deepProperty } from \"../utils/deep-property\";\nimport { CloneMethods, clone } from \"../utils/clone\";\nimport { deepFreeze, freeze, unFreeze } from \"../utils/icebox\";\nimport { Utils } from \"../utils/index\";\nimport { average, isDeepProperty, standardDeviation, sub } from \"../utils/math\";\nimport { LokiOps } from \"../utils/ops\";\nimport { Comparators } from \"../utils/sort\";\nimport { DynamicView, DynamicViewOptions } from \"./dynamic-view\";\nimport { ChangeOps } from \"./sylvie\";\nimport { SylvieEventEmitter } from \"./sylvie-event-emitter\";\nimport { ResultSet } from \"./result-set\";\nimport { ExactIndex } from \"./index/exact-index\";\nimport { UniqueIndex } from \"./index/unique-index\";\nimport { parseBase10 } from \"../utils/parse-base-10\";\n\nexport type ChainTransform =\n  | string\n  | {\n      type: string;\n      value?: any;\n      mapFunction?: (_: any) => any;\n      reduceFunction?: (values: any[]) => any;\n    }[];\n\ninterface CollectionOptions {\n  unique: string | string[];\n  exact: string[];\n  adaptiveBinaryIndices: boolean;\n  transactional: boolean;\n  cloneObjects: boolean;\n  cloneMethod: CloneMethods;\n  asyncListeners: boolean;\n  disableMeta: boolean;\n  disableChangesApi: boolean;\n  disableDeltaChangesApi: boolean;\n  autoupdate: boolean;\n  serializableIndices: boolean;\n  disableFreeze: boolean;\n  ttl: number;\n  ttlInterval: number;\n  indices: string | string[];\n  clone: boolean;\n}\n\nexport type CollectionDocument = object &\n  Record<string, any> &\n  CollectionDocumentBase;\n\nexport interface CollectionDocumentBase {\n  meta?: CollectionDocumentMeta;\n  $loki?: number;\n}\n\nexport interface CollectionDocumentMeta {\n  created?: number;\n  revision?: number;\n  updated?: number;\n}\n\nexport type BinaryIndex = Record<\n  string,\n  {\n    name: string;\n    dirty: boolean;\n    values: any[];\n  }\n>;\n\n/**\n * Collection class that handles documents of same type\n * @constructor Collection\n * @implements SylvieEventEmitter\n * @param {string} name - collection name\n * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n * @param {array=} [options.unique=[]] - array of property names to define unique constraints for\n * @param {array=} [options.exact=[]] - array of property names to define exact constraints for\n * @param {array=} [options.indices=[]] - array property names to define binary indexes for\n * @param {boolean} [options.adaptiveBinaryIndices=true] - collection indices will be actively rebuilt rather than lazily\n * @param {boolean} [options.asyncListeners=false] - whether listeners are invoked asynchronously\n * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents\n * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes API\n * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)\n * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically\n * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user\n * @param {boolean} [options.serializableIndices=true[]] - converts date values on binary indexed properties to epoch time\n * @param {boolean} [options.disableFreeze=true] - when false all docs are frozen\n * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow', 'shallow-assign'\n * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.\n * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n * @see {@link Loki#addCollection} for normal creation of collections\n */\n\nexport class Collection<\n  ColT extends Partial<CollectionDocument>,\n> extends SylvieEventEmitter {\n  data: ColT[];\n  isIncremental: boolean;\n  name: string;\n  idIndex: number[] | null;\n  binaryIndices: BinaryIndex;\n  constraints: {\n    unique: Record<string, UniqueIndex>;\n    exact: Record<string, ExactIndex<number>>;\n  };\n  uniqueNames: string[];\n  transforms: Record<string, (Record<string, any> & { type: string })[]>;\n  objType: string;\n  dirty: boolean;\n  cachedIndex: number[] | null;\n  cachedBinaryIndex: BinaryIndex | null;\n  cachedData: ColT[] | null;\n  adaptiveBinaryIndices: boolean;\n  transactional: boolean;\n  cloneObjects: boolean;\n  cloneMethod: CloneMethods;\n  disableMeta: boolean;\n  disableChangesApi: boolean;\n  disableDeltaChangesApi: boolean;\n  autoupdate: boolean;\n  serializableIndices: boolean;\n  disableFreeze: boolean;\n  ttl: {\n    age?: number;\n    ttlInterval?: number;\n    daemon?: ReturnType<typeof setInterval>;\n  };\n  maxId: number;\n  DynamicViews: DynamicView<ColT>[];\n  changes: ChangeOps[];\n  dirtyIds: number[];\n  observerCallback: (changes: any) => void;\n  getChangeDelta: (obj: any, old: any) => any;\n  getObjectDelta: (oldObject: any, newObject: any) => any;\n  getChanges: () => any;\n  flushChanges: () => void;\n  setChangesApi: (enabled: any) => void;\n  cachedDirtyIds: number[];\n  /**\n   * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n   * manipulated without affecting the data in the original collection\n   */\n  stages: Record<string, CollectionDocument> = {};\n  /**\n   * a collection of objects recording the changes applied through a commmitStage\n   */\n  commitLog: {\n    timestamp: number;\n    message: string;\n    data: string;\n  }[] = [];\n  no_op: () => void;\n  constructor(name: string, options?: Partial<CollectionOptions>) {\n    super();\n    // the name of the collection\n    this.name = name;\n    // the data held by the collection\n    this.data = [];\n    this.idIndex = null; // position->$loki index (built lazily)\n    this.binaryIndices = {}; // user defined indexes\n    this.constraints = {\n      unique: {},\n      exact: {},\n    };\n\n    // unique contraints contain duplicate object references, so they are not persisted.\n    // we will keep track of properties which have unique contraint applied here, and regenerate lazily\n    this.uniqueNames = [];\n\n    // transforms will be used to store frequently used query chains as a series of steps\n    // which itself can be stored along with the database.\n    this.transforms = {};\n\n    // the object type of the collection\n    this.objType = name;\n\n    // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n    // currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n    // defaulting to true since this is called from addCollection and adding a collection should trigger save\n    this.dirty = true;\n\n    // private holders for cached data\n    this.cachedIndex = null;\n    this.cachedBinaryIndex = null;\n    this.cachedData = null;\n    const self = this;\n\n    /* OPTIONS */\n    options = options || {};\n\n    // exact match and unique constraints\n    if (options.unique) {\n      if (!Array.isArray(options.unique)) {\n        options.unique = [options.unique];\n      }\n      // save names; actual index is built lazily\n      options.unique.forEach((prop) => {\n        self.uniqueNames.push(prop);\n      });\n    }\n\n    if (options.exact) {\n      options.exact.forEach((prop) => {\n        self.constraints.exact[prop] = new ExactIndex(prop);\n      });\n    }\n\n    // if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n    // if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n    this.adaptiveBinaryIndices = Object.hasOwn(options, \"adaptiveBinaryIndices\")\n      ? options.adaptiveBinaryIndices!\n      : true;\n\n    // is collection transactional\n    this.transactional = Object.hasOwn(options, \"transactional\")\n      ? options.transactional!\n      : false;\n\n    // options to clone objects when inserting them\n    this.cloneObjects = Object.hasOwn(options, \"clone\")\n      ? options.clone!\n      : false;\n\n    // default clone method (if enabled) is parse-stringify\n    this.cloneMethod = Object.hasOwn(options, \"cloneMethod\")\n      ? options.cloneMethod!\n      : \"parse-stringify\";\n\n    // option to make event listeners async, default is sync\n    this.asyncListeners = Object.hasOwn(options, \"asyncListeners\")\n      ? options.asyncListeners!\n      : false;\n\n    // if set to true we will not maintain a meta property for a document\n    this.disableMeta = Object.hasOwn(options, \"disableMeta\")\n      ? options.disableMeta!\n      : false;\n\n    // disable track changes\n    this.disableChangesApi = Object.hasOwn(options, \"disableChangesApi\")\n      ? options.disableChangesApi!\n      : true;\n\n    // disable delta update object style on changes\n    this.disableDeltaChangesApi = Object.hasOwn(\n      options,\n      \"disableDeltaChangesApi\",\n    )\n      ? options.disableDeltaChangesApi!\n      : true;\n\n    if (this.disableChangesApi) {\n      this.disableDeltaChangesApi = true;\n    }\n\n    // option to observe objects and update them automatically, ignored if Object.observe is not supported\n    this.autoupdate = Object.hasOwn(options, \"autoupdate\")\n      ? options.autoupdate!\n      : false;\n\n    // by default, if you insert a document into a collection with binary indices, if those indexed properties contain\n    // a DateTime we will convert to epoch time format so that (across serializations) its value position will be the\n    // same 'after' serialization as it was 'before'.\n    this.serializableIndices = Object.hasOwn(options, \"serializableIndices\")\n      ? options.serializableIndices!\n      : true;\n\n    // option to deep freeze all documents\n    this.disableFreeze = Object.hasOwn(options, \"disableFreeze\")\n      ? options.disableFreeze!\n      : true;\n\n    //option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n    this.ttl = {\n      age: null,\n      ttlInterval: null,\n      daemon: null,\n    };\n    this.setTTL(options.ttl || -1, options.ttlInterval);\n\n    // currentMaxId - change manually at your own peril!\n    this.maxId = 0;\n\n    this.DynamicViews = [];\n\n    // events\n    this.events = {\n      insert: [],\n      update: [],\n      \"pre-insert\": [],\n      \"pre-update\": [],\n      close: [],\n      flushbuffer: [],\n      error: [],\n      delete: [],\n      warning: [],\n    };\n\n    // changes are tracked by collection and aggregated by the db\n    this.changes = [];\n\n    // lightweight changes tracking (loki IDs only) for optimized db saving\n    this.dirtyIds = [];\n\n    // initialize optional user-supplied indices array ['age', 'lname', 'zip']\n    let indices: string[] = [];\n    if (options && options.indices) {\n      if (\n        Object.prototype.toString.call(options.indices) === \"[object Array]\"\n      ) {\n        indices = options.indices as string[];\n      } else if (typeof options.indices === \"string\") {\n        indices = [options.indices];\n      } else {\n        throw new TypeError(\n          \"Indices needs to be a string or an array of strings\",\n        );\n      }\n    }\n\n    for (let idx = 0; idx < indices.length; idx++) {\n      this.ensureIndex(indices[idx]);\n    }\n\n    function observerCallback(changes: { object: object }[]) {\n      const changedObjects = new Set<object>();\n\n      if (!changedObjects.add)\n        changedObjects.add = function (object) {\n          if (!this.includes(object)) this.push(object);\n          return this;\n        };\n\n      changes.forEach(({ object }) => {\n        changedObjects.add(object);\n      });\n\n      changedObjects.forEach((object) => {\n        if (!hasOwnProperty.call(object, \"$loki\"))\n          return self.removeAutoUpdateObserver(object);\n        try {\n          self.update(object);\n        } catch (err) {\n          console.log(err);\n        }\n      });\n    }\n\n    this.observerCallback = observerCallback;\n\n    //Compare changed object (which is a forced clone) with existing object and return the delta\n    function getChangeDelta(obj: object, old: object) {\n      if (old) {\n        return getObjectDelta(old, obj);\n      } else {\n        return JSON.parse(JSON.stringify(obj));\n      }\n    }\n\n    this.getChangeDelta = getChangeDelta;\n\n    function getObjectDelta(oldObject: object, newObject: object) {\n      const propertyNames =\n        newObject !== null && typeof newObject === \"object\"\n          ? Object.keys(newObject)\n          : null;\n      if (\n        propertyNames &&\n        propertyNames.length &&\n        ![\"string\", \"boolean\", \"number\"].includes(typeof newObject)\n      ) {\n        const delta = {};\n        for (let i = 0; i < propertyNames.length; i++) {\n          const propertyName = propertyNames[i];\n          if (propertyName in newObject) {\n            if (\n              !(propertyName in oldObject) ||\n              self.uniqueNames.includes(propertyName) ||\n              propertyName == \"$loki\" ||\n              propertyName == \"meta\"\n            ) {\n              delta[propertyName] = newObject[propertyName];\n            } else {\n              const propertyDelta = getObjectDelta(\n                oldObject[propertyName],\n                newObject[propertyName],\n              );\n              if (typeof propertyDelta !== \"undefined\") {\n                delta[propertyName] = propertyDelta;\n              }\n            }\n          }\n        }\n        return Object.keys(delta).length === 0 ? undefined : delta;\n      } else {\n        return oldObject === newObject ? undefined : newObject;\n      }\n    }\n\n    this.getObjectDelta = getObjectDelta;\n\n    // clear all the changes\n    function flushChanges() {\n      self.changes = [];\n    }\n\n    this.getChanges = () => self.changes;\n\n    this.flushChanges = flushChanges;\n\n    this.setChangesApi = (enabled) => {\n      self.disableChangesApi = !enabled;\n      if (!enabled) {\n        self.disableDeltaChangesApi = false;\n      }\n    };\n\n    this.on(\"delete\", function deleteCallback(obj) {\n      if (!self.disableChangesApi) {\n        self.createChange(self.name, \"R\", obj);\n      }\n    });\n\n    this.on(\"warning\", (warning) => {\n      self.lokiConsoleWrapper.warn(warning);\n    });\n    // for de-serialization purposes\n    flushChanges();\n  }\n\n  /*\n   * For ChangeAPI default to clone entire object, for delta changes create object with only differences (+ $loki and meta)\n   */\n  createChange<T extends Partial<CollectionDocument>>(\n    name: string,\n    op: \"U\" | \"I\" | \"R\",\n    obj: T,\n    old?: T,\n  ) {\n    this.changes.push({\n      name,\n      operation: op,\n      obj:\n        op == \"U\" && !this.disableDeltaChangesApi\n          ? this.getChangeDelta(obj, old)\n          : JSON.parse(JSON.stringify(obj)),\n    });\n  }\n\n  insertMeta<T extends Partial<CollectionDocument>>(obj: T) {\n    let len: number;\n    let idx: number;\n\n    if (this.disableMeta || !obj) {\n      return;\n    }\n\n    // if batch insert\n    if (Array.isArray(obj)) {\n      len = obj.length;\n\n      for (idx = 0; idx < len; idx++) {\n        if (!(\"meta\" in obj[idx])) {\n          obj[idx].meta = {};\n        }\n\n        obj[idx].meta.created = new Date().getTime();\n        obj[idx].meta.revision = 0;\n      }\n\n      return;\n    }\n\n    // single object\n    if (!obj.meta) {\n      obj.meta = {};\n    }\n\n    obj.meta.created = new Date().getTime();\n    obj.meta.revision = 0;\n  }\n\n  updateMeta<T extends CollectionDocument>(obj: T) {\n    if (this.disableMeta || !obj) {\n      return obj;\n    }\n    if (!this.disableFreeze) {\n      obj = unFreeze(obj);\n      obj.meta = unFreeze(obj.meta);\n    }\n    obj.meta.updated = new Date().getTime();\n    obj.meta.revision += 1;\n    return obj;\n  }\n\n  createInsertChange<T extends Partial<CollectionDocument>>(obj: T) {\n    this.createChange(this.name, \"I\", obj);\n  }\n\n  createUpdateChange(obj: CollectionDocument, old: CollectionDocument) {\n    this.createChange(this.name, \"U\", obj, old);\n  }\n\n  insertMetaWithChange<T extends Partial<CollectionDocument>>(obj: T) {\n    this.insertMeta(obj);\n    this.createInsertChange(obj);\n  }\n\n  updateMetaWithChange<T extends CollectionDocument>(obj: T, old: T): T {\n    obj = this.updateMeta(obj);\n    this.createUpdateChange(obj, old);\n    return obj;\n  }\n\n  addAutoUpdateObserver<T extends CollectionDocument>(object: T) {\n    if (!this.autoupdate || typeof Object.observe !== \"function\") return;\n\n    Object.observe(object, this.observerCallback, [\n      \"add\",\n      \"update\",\n      \"delete\",\n      \"reconfigure\",\n      \"setPrototype\",\n    ]);\n  }\n\n  removeAutoUpdateObserver<T extends object>(object: T) {\n    if (!this.autoupdate || typeof Object.observe !== \"function\") return;\n\n    Object.unobserve(object, this.observerCallback);\n  }\n\n  /**\n   * Adds a named collection transform to the collection\n   * @param {string} name - name to associate with transform\n   * @param {array} transform - an array of transformation 'step' objects to save into the collection\n   \n   * @example\n   * users.addTransform('progeny', [\n   *   {\n   *     type: 'find',\n   *     value: {\n   *       'age': {'$lte': 40}\n   *     }\n   *   }\n   * ]);\n   *\n   * var results = users.chain('progeny').data();\n   */\n  addTransform(\n    name: string,\n    transform: (Record<string, any> & { type: string })[],\n  ) {\n    if (name in this.transforms) {\n      throw new Error(\"a transform by that name already exists\");\n    }\n\n    this.transforms[name] = transform;\n  }\n\n  /**\n   * Retrieves a named transform from the collection.\n   * @param {string} name - name of the transform to lookup.\n   */\n  getTransform(name: string) {\n    return this.transforms[name];\n  }\n\n  /**\n   * Updates a named collection transform to the collection\n   * @param {string} name - name to associate with transform\n   * @param {object} transform - a transformation object to save into collection\n   \n   */\n  setTransform(\n    name: string,\n    transform: (Record<string, any> & { type: string })[],\n  ) {\n    this.transforms[name] = transform;\n  }\n\n  /**\n   * Removes a named collection transform from the collection\n   * @param {string} name - name of collection transform to remove\n   \n   */\n  removeTransform(name: string) {\n    delete this.transforms[name];\n  }\n\n  // convert a template into a $and query\n  byExample(template: Record<string, any>) {\n    let prop: string;\n    let obj: object;\n    const query = [];\n    for (prop in template) {\n      if (!(prop in template)) continue;\n      query.push(((obj = {}), (obj[prop] = template[prop]), obj));\n    }\n    return {\n      $and: query,\n    };\n  }\n\n  findObject(template: Record<string, any>) {\n    return this.findOne(this.byExample(template));\n  }\n\n  findObjects(template: Record<string, any>) {\n    return this.find(this.byExample(template));\n  }\n\n  /*----------------------------+\n  | TTL daemon                  |\n  +----------------------------*/\n  ttlDaemonFuncGen() {\n    const collection = this;\n    const age = this.ttl.age;\n    return function ttlDaemon() {\n      const now = Date.now();\n      const toRemove = (collection.chain() as ResultSet<ColT>).where(\n        function daemonFilter(member: CollectionDocument) {\n          const timestamp = member.meta.updated || member.meta.created;\n          const diff = now - timestamp;\n          return age < diff;\n        },\n      );\n      toRemove.remove();\n    };\n  }\n\n  /**\n   * Updates or applies collection TTL settings.\n   * @param {int} age - age (in ms) to expire document from collection\n   * @param {int} interval - time (in ms) to clear collection of aged documents.\n   \n   */\n  setTTL(age: number, interval: number) {\n    if (age < 0) {\n      clearInterval(this.ttl.daemon);\n    } else {\n      this.ttl.age = age;\n      this.ttl.ttlInterval = interval;\n      this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n    }\n  }\n\n  /*----------------------------+\n  | INDEXING                    |\n  +----------------------------*/\n  /**\n   * create a row filter that covers all documents in the collection\n   */\n  prepareFullDocIndex(): any[] {\n    const len = this.data.length;\n    const indexes = new Array(len);\n    for (let i = 0; i < len; i += 1) {\n      indexes[i] = i;\n    }\n    return indexes;\n  }\n\n  /**\n   * Will allow reconfiguring certain collection options.\n   * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n   \n   */\n  configureOptions = (options: { adaptiveBinaryIndices?: boolean } = {}) => {\n    if (\"adaptiveBinaryIndices\" in options) {\n      this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\n      // if switching to adaptive binary indices, make sure none are 'dirty'\n      if (this.adaptiveBinaryIndices) {\n        this.ensureAllIndexes();\n      }\n    }\n  };\n\n  /**\n   * Ensure binary index on a certain field\n   * @param {string} property - name of property to create binary index on\n   * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n   \n   */\n  ensureIndex(property: string, force?: boolean) {\n    // optional parameter to force rebuild whether flagged as dirty or not\n    if (typeof force === \"undefined\") {\n      force = false;\n    }\n\n    if (property === null || property === undefined) {\n      throw new Error(\"Attempting to set index without an associated property\");\n    }\n\n    if (this.binaryIndices[property] && !force) {\n      if (!this.binaryIndices[property].dirty) {\n        return;\n      }\n    }\n\n    // if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n    if (\n      this.adaptiveBinaryIndices === true &&\n      property in this.binaryIndices &&\n      !force\n    ) {\n      return;\n    }\n\n    const index = {\n      name: property,\n      dirty: true,\n      values: this.prepareFullDocIndex(),\n    };\n    this.binaryIndices[property] = index;\n\n    const wrappedComparer = ((prop, data) => {\n      let val1;\n      let val2;\n      const propPath = ~prop.indexOf(\".\") ? prop.split(\".\") : false;\n      return (a, b) => {\n        if (propPath) {\n          val1 = Utils.getIn(data[a], propPath, true);\n          val2 = Utils.getIn(data[b], propPath, true);\n        } else {\n          val1 = data[a][prop];\n          val2 = data[b][prop];\n        }\n\n        if (val1 !== val2) {\n          if (Comparators.lt(val1, val2, false)) return -1;\n          if (Comparators.gt(val1, val2, false)) return 1;\n        }\n        return 0;\n      };\n    })(property, this.data);\n\n    index.values.sort(wrappedComparer);\n    index.dirty = false;\n\n    this.dirty = true; // for autosave scenarios\n  }\n\n  /**\n   * Perform checks to determine validity/consistency of all binary indices\n   * @param {object=} options - optional configuration object\n   * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used\n   * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample\n   * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered\n   * @returns {string[]} array of index names where problems were found.\n   \n   * @example\n   * // check all indices on a collection, returns array of invalid index names\n   * var result = coll.checkAllIndexes({ repair: true, randomSampling: true, randomSamplingFactor: 0.15 });\n   * if (result.length > 0) {\n   *   results.forEach(function(name) {\n   *     console.log('problem encountered with index : ' + name);\n   *   });\n   * }\n   */\n  checkAllIndexes(options?: {\n    randomSampling: boolean;\n    randomSamplingFactor: number;\n    repair: boolean;\n  }): string[] {\n    let key: string;\n    const bIndices = this.binaryIndices;\n    const results = [];\n    let result: boolean;\n\n    for (key in bIndices) {\n      if (hasOwnProperty.call(bIndices, key)) {\n        result = this.checkIndex(key, options);\n        if (!result) {\n          results.push(key);\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Perform checks to determine validity/consistency of a binary index\n   * @param {string} property - name of the binary-indexed property to check\n   * @param {object=} options - optional configuration object\n   * @param {boolean} [options.randomSampling=false] - whether (faster) random sampling should be used\n   * @param {number} [options.randomSamplingFactor=0.10] - percentage of total rows to randomly sample\n   * @param {boolean} [options.repair=false] - whether to fix problems if they are encountered\n   * @returns {boolean} whether the index was found to be valid (before optional correcting).\n   \n   * @example\n   * // full test\n   * var valid = coll.checkIndex('name');\n   * // full test with repair (if issues found)\n   * valid = coll.checkIndex('name', { repair: true });\n   * // random sampling (default is 10% of total document count)\n   * valid = coll.checkIndex('name', { randomSampling: true });\n   * // random sampling (sample 20% of total document count)\n   * valid = coll.checkIndex('name', { randomSampling: true, randomSamplingFactor: 0.20 });\n   * // random sampling (implied boolean)\n   * valid = coll.checkIndex('name', { randomSamplingFactor: 0.20 });\n   * // random sampling with repair (if issues found)\n   * valid = coll.checkIndex('name', { repair: true, randomSampling: true });\n   */\n  checkIndex(\n    property: string,\n    options: {\n      randomSampling?: boolean;\n      randomSamplingFactor?: number;\n      repair?: boolean;\n    } = {},\n  ): boolean {\n    // if 'randomSamplingFactor' specified but not 'randomSampling', assume true\n    if (options.randomSamplingFactor && options.randomSampling !== false) {\n      options.randomSampling = true;\n    }\n    options.randomSamplingFactor = options.randomSamplingFactor || 0.1;\n    if (options.randomSamplingFactor < 0 || options.randomSamplingFactor > 1) {\n      options.randomSamplingFactor = 0.1;\n    }\n\n    let valid = true;\n    let idx;\n    let iter;\n    let pos;\n\n    // make sure we are passed a valid binary index name\n    if (!(property in this.binaryIndices)) {\n      throw new Error(\n        `called checkIndex on property without an index: ${property}`,\n      );\n    }\n\n    // if lazy indexing, rebuild only if flagged as dirty\n    if (!this.adaptiveBinaryIndices) {\n      this.ensureIndex(property);\n    }\n\n    const biv = this.binaryIndices[property].values;\n    const len = biv.length;\n\n    // if the index has an incorrect number of values\n    if (len !== this.data.length) {\n      if (options.repair) {\n        this.ensureIndex(property, true);\n      }\n      return false;\n    }\n\n    if (len === 0) {\n      return true;\n    }\n\n    const usingDotNotation = property.includes(\".\");\n\n    if (len === 1) {\n      valid = biv[0] === 0;\n    } else {\n      if (options.randomSampling) {\n        // validate first and last\n        if (\n          !LokiOps.$lte(\n            Utils.getIn(this.data[biv[0]], property, usingDotNotation),\n            Utils.getIn(this.data[biv[1]], property, usingDotNotation),\n          )\n        ) {\n          valid = false;\n        }\n        if (\n          !LokiOps.$lte(\n            Utils.getIn(this.data[biv[len - 2]], property, usingDotNotation),\n            Utils.getIn(this.data[biv[len - 1]], property, usingDotNotation),\n          )\n        ) {\n          valid = false;\n        }\n\n        // if first and last positions are sorted correctly with their nearest neighbor,\n        // continue onto random sampling phase...\n        if (valid) {\n          // # random samplings = total count * sampling factor\n          iter = Math.floor((len - 1) * options.randomSamplingFactor);\n\n          // for each random sampling, validate that the binary index is sequenced properly\n          // with next higher value.\n          for (idx = 0; idx < iter - 1; idx++) {\n            // calculate random position\n            pos = Math.floor(Math.random() * (len - 1));\n            if (\n              !LokiOps.$lte(\n                Utils.getIn(this.data[biv[pos]], property, usingDotNotation),\n                Utils.getIn(\n                  this.data[biv[pos + 1]],\n                  property,\n                  usingDotNotation,\n                ),\n              )\n            ) {\n              valid = false;\n              break;\n            }\n          }\n        }\n      } else {\n        // validate that the binary index is sequenced properly\n        for (idx = 0; idx < len - 1; idx++) {\n          if (\n            !LokiOps.$lte(\n              Utils.getIn(this.data[biv[idx]], property, usingDotNotation),\n              Utils.getIn(this.data[biv[idx + 1]], property, usingDotNotation),\n            )\n          ) {\n            valid = false;\n            break;\n          }\n        }\n      }\n    }\n\n    // if incorrectly sequenced and we are to fix problems, rebuild index\n    if (!valid && options.repair) {\n      this.ensureIndex(property, true);\n    }\n\n    return valid;\n  }\n\n  getBinaryIndexValues(property: string) {\n    let idx;\n    const idxvals = this.binaryIndices[property].values;\n    const result = [];\n\n    for (idx = 0; idx < idxvals.length; idx++) {\n      result.push(Utils.getIn(this.data[idxvals[idx]], property, true));\n    }\n\n    return result;\n  }\n\n  /**\n   * Returns a named unique index\n   * @param {string} field - indexed field name\n   * @param {boolean} force - if `true`, will rebuild index; otherwise, function may return null\n   */\n  getUniqueIndex(field: string, force?: boolean) {\n    const index = this.constraints.unique[field];\n    if (!index && force) {\n      return this.ensureUniqueIndex(field);\n    }\n    return index;\n  }\n\n  ensureUniqueIndex(field) {\n    let index: UniqueIndex = this.constraints.unique[field];\n    if (!index) {\n      // keep track of new unique index for regenerate after database (re)load.\n      if (!this.uniqueNames.includes(field)) {\n        this.uniqueNames.push(field);\n      }\n    }\n\n    // if index already existed, (re)loading it will likely cause collisions, rebuild always\n    this.constraints.unique[field] = index = new UniqueIndex(field);\n    this.data.forEach((obj) => {\n      index.set(obj);\n    });\n    return index;\n  }\n\n  /**\n   * Ensure all binary indices\n   * @param {boolean} force - whether to force rebuild of existing lazy binary indices\n   \n   */\n  ensureAllIndexes(force?: boolean) {\n    const bIndices = this.binaryIndices;\n    for (const key in bIndices) {\n      if (hasOwnProperty.call(bIndices, key)) {\n        this.ensureIndex(key, force);\n      }\n    }\n  }\n\n  /**\n   * Internal method used to flag all lazy index as dirty\n   */\n  flagBinaryIndexesDirty() {\n    const bIndices = this.binaryIndices;\n    for (const key in bIndices) {\n      if (hasOwnProperty.call(bIndices, key)) {\n        bIndices[key].dirty = true;\n      }\n    }\n  }\n\n  /**\n   * Internal method used to flag a lazy index as dirty\n   */\n  flagBinaryIndexDirty(index) {\n    if (this.binaryIndices[index]) this.binaryIndices[index].dirty = true;\n  }\n\n  /**\n   * Quickly determine number of documents in collection (or query)\n   * @param {object=} query - (optional) query object to count results of\n   * @returns {number} number of documents in the collection\n   \n   */\n  count = (query?: Record<string, any>) => {\n    if (!query) {\n      return this.data.length;\n    }\n\n    return (this.chain() as ResultSet<ColT>).find(query).filteredrows.length;\n  };\n\n  /**\n   * Rebuild idIndex\n   */\n  ensureId() {\n    if (this.idIndex) {\n      return;\n    }\n    const data = this.data;\n    let i = 0;\n    const len = data.length;\n    const index = new Array(len);\n    for (i; i < len; i++) {\n      index[i] = data[i].$loki;\n    }\n    this.idIndex = index;\n  }\n\n  /**\n   * Rebuild idIndex async with callback - useful for background syncing with a remote server\n   */\n  ensureIdAsync(callback) {\n    this.async(function () {\n      this.ensureId();\n    }, callback);\n  }\n\n  /**\n   * Add a dynamic view to the collection\n   * @param {string} name - name of dynamic view to add\n   * @param {object=} options - options to configure dynamic view with\n   * @param {boolean} [options.persistent=false] - indicates if view is to main internal results array in 'resultdata'\n   * @param {string} [options.sortPriority='passive'] - 'passive' (sorts performed on call to data) or 'active' (after updates)\n   * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n   * @returns {DynamicView} reference to the dynamic view added\n   * @example\n   * var pview = users.addDynamicView('progeny');\n   * pview.applyFind({'age': {'$lte': 40}});\n   * pview.applySimpleSort('name');\n   *\n   * var results = pview.data();\n   **/\n  addDynamicView(name?: string, options?: Partial<DynamicViewOptions>) {\n    const dv = new DynamicView(this, name, options);\n    this.DynamicViews.push(dv);\n\n    return dv;\n  }\n\n  /**\n   * Remove a dynamic view from the collection\n   * @param {string} name - name of dynamic view to remove\n   **/\n  removeDynamicView(name) {\n    this.DynamicViews = this.DynamicViews.filter((dv) => dv.name !== name);\n  }\n\n  /**\n   * Look up dynamic view reference from within the collection\n   * @param {string} name - name of dynamic view to retrieve reference of\n   * @returns {DynamicView} A reference to the dynamic view with that name\n   **/\n  getDynamicView(name) {\n    for (let idx = 0; idx < this.DynamicViews.length; idx++) {\n      if (this.DynamicViews[idx].name === name) {\n        return this.DynamicViews[idx];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Applies a 'mongo-like' find query object and passes all results to an update function.\n   * For filter function querying you should migrate to [updateWhere()]{@link Collection#updateWhere}.\n   *\n   * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n   * @param {function} updateFunction - update function to run against filtered documents\n   */\n  findAndUpdate(filterObject, updateFunction) {\n    if (typeof filterObject === \"function\") {\n      this.updateWhere(filterObject, updateFunction);\n    } else {\n      (this.chain() as ResultSet<ColT>)\n        .find(filterObject)\n        .update(updateFunction);\n    }\n  }\n\n  /**\n   * Applies a 'mongo-like' find query object removes all documents which match that filter.\n   *\n   * @param {object} filterObject - 'mongo-like' query object\n   */\n  findAndRemove(filterObject?: Record<string, any>) {\n    (this.chain() as ResultSet<ColT>).find(filterObject).remove();\n  }\n\n  /**\n   * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n   * @param {(object|array)} doc - the document (or array of documents) to be inserted\n   * @param {boolean=} overrideAdaptiveIndices - (optional) if `true`, adaptive indicies will be\n   *   temporarily disabled and then fully rebuilt after batch. This will be faster for\n   *   large inserts, but slower for small/medium inserts in large collections\n   * @returns {(object|array)} document or documents inserted\n   * @example\n   * users.insert({\n   *     name: 'Odin',\n   *     age: 50,\n   *     address: 'Asgard'\n   * });\n   *\n   * // alternatively, insert array of documents\n   * users.insert([{ name: 'Thor', age: 35}, { name: 'Loki', age: 30}]);\n   */\n  insert<T extends CollectionDocument | CollectionDocument[]>(\n    doc: T,\n    overrideAdaptiveIndices?: boolean,\n  ): T {\n    if (!Array.isArray(doc)) {\n      return this.insertOne(doc as CollectionDocument) as T;\n    }\n\n    // holder to the clone of the object inserted if collections is set to clone objects\n    let obj;\n    let results = [];\n\n    // if not cloning, disable adaptive binary indices for the duration of the batch insert,\n    // followed by lazy rebuild and re-enabling adaptive indices after batch insert.\n    const adaptiveBatchOverride =\n      overrideAdaptiveIndices &&\n      !this.cloneObjects &&\n      this.adaptiveBinaryIndices &&\n      Object.keys(this.binaryIndices).length > 0;\n\n    if (adaptiveBatchOverride) {\n      this.adaptiveBinaryIndices = false;\n    }\n\n    try {\n      this.emit(\"pre-insert\", doc);\n      for (let i = 0, len = doc.length; i < len; i++) {\n        obj = this.insertOne(doc[i], true);\n        if (!obj) {\n          return undefined;\n        }\n        results.push(obj);\n      }\n    } finally {\n      if (adaptiveBatchOverride) {\n        this.ensureAllIndexes();\n        this.adaptiveBinaryIndices = true;\n      }\n    }\n\n    // at the 'batch' level, if clone option is true then emitted docs are clones\n    this.emit(\"insert\", results);\n\n    // if clone option is set, clone return values\n    results = this.cloneObjects ? clone(results, this.cloneMethod) : results;\n\n    return results.length === 1 ? results[0] : results;\n  }\n\n  /**\n   * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n   * @param {object} doc - the document to be inserted\n   * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n   * @returns {object} document or 'undefined' if there was a problem inserting it\n   */\n  insertOne<T extends CollectionDocument>(\n    doc: T,\n    bulkInsert?: boolean,\n  ): T | undefined {\n    let err = null;\n\n    if (typeof doc !== \"object\") {\n      err = new TypeError(\"Document needs to be an object\");\n    } else if (doc === null) {\n      err = new TypeError(\"Object cannot be null\");\n    }\n\n    if (err !== null) {\n      this.emit(\"error\", err);\n      throw err;\n    }\n\n    // if configured to clone, do so now... otherwise just use same obj reference\n    let obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n    if (!this.disableFreeze) {\n      obj = unFreeze(obj);\n    }\n\n    if (!this.disableMeta) {\n      if (typeof obj.meta === \"undefined\") {\n        obj.meta = {\n          revision: 0,\n          created: 0,\n        };\n      } else if (!this.disableFreeze) {\n        obj.meta = unFreeze(obj.meta);\n      }\n    }\n\n    // both 'pre-insert' and 'insert' events are passed internal data reference even when cloning\n    // insert needs internal reference because that is where loki itself listens to add meta\n    if (!bulkInsert) {\n      this.emit(\"pre-insert\", obj);\n    }\n    if (!this.add(obj)) {\n      return undefined;\n    }\n\n    // update meta and store changes if ChangesAPI is enabled\n    // (moved from \"insert\" event listener to allow internal reference to be used)\n    if (this.disableChangesApi) {\n      this.insertMeta(obj);\n    } else {\n      this.insertMetaWithChange(obj);\n    }\n\n    if (!this.disableFreeze) {\n      deepFreeze(obj);\n    }\n\n    // if cloning is enabled, emit insert event with clone of new object\n    const returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\n    if (!bulkInsert) {\n      this.emit(\"insert\", returnObj);\n    }\n\n    this.addAutoUpdateObserver(returnObj);\n\n    return returnObj;\n  }\n\n  /**\n   * Empties the collection of all data but leaves indexes and options intact by default.\n   * @param {object=} options - configure clear behavior\n   * @param {bool=} [options.removeIndices=false] - whether to remove indices in addition to data\n   */\n  clear(options?: { removeIndices?: boolean }): void {\n    const self = this;\n\n    options = options || {};\n\n    this.data = [];\n    this.idIndex = null;\n    this.cachedIndex = null;\n    this.cachedBinaryIndex = null;\n    this.cachedData = null;\n    this.maxId = 0;\n    this.DynamicViews = [];\n    this.dirty = true;\n    this.constraints = {\n      unique: {},\n      exact: {},\n    };\n\n    // if removing indices entirely\n    if (options.removeIndices === true) {\n      this.binaryIndices = {};\n      this.uniqueNames = [];\n    }\n\n    // clear indices but leave definitions in place\n    else {\n      // clear binary indices\n      const keys = Object.keys(this.binaryIndices);\n      keys.forEach((biname) => {\n        self.binaryIndices[biname].dirty = false;\n        self.binaryIndices[biname].values = [];\n      });\n    }\n  }\n\n  /**\n   * Updates an object and notifies collection that the document has changed.\n   * @param {CollectionDocument} doc - document to update within the collection\n   * @returns the document that was updated\n   */\n  update(doc: CollectionDocument | CollectionDocument[]) {\n    let adaptiveBatchOverride;\n    let k;\n    let len;\n\n    if (Array.isArray(doc)) {\n      len = doc.length;\n\n      // if not cloning, disable adaptive binary indices for the duration of the batch update,\n      // followed by lazy rebuild and re-enabling adaptive indices after batch update.\n      adaptiveBatchOverride =\n        !this.cloneObjects &&\n        this.adaptiveBinaryIndices &&\n        Object.keys(this.binaryIndices).length > 0;\n\n      if (adaptiveBatchOverride) {\n        this.adaptiveBinaryIndices = false;\n      }\n\n      try {\n        for (k = 0; k < len; k += 1) {\n          this.update(doc[k]);\n        }\n      } finally {\n        if (adaptiveBatchOverride) {\n          this.ensureAllIndexes();\n          this.adaptiveBinaryIndices = true;\n        }\n      }\n\n      return;\n    }\n\n    // verify object is a properly formed document\n    if (!hasOwnProperty.call(doc, \"$loki\")) {\n      throw new Error(\n        \"Trying to update unsynced document. Please save the document first by using insert() or addMany()\",\n      );\n    }\n    try {\n      this.startTransaction();\n      const arr = this.get(doc.$loki, true);\n\n      let newInternal;\n\n      const self = this;\n\n      if (!arr) {\n        throw new Error(\"Trying to update a document not in collection.\");\n      }\n\n      const oldInternal = arr[0]; // -internal- obj ref\n      const position = arr[1]; // position in data array\n\n      // if configured to clone, do so now... otherwise just use same obj reference\n      newInternal =\n        this.cloneObjects ||\n        (!this.disableDeltaChangesApi && this.disableFreeze)\n          ? clone(doc, this.cloneMethod)\n          : doc;\n\n      this.emit(\"pre-update\", doc);\n\n      this.uniqueNames.forEach((key) => {\n        self.getUniqueIndex(key, true).update(oldInternal, newInternal);\n      });\n\n      // operate the update\n      this.data[position] = newInternal;\n\n      if (newInternal !== doc) {\n        this.addAutoUpdateObserver(doc);\n      }\n\n      // now that we can efficiently determine the data[] position of newly added document,\n      // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n      for (let idx = 0; idx < this.DynamicViews.length; idx++) {\n        this.DynamicViews[idx].evaluateDocument(position, false);\n      }\n\n      let key;\n      if (this.adaptiveBinaryIndices) {\n        // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n        const bIndices = this.binaryIndices;\n        for (key in bIndices) {\n          this.adaptiveBinaryIndexUpdate(position, key);\n        }\n      } else {\n        this.flagBinaryIndexesDirty();\n      }\n\n      this.idIndex[position] = newInternal.$loki;\n      //this.flagBinaryIndexesDirty();\n      if (this.isIncremental) {\n        this.dirtyIds.push(newInternal.$loki);\n      }\n\n      this.commit();\n      this.dirty = true; // for autosave scenarios\n\n      // update meta and store changes if ChangesAPI is enabled\n      if (this.disableChangesApi) {\n        newInternal = this.updateMeta(newInternal);\n      } else {\n        newInternal = this.updateMetaWithChange(newInternal, oldInternal);\n      }\n\n      if (!this.disableFreeze) {\n        deepFreeze(newInternal);\n      }\n\n      let returnObj;\n\n      // if cloning is enabled, emit 'update' event and return with clone of new object\n      if (this.cloneObjects) {\n        returnObj = clone(newInternal, this.cloneMethod);\n      } else {\n        returnObj = newInternal;\n      }\n\n      this.emit(\"update\", returnObj);\n      // this.emit(\"update\", returnObj, oldInternal);\n      return returnObj;\n    } catch (err) {\n      this.rollback();\n      this.lokiConsoleWrapper.error(err.message);\n      this.emit(\"error\", err);\n      throw err; // re-throw error so user does not think it succeeded\n    }\n  }\n\n  /**\n   * Add object to collection\n   */\n  add(obj) {\n    // if parameter isn't object exit with throw\n    if (\"object\" !== typeof obj) {\n      throw new TypeError(\"Object being added needs to be an object\");\n    }\n    // if object you are adding already has id column it is either already in the collection\n    // or the object is carrying its own 'id' property.  If it also has a meta property,\n    // then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n    if (typeof obj.$loki !== \"undefined\") {\n      throw new Error(\"Document is already in collection, please use update()\");\n    }\n\n    /*\n     * try adding object to collection\n     */\n    try {\n      this.startTransaction();\n      this.maxId++;\n\n      if (isNaN(this.maxId)) {\n        this.maxId = this.data[this.data.length - 1].$loki + 1;\n      }\n\n      const newId = this.maxId;\n      obj.$loki = newId;\n\n      if (!this.disableMeta) {\n        obj.meta.version = 0;\n      }\n\n      for (let i = 0, len = this.uniqueNames.length; i < len; i++) {\n        this.getUniqueIndex(this.uniqueNames[i], true).set(obj);\n      }\n\n      if (this.idIndex) {\n        this.idIndex.push(newId);\n      }\n\n      if (this.isIncremental) {\n        this.dirtyIds.push(newId);\n      }\n\n      // add the object\n      this.data.push(obj);\n\n      const addedPos = this.data.length - 1;\n\n      // now that we can efficiently determine the data[] position of newly added document,\n      // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n      const dvlen = this.DynamicViews.length;\n      for (let i = 0; i < dvlen; i++) {\n        this.DynamicViews[i].evaluateDocument(addedPos, true);\n      }\n\n      if (this.adaptiveBinaryIndices) {\n        // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n        const bIndices = this.binaryIndices;\n        for (const key in bIndices) {\n          this.adaptiveBinaryIndexInsert(addedPos, key);\n        }\n      } else {\n        this.flagBinaryIndexesDirty();\n      }\n\n      this.commit();\n      this.dirty = true; // for autosave scenarios\n\n      return this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n    } catch (err) {\n      this.rollback();\n      this.lokiConsoleWrapper.error(err.message);\n      this.emit(\"error\", err);\n      throw err; // re-throw error so user does not think it succeeded\n    }\n  }\n\n  /**\n   * Applies a filter function and passes all results to an update function.\n   *\n   * @param {function} filterFunction - filter function whose results will execute update\n   * @param {function} updateFunction - update function to run against filtered documents\n   \n   */\n  updateWhere(filterFunction, updateFunction) {\n    const results = this.where(filterFunction);\n    let i = 0;\n    let obj;\n    try {\n      for (i; i < results.length; i++) {\n        obj = updateFunction(results[i]);\n        this.update(obj);\n      }\n    } catch (err) {\n      this.rollback();\n      this.lokiConsoleWrapper.error(err.message);\n    }\n  }\n\n  /**\n   * Remove all documents matching supplied filter function.\n   * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n   * @param {function|object} query - query object to filter on\n   \n   */\n  removeWhere(query: ((...args: any[]) => any) | Record<string, any>) {\n    let list: ColT[];\n    if (typeof query === \"function\") {\n      list = this.data.filter(query as (...args: any[]) => any);\n      this.remove(list);\n    } else {\n      (this.chain() as ResultSet<ColT>).find(query).remove();\n    }\n  }\n\n  removeDataOnly(): void {\n    this.remove(this.data.slice());\n  }\n\n  /**\n   * Internal method to remove a batch of documents from the collection.\n   * @param {number[]} positions - data/idIndex positions to remove\n   */\n  removeBatchByPositions(positions: number[]) {\n    const len = positions.length;\n    const xo = {};\n    let dlen;\n    let didx;\n    let idx;\n    const bic = Object.keys(this.binaryIndices).length;\n    const uic = Object.keys(this.constraints.unique).length;\n    const adaptiveOverride =\n      this.adaptiveBinaryIndices && Object.keys(this.binaryIndices).length > 0;\n    let doc;\n    const self = this;\n\n    try {\n      this.startTransaction();\n\n      // create hashobject for positional removal inclusion tests...\n      // all keys defined in this hashobject represent $loki ids of the documents to remove.\n      this.ensureId();\n      for (idx = 0; idx < len; idx++) {\n        xo[this.idIndex[positions[idx]]] = true;\n      }\n\n      // if we will need to notify dynamic views and/or binary indices to update themselves...\n      dlen = this.DynamicViews.length;\n      if (dlen > 0 || bic > 0 || uic > 0) {\n        if (dlen > 0) {\n          // notify dynamic views to remove relevant documents at data positions\n          for (didx = 0; didx < dlen; didx++) {\n            // notify dv of remove (passing batch/array of positions)\n            this.DynamicViews[didx].removeDocument(positions);\n          }\n        }\n\n        // notify binary indices to update\n        if (this.adaptiveBinaryIndices && !adaptiveOverride) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          let key;\n\n          const bIndices = this.binaryIndices;\n\n          for (key in bIndices) {\n            this.adaptiveBinaryIndexRemove(positions, key);\n          }\n        } else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        if (uic) {\n          this.uniqueNames.forEach((key) => {\n            const index = self.getUniqueIndex(key);\n            if (index) {\n              for (idx = 0; idx < len; idx++) {\n                doc = self.data[positions[idx]];\n                if (doc[key] !== null && doc[key] !== undefined) {\n                  index.remove(doc[key]);\n                }\n              }\n            }\n          });\n        }\n      }\n\n      // emit 'delete' events only of listeners are attached.\n      // since data not removed yet, in future we can emit single delete event with array...\n      // for now that might be breaking change to put in potential 1.6 or LokiDB (lokijs2) version\n      if (!this.disableChangesApi || this.events.delete.length > 1) {\n        for (idx = 0; idx < len; idx++) {\n          this.emit(\"delete\", this.data[positions[idx]]);\n        }\n      }\n\n      // remove from data[] :\n      // filter collection data for items not in inclusion hashobject\n      this.data = this.data.filter(({ $loki }) => !xo[$loki]);\n\n      if (this.isIncremental) {\n        for (idx = 0; idx < len; idx++) {\n          this.dirtyIds.push(this.idIndex[positions[idx]]);\n        }\n      }\n\n      // remove from idIndex[] :\n      // filter idIndex for items not in inclusion hashobject\n      this.idIndex = this.idIndex.filter((id) => !xo[id]);\n\n      if (this.adaptiveBinaryIndices && adaptiveOverride) {\n        this.adaptiveBinaryIndices = false;\n        this.ensureAllIndexes(true);\n        this.adaptiveBinaryIndices = true;\n      }\n\n      this.commit();\n\n      // flag collection as dirty for autosave\n      this.dirty = true;\n    } catch (err) {\n      this.rollback();\n      if (adaptiveOverride) {\n        this.adaptiveBinaryIndices = true;\n      }\n      this.lokiConsoleWrapper.error(err.message);\n      this.emit(\"error\", err);\n      return null;\n    }\n  }\n\n  /**\n   *  Internal method called by remove()\n   * @param {object[]|number[]} batch - array of documents or $loki ids to remove\n   */\n  removeBatch(batch: CollectionDocument[] | number[]) {\n    const len = batch.length;\n    const dlen = this.data.length;\n    let idx;\n    const xlt = {};\n    const posx = [];\n\n    // create lookup hashobject to translate $loki id to position\n    for (idx = 0; idx < dlen; idx++) {\n      xlt[this.data[idx].$loki] = idx;\n    }\n\n    // iterate the batch\n    for (idx = 0; idx < len; idx++) {\n      if (typeof batch[idx] === \"object\") {\n        posx.push(xlt[(batch[idx] as CollectionDocument).$loki]);\n      } else {\n        posx.push(xlt[batch[idx] as number]);\n      }\n    }\n\n    this.removeBatchByPositions(posx);\n  }\n\n  /**\n   * Remove a document from the collection\n   * @param {object | array | number} newDoc - document(s) to remove from collection. If number, remove by id\n   \n   * @returns CollectionDocument | null - null if document not found, otherwise removed document. Array of new documents is not returned\n   */\n  remove(\n    docOrId: CollectionDocument | number | CollectionDocument[],\n  ): CollectionDocument {\n    let doc: CollectionDocument;\n    if (typeof docOrId === \"number\") {\n      doc = this.get(docOrId as number);\n    } else {\n      doc = docOrId as CollectionDocument | CollectionDocument[];\n    }\n\n    if (\"object\" !== typeof doc) {\n      throw new Error(\"Parameter is not an object\");\n    }\n    if (Array.isArray(doc)) {\n      this.removeBatch(doc);\n      return;\n    }\n\n    if (!hasOwnProperty.call(doc, \"$loki\")) {\n      throw new Error(\"Object is not a document stored in the collection\");\n    }\n\n    try {\n      this.startTransaction();\n      const arr = this.get(doc.$loki, true);\n\n      const position = arr[1];\n\n      const self = this;\n      this.uniqueNames.forEach((key) => {\n        if (doc[key] !== null && typeof doc[key] !== \"undefined\") {\n          const index = self.getUniqueIndex(key);\n          if (index) {\n            index.remove(doc[key]);\n          }\n        }\n      });\n      // now that we can efficiently determine the data[] position of newly added document,\n      // submit it for all registered DynamicViews to remove\n      for (let idx = 0; idx < this.DynamicViews.length; idx++) {\n        this.DynamicViews[idx].removeDocument(position);\n      }\n\n      if (this.adaptiveBinaryIndices) {\n        // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n        let key;\n\n        const bIndices = this.binaryIndices;\n        for (key in bIndices) {\n          this.adaptiveBinaryIndexRemove(position, key);\n        }\n      } else {\n        this.flagBinaryIndexesDirty();\n      }\n\n      this.data.splice(position, 1);\n      this.removeAutoUpdateObserver(doc);\n\n      // remove id from idIndex\n      this.idIndex.splice(position, 1);\n\n      if (this.isIncremental) {\n        this.dirtyIds.push(doc.$loki);\n      }\n\n      this.commit();\n      this.dirty = true; // for autosave scenarios\n      this.emit(\"delete\", arr[0]);\n\n      if (!this.disableFreeze) {\n        doc = unFreeze(doc);\n      }\n      delete doc.$loki;\n      delete doc.meta;\n      if (!this.disableFreeze) {\n        freeze(doc);\n      }\n      return doc;\n    } catch (err) {\n      this.rollback();\n      this.lokiConsoleWrapper.error(err.message);\n      this.emit(\"error\", err);\n      return null;\n    }\n  }\n\n  /*---------------------+\n  | Finding methods     |\n  +----------------------*/\n  /**\n   * Get by Id - faster than other methods because of the searching algorithm\n   * @param {int} id - $loki id of document you want to retrieve\n   * @param {boolean} returnPosition - if 'true' we will return [object, position]\n   * @returns {(object|array|null)} Object reference if document was found, null if not,\n   *     or an array if 'returnPosition' was passed.\n   \n   */\n  get(id: number, returnPosition?: boolean): object | Array<any> | null {\n    if (!this.idIndex) {\n      this.ensureId();\n    }\n\n    const retpos = returnPosition || false;\n    const data = this.idIndex;\n    let max = data.length - 1;\n    let min = 0;\n    let mid = (min + max) >> 1;\n\n    id = typeof id === \"number\" ? id : parseInt(id, 10);\n\n    if (isNaN(id)) {\n      throw new TypeError(\"Passed id is not an integer\");\n    }\n\n    while (data[min] < data[max]) {\n      mid = (min + max) >> 1;\n\n      if (data[mid] < id) {\n        min = mid + 1;\n      } else {\n        max = mid;\n      }\n    }\n\n    if (max === min && data[min] === id) {\n      if (retpos) {\n        return [this.data[min], min];\n      }\n      return this.data[min];\n    }\n    return null;\n  }\n\n  /**\n   * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n   *    Since multiple documents may contain the same value (which the index is sorted on),\n   *    we hone in on range and then linear scan range to find exact index array position.\n   * @param {int} dataPosition : coll.data array index/position\n   * @param {string} binaryIndexName : index to search for dataPosition in\n   */\n  getBinaryIndexPosition(dataPosition: number, binaryIndexName: string) {\n    const val = Utils.getIn(this.data[dataPosition], binaryIndexName, true);\n    const index = this.binaryIndices[binaryIndexName].values;\n\n    // i think calculateRange can probably be moved to collection\n    // as it doesn't seem to need resultset.  need to verify\n    const range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n    if (range[0] === 0 && range[1] === -1) {\n      // uhoh didn't find range\n      return null;\n    }\n\n    const min = range[0];\n    const max = range[1];\n\n    // narrow down the sub-segment of index values\n    // where the indexed property value exactly matches our\n    // value and then linear scan to find exact -index- position\n    for (let idx = min; idx <= max; idx++) {\n      if (index[idx] === dataPosition) return idx;\n    }\n\n    // uhoh\n    return null;\n  }\n\n  /**\n   * Adaptively insert a selected item to the index.\n   * @param {int} dataPosition : coll.data array index/position\n   * @param {string} binaryIndexName : index to search for dataPosition in\n   */\n  adaptiveBinaryIndexInsert(dataPosition: number, binaryIndexName: string) {\n    const usingDotNotation = binaryIndexName.includes(\".\");\n    const index = this.binaryIndices[binaryIndexName].values;\n    let val = Utils.getIn(\n      this.data[dataPosition],\n      binaryIndexName,\n      usingDotNotation,\n    );\n\n    // If you are inserting a javascript Date value into a binary index, convert to epoch time\n    if (this.serializableIndices === true && val instanceof Date) {\n      // @ts-ignore\n      this.data[dataPosition][binaryIndexName] = val.getTime();\n      val = Utils.getIn(this.data[dataPosition], binaryIndexName);\n    }\n\n    const idxPos =\n      index.length === 0\n        ? 0\n        : this.calculateRangeStart(\n            binaryIndexName,\n            val,\n            true,\n            usingDotNotation,\n          );\n\n    // insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n    // doing this after adjusting dataPositions so no clash with previous item at that position.\n    this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n  }\n\n  /**\n   * Adaptively update a selected item within an index.\n   * @param {int} dataPosition : coll.data array index/position\n   * @param {string} binaryIndexName : index to search for dataPosition in\n   */\n  adaptiveBinaryIndexUpdate(dataPosition: number, binaryIndexName: string) {\n    // linear scan needed to find old position within index unless we optimize for clone scenarios later\n    // within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n    let idxPos;\n\n    const index = this.binaryIndices[binaryIndexName].values;\n    const len = index.length;\n\n    for (idxPos = 0; idxPos < len; idxPos++) {\n      if (index[idxPos] === dataPosition) break;\n    }\n\n    //var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n    this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n    //this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n    this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n  }\n\n  /**\n   * Adaptively remove a selected item from the index.\n   * @param {number|number[]} dataPosition : coll.data array index/position\n   * @param {string} binaryIndexName : index to search for dataPosition in\n   */\n  adaptiveBinaryIndexRemove(\n    dataPosition: number | number[],\n    binaryIndexName: string,\n    removedFromIndexOnly?: boolean,\n  ) {\n    const bi = this.binaryIndices[binaryIndexName];\n    let len;\n    let idx;\n    let rmidx;\n    let rmlen;\n    const rxo = {};\n    let curr;\n    let shift;\n\n    if (Array.isArray(dataPosition)) {\n      // when called from chained remove, and only one document in array,\n      // it will be faster to use old algorithm\n      rmlen = dataPosition.length;\n      if (rmlen === 1) {\n        dataPosition = dataPosition[0];\n      }\n\n      // we were passed an array (batch) of documents so use this 'batch optimized' algorithm\n      else {\n        for (rmidx = 0; rmidx < rmlen; rmidx++) {\n          rxo[dataPosition[rmidx]] = true;\n        }\n\n        // remove document from index (with filter function)\n        bi.values = bi.values.filter((di) => !rxo[di]);\n\n        // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n        // in which case data positions stay the same.\n        if (removedFromIndexOnly === true) {\n          return;\n        }\n\n        const sortedPositions = dataPosition.slice();\n        sortedPositions.sort((a, b) => a - b);\n\n        // to remove holes, we need to 'shift down' the index's data array positions\n        // we need to adjust array positions -1 for each index data positions greater than removed positions\n        len = bi.values.length;\n        for (idx = 0; idx < len; idx++) {\n          curr = bi.values[idx];\n          shift = 0;\n          for (\n            rmidx = 0;\n            rmidx < rmlen && curr > sortedPositions[rmidx];\n            rmidx++\n          ) {\n            shift++;\n          }\n          bi.values[idx] -= shift;\n        }\n\n        // batch processed, bail out\n        return;\n      }\n\n      // not a batch so continue...\n    }\n\n    const idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\n    if (idxPos === null) {\n      // throw new Error('unable to determine binary index position');\n      return null;\n    }\n\n    // remove document from index (with splice)\n    bi.values.splice(idxPos, 1);\n\n    // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n    // in which case data positions stay the same.\n    if (removedFromIndexOnly === true) {\n      return;\n    }\n\n    // since index stores data array positions, if we remove a document\n    // we need to adjust array positions -1 for all document positions greater than removed position\n    len = bi.values.length;\n    for (idx = 0; idx < len; idx++) {\n      if (bi.values[idx] > dataPosition) {\n        bi.values[idx]--;\n      }\n    }\n  }\n\n  /**\n   * Internal method used for index maintenance and indexed searching.\n   * Calculates the beginning of an index range for a given value.\n   * For index maintainance (adaptive:true), we will return a valid index position to insert to.\n   * For querying (adaptive:false/undefined), we will :\n   *    return lower bound/index of range of that value (if found)\n   *    return next lower index position if not found (hole)\n   * If index is empty it is assumed to be handled at higher level, so\n   * this method assumes there is at least 1 document in index.\n   *\n   * @param {string} prop - name of property which has binary index\n   * @param {any} val - value to find within index\n   * @param {bool?} adaptive - if true, we will return insert position\n   */\n  calculateRangeStart(\n    prop: string,\n    val: any,\n    adaptive: boolean | null,\n    usingDotNotation?: boolean,\n  ) {\n    const rcd = this.data;\n    const index = this.binaryIndices[prop].values;\n    let min = 0;\n    let max = index.length - 1;\n    let mid = 0;\n\n    if (index.length === 0) {\n      return -1;\n    }\n\n    // hone in on start position of value\n    while (min < max) {\n      mid = (min + max) >> 1;\n\n      if (\n        Comparators.lt(\n          Utils.getIn(rcd[index[mid]], prop, usingDotNotation),\n          val,\n          false,\n        )\n      ) {\n        min = mid + 1;\n      } else {\n        max = mid;\n      }\n    }\n\n    const lbound = min;\n\n    // found it... return it\n    if (\n      Comparators.aeq(\n        val,\n        Utils.getIn(rcd[index[lbound]], prop, usingDotNotation),\n      )\n    ) {\n      return lbound;\n    }\n\n    // if not in index and our value is less than the found one\n    if (\n      Comparators.lt(\n        val,\n        Utils.getIn(rcd[index[lbound]], prop, usingDotNotation),\n        false,\n      )\n    ) {\n      return adaptive ? lbound : lbound - 1;\n    }\n\n    // not in index and our value is greater than the found one\n    return adaptive ? lbound + 1 : lbound;\n  }\n\n  /**\n   * Internal method used for indexed $between.  Given a prop (index name), and a value\n   * (which may or may not yet exist) this will find the final position of that upper range value.\n   */\n  calculateRangeEnd(prop: string, val: any, usingDotNotation: boolean) {\n    const rcd = this.data;\n    const index = this.binaryIndices[prop].values;\n    let min = 0;\n    let max = index.length - 1;\n    let mid = 0;\n\n    if (index.length === 0) {\n      return -1;\n    }\n\n    // hone in on start position of value\n    while (min < max) {\n      mid = (min + max) >> 1;\n\n      if (\n        Comparators.lt(\n          val,\n          Utils.getIn(rcd[index[mid]], prop, usingDotNotation),\n          false,\n        )\n      ) {\n        max = mid;\n      } else {\n        min = mid + 1;\n      }\n    }\n\n    const ubound = max;\n\n    // only eq if last element in array is our val\n    if (\n      Comparators.aeq(\n        val,\n        Utils.getIn(rcd[index[ubound]], prop, usingDotNotation),\n      )\n    ) {\n      return ubound;\n    }\n\n    // if not in index and our value is less than the found one\n    if (\n      Comparators.gt(\n        val,\n        Utils.getIn(rcd[index[ubound]], prop, usingDotNotation),\n        false,\n      )\n    ) {\n      return ubound + 1;\n    }\n\n    // either hole or first nonmatch\n    if (\n      Comparators.aeq(\n        val,\n        Utils.getIn(rcd[index[ubound - 1]], prop, usingDotNotation),\n      )\n    ) {\n      return ubound - 1;\n    }\n\n    // hole, so ubound if nearest gt than the val we were looking for\n    return ubound;\n  }\n\n  /**\n   * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n   *    this is used for collection.find() and first find filter of resultset/dynview\n   *    slightly different than get() binary search in that get() hones in on 1 value,\n   *    but we have to hone in on many (range)\n   * @param {string} op - operation, such as $eq\n   * @param {string} prop - name of property to calculate range for\n   * @param {object} val - value to use for range calculation.\n   * @returns {array} [start, end] index array positions\n   */\n  calculateRange(\n    op: string,\n    prop: string,\n    val: any,\n  ): [start: number, end: number] {\n    const rcd = this.data;\n    const index = this.binaryIndices[prop].values;\n    const min = 0;\n    const max = index.length - 1;\n    let lbound;\n    let lval;\n    let ubound;\n    let uval;\n\n    // when no documents are in collection, return empty range condition\n    if (rcd.length === 0) {\n      return [0, -1];\n    }\n\n    const usingDotNotation = prop.includes(\".\");\n\n    const minVal = Utils.getIn(rcd[index[min]], prop, usingDotNotation);\n    const maxVal = Utils.getIn(rcd[index[max]], prop, usingDotNotation);\n\n    // if value falls outside of our range return [0, -1] to designate no results\n    switch (op) {\n      case \"$eq\":\n      case \"$aeq\":\n        if (\n          Comparators.lt(val, minVal, false) ||\n          Comparators.gt(val, maxVal, false)\n        ) {\n          return [0, -1];\n        }\n        break;\n      case \"$dteq\":\n        if (\n          Comparators.lt(val, minVal, false) ||\n          Comparators.gt(val, maxVal, false)\n        ) {\n          return [0, -1];\n        }\n        break;\n      case \"$gt\":\n        // none are within range\n        if (Comparators.gt(val, maxVal, true)) {\n          return [0, -1];\n        }\n        // all are within range\n        if (Comparators.gt(minVal, val, false)) {\n          return [min, max];\n        }\n        break;\n      case \"$gte\":\n        // none are within range\n        if (Comparators.gt(val, maxVal, false)) {\n          return [0, -1];\n        }\n        // all are within range\n        if (Comparators.gt(minVal, val, true)) {\n          return [min, max];\n        }\n        break;\n      case \"$lt\":\n        // none are within range\n        if (Comparators.lt(val, minVal, true)) {\n          return [0, -1];\n        }\n        // all are within range\n        if (Comparators.lt(maxVal, val, false)) {\n          return [min, max];\n        }\n        break;\n      case \"$lte\":\n        // none are within range\n        if (Comparators.lt(val, minVal, false)) {\n          return [0, -1];\n        }\n        // all are within range\n        if (Comparators.lt(maxVal, val, true)) {\n          return [min, max];\n        }\n        break;\n      case \"$between\":\n        // none are within range (low range is greater)\n        if (Comparators.gt(val[0], maxVal, false)) {\n          return [0, -1];\n        }\n        // none are within range (high range lower)\n        if (Comparators.lt(val[1], minVal, false)) {\n          return [0, -1];\n        }\n\n        lbound = this.calculateRangeStart(\n          prop,\n          val[0],\n          false,\n          usingDotNotation,\n        );\n        ubound = this.calculateRangeEnd(prop, val[1], usingDotNotation);\n\n        if (lbound < 0) lbound++;\n        if (ubound > max) ubound--;\n\n        if (\n          !Comparators.gt(\n            Utils.getIn(rcd[index[lbound]], prop, usingDotNotation),\n            val[0],\n            true,\n          )\n        )\n          lbound++;\n        if (\n          !Comparators.lt(\n            Utils.getIn(rcd[index[ubound]], prop, usingDotNotation),\n            val[1],\n            true,\n          )\n        )\n          ubound--;\n\n        if (ubound < lbound) return [0, -1];\n\n        return [lbound, ubound];\n      case \"$in\": {\n        const idxset = [];\n        const segResult = [];\n        // query each value '$eq' operator and merge the seqment results.\n        for (let j = 0, len = val.length; j < len; j++) {\n          const seg = this.calculateRange(\"$eq\", prop, val[j]);\n\n          for (let i = seg[0]; i <= seg[1]; i++) {\n            if (idxset[i] === undefined) {\n              idxset[i] = true;\n              segResult.push(i);\n            }\n          }\n        }\n        return segResult as [start: number, end: number];\n      }\n    }\n\n    // determine lbound where needed\n    switch (op) {\n      case \"$eq\":\n      case \"$aeq\":\n      case \"$dteq\":\n      case \"$gte\":\n      case \"$lt\":\n        lbound = this.calculateRangeStart(prop, val, false, usingDotNotation);\n        lval = Utils.getIn(rcd[index[lbound]], prop, usingDotNotation);\n        break;\n      default:\n        break;\n    }\n\n    // determine ubound where needed\n    switch (op) {\n      case \"$eq\":\n      case \"$aeq\":\n      case \"$dteq\":\n      case \"$lte\":\n      case \"$gt\":\n        ubound = this.calculateRangeEnd(prop, val, usingDotNotation);\n        uval = Utils.getIn(rcd[index[ubound]], prop, usingDotNotation);\n        break;\n      default:\n        break;\n    }\n\n    switch (op) {\n      case \"$eq\":\n      case \"$aeq\":\n      case \"$dteq\":\n        // if hole (not found)\n        if (!Comparators.aeq(lval, val)) {\n          return [0, -1];\n        }\n\n        return [lbound, ubound];\n\n      case \"$gt\":\n        // if hole (not found) ub position is already greater\n        if (\n          !Comparators.aeq(\n            Utils.getIn(rcd[index[ubound]], prop, usingDotNotation),\n            val,\n          )\n        ) {\n          return [ubound, max];\n        }\n        // otherwise (found) so ubound is still equal, get next\n        return [ubound + 1, max];\n\n      case \"$gte\":\n        // if hole (not found) lb position marks left outside of range\n        if (\n          !Comparators.aeq(\n            Utils.getIn(rcd[index[lbound]], prop, usingDotNotation),\n            val,\n          )\n        ) {\n          return [lbound + 1, max];\n        }\n        // otherwise (found) so lb is first position where its equal\n        return [lbound, max];\n\n      case \"$lt\":\n        // if hole (not found) position already is less than\n        if (\n          !Comparators.aeq(\n            Utils.getIn(rcd[index[lbound]], prop, usingDotNotation),\n            val,\n          )\n        ) {\n          return [min, lbound];\n        }\n        // otherwise (found) so lb marks left inside of eq range, get previous\n        return [min, lbound - 1];\n\n      case \"$lte\":\n        // if hole (not found) ub position marks right outside so get previous\n        if (\n          !Comparators.aeq(\n            Utils.getIn(rcd[index[ubound]], prop, usingDotNotation),\n            val,\n          )\n        ) {\n          return [min, ubound - 1];\n        }\n        // otherwise (found) so ub is last position where its still equal\n        return [min, ubound];\n\n      default:\n        return [0, rcd.length - 1];\n    }\n  }\n\n  /**\n   * Retrieve doc by Unique index\n   * @param {string} field - name of uniquely indexed property to use when doing lookup\n   * @param {value} value - unique value to search for\n   * @returns {object} document matching the value passed\n   \n   */\n  by(field: string, value?: string) {\n    let self;\n    if (value === undefined) {\n      self = this;\n      return (value) => self.by(field, value);\n    }\n\n    const result = this.getUniqueIndex(field, true).get(value);\n    if (!this.cloneObjects) {\n      return result;\n    } else {\n      return clone(result, this.cloneMethod);\n    }\n  }\n\n  /**\n   * Find one object by index property, by property equal to value\n   * @param {object} query - query object used to perform search with\n   * @returns {(object|null)} First matching document, or null if none\n   \n   */\n  findOne(query = {}) {\n    // Instantiate Resultset and exec find op passing firstOnly = true param\n    const result = (this.chain() as ResultSet<ColT>).find(query, true).data();\n\n    if (Array.isArray(result) && result.length === 0) {\n      return null;\n    } else {\n      if (!this.cloneObjects) {\n        return result[0];\n      } else {\n        return clone(result[0], this.cloneMethod);\n      }\n    }\n  }\n\n  /**\n   * Chain method, used for beginning a series of chained find() and/or view() operations\n   * on a collection.\n   *\n   * @param {string|array=} transform - named transform or array of transform steps\n   * @param {object=} parameters - Object containing properties representing parameters to substitute\n   * @returns {ResultSet} (this) resultset, or data array if any map or join functions where called\n   \n   */\n  chain(\n    transform?: ChainTransform,\n    parameters?: any | any[],\n  ): ResultSet<ColT> | any {\n    const rs = new ResultSet<ColT>(this);\n\n    if (typeof transform === \"undefined\") {\n      return rs;\n    }\n\n    return rs.transform(transform, parameters);\n  }\n\n  /**\n   * Find method, api is similar to mongodb.\n   * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n   * @example {@tutorial Query Examples}\n   * @param {object} query - 'mongo-like' query object\n   * @returns {array} Array of matching documents\n   \n   */\n  find(query?: Record<string, any>) {\n    return (this.chain() as ResultSet<ColT>).find(query).data();\n  }\n\n  /**\n   * Find object by unindexed field by property equal to value,\n   * simply iterates and returns the first element matching the query\n   */\n  findOneUnindexed(prop, value) {\n    let i = this.data.length;\n    let doc;\n    while (i--) {\n      if (Utils.getIn(this.data[i], prop, true) === value) {\n        doc = this.data[i];\n        return doc;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Transaction methods\n   */\n  /** start the transation */\n  startTransaction = () => {\n    if (this.transactional) {\n      this.cachedData = clone(this.data, this.cloneMethod);\n      this.cachedIndex = this.idIndex;\n      this.cachedBinaryIndex = this.binaryIndices;\n      this.cachedDirtyIds = this.dirtyIds;\n\n      // propagate startTransaction to dynamic views\n      for (let idx = 0; idx < this.DynamicViews.length; idx++) {\n        this.DynamicViews[idx].startTransaction();\n      }\n    }\n  };\n\n  /** commit the transation */\n  commit = () => {\n    if (this.transactional) {\n      this.cachedData = null;\n      this.cachedIndex = null;\n      this.cachedBinaryIndex = null;\n      this.cachedDirtyIds = null;\n\n      // propagate commit to dynamic views\n      for (let idx = 0; idx < this.DynamicViews.length; idx++) {\n        this.DynamicViews[idx].commit();\n      }\n    }\n  };\n\n  /** roll back the transation */\n  rollback = () => {\n    if (this.transactional) {\n      if (this.cachedData !== null && this.cachedIndex !== null) {\n        this.data = this.cachedData;\n        this.idIndex = this.cachedIndex;\n        this.binaryIndices = this.cachedBinaryIndex;\n        this.dirtyIds = this.cachedDirtyIds;\n      }\n\n      // propagate rollback to dynamic views\n      for (let idx = 0; idx < this.DynamicViews.length; idx++) {\n        this.DynamicViews[idx].rollback();\n      }\n    }\n  };\n\n  // async executor. This is only to enable callbacks at the end of the execution.\n  async(fun: () => void, callback: () => void) {\n    setTimeout(() => {\n      if (typeof fun === \"function\") {\n        fun();\n        callback();\n      } else {\n        throw new TypeError(\n          \"Argument passed for async execution is not a function\",\n        );\n      }\n    }, 0);\n  }\n\n  /**\n   * Query the collection by supplying a javascript filter function.\n   * @example\n   * var results = coll.where(function(obj) {\n   *   return obj.legs === 8;\n   * });\n   *\n   * @param {function} fun - filter function to run against all collection docs\n   * @returns {array} all documents which pass your filter function\n   \n   */\n  where(fun) {\n    return (this.chain() as ResultSet<ColT>).where(fun).data();\n  }\n\n  /**\n   * Map Reduce operation\n   *\n   * @param {function} mapFunction - function to use as map function\n   * @param {function} reduceFunction - function to use as reduce function\n   * @returns {data} The result of your mapReduce operation\n   \n   */\n  mapReduce = (mapFunction, reduceFunction) => {\n    return reduceFunction(this.data.map(mapFunction));\n  };\n\n  /**\n   * Join two collections on specified properties\n   *\n   * @param {array|ResultSet|Collection} joinData - array of documents to 'join' to this collection\n   * @param {string} leftJoinProp - property name in collection\n   * @param {string} rightJoinProp - property name in joinData\n   * @param {function=} mapFun - (Optional) map function to use\n   * @param {object=} dataOptions - options to data() before input to your map function\n   * @param {bool} dataOptions.removeMeta - allows removing meta before calling mapFun\n   * @param {boolean} dataOptions.forceClones - forcing the return of cloned objects to your map object\n   * @param {string} dataOptions.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n   * @returns {ResultSet} Result of the mapping operation\n   \n   */\n  eqJoin(\n    joinData: ColT[] | ResultSet<ColT> | Collection<ColT>,\n    leftJoinProp: string,\n    rightJoinProp: string,\n    mapFun: () => void,\n    dataOptions: {\n      removeMeta: boolean;\n      forceClones: boolean;\n      forceCloneMethod: CloneMethods;\n    },\n  ) {\n    // logic in Resultset class\n    return new ResultSet(this).eqJoin(\n      joinData,\n      leftJoinProp,\n      rightJoinProp,\n      mapFun,\n      dataOptions,\n    );\n  }\n\n  /* ------ STAGING API -------- */\n\n  /**\n   * (Staging API) create a stage and/or retrieve it\n   \n   */\n  getStage(name: string): CollectionDocument {\n    if (!this.stages[name]) {\n      this.stages[name] = {};\n    }\n    return this.stages[name];\n  }\n\n  /**\n   * (Staging API) create a copy of an object and insert it into a stage\n   \n   */\n  stage(stageName: string, obj: CollectionDocument) {\n    const copy = JSON.parse(JSON.stringify(obj));\n    this.getStage(stageName)[obj.$loki] = copy;\n    return copy;\n  }\n\n  /**\n   * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n   * then create a message to be inserted in the commitlog\n   * @param {string} stageName - name of stage\n   * @param {string} message\n   \n   */\n  commitStage(stageName: string, message: string) {\n    const stage = this.getStage(stageName);\n    let prop;\n    const timestamp = new Date().getTime();\n\n    for (prop in stage) {\n      this.update(stage[prop]);\n      this.commitLog.push({\n        timestamp,\n        message,\n        data: JSON.parse(JSON.stringify(stage[prop])),\n      });\n    }\n    this.stages[stageName] = {};\n  }\n\n  /**\n   \n   */\n  extract(field) {\n    let i = 0;\n    const len = this.data.length;\n    const isDotNotation = isDeepProperty(field);\n    const result = [];\n    for (i; i < len; i += 1) {\n      result.push(deepProperty(this.data[i], field, isDotNotation));\n    }\n    return result;\n  }\n\n  /**\n   \n   */\n  max(field) {\n    return Math.max.apply(null, this.extract(field));\n  }\n\n  /**\n   \n   */\n  min(field) {\n    return Math.min.apply(null, this.extract(field));\n  }\n\n  /**\n   \n   */\n  maxRecord(field) {\n    let i = 0;\n    const len = this.data.length;\n    const deep = isDeepProperty(field);\n\n    const result = {\n      index: 0,\n      value: undefined,\n    };\n\n    let max;\n\n    for (i; i < len; i += 1) {\n      if (max !== undefined) {\n        if (max < deepProperty(this.data[i], field, deep)) {\n          max = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      } else {\n        max = deepProperty(this.data[i], field, deep);\n        result.index = this.data[i].$loki;\n      }\n    }\n    result.value = max;\n    return result;\n  }\n\n  /**\n   \n   */\n  minRecord(field) {\n    let i = 0;\n    const len = this.data.length;\n    const deep = isDeepProperty(field);\n\n    const result = {\n      index: 0,\n      value: undefined,\n    };\n\n    let min;\n\n    for (i; i < len; i += 1) {\n      if (min !== undefined) {\n        if (min > deepProperty(this.data[i], field, deep)) {\n          min = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      } else {\n        min = deepProperty(this.data[i], field, deep);\n        result.index = this.data[i].$loki;\n      }\n    }\n    result.value = min;\n    return result;\n  }\n\n  /**\n   \n   */\n  extractNumerical(field) {\n    return this.extract(field)\n      .map(parseBase10)\n      .filter(Number)\n      .filter((n) => !isNaN(n));\n  }\n\n  /**\n   * Calculates the average numerical value of a property\n   *\n   * @param {string} field - name of property in docs to average\n   * @returns {number} average of property in all docs in the collection\n   \n   */\n  avg(field) {\n    return average(this.extractNumerical(field));\n  }\n\n  /**\n   * Calculate standard deviation of a field\n   \n   * @param {string} field\n   */\n  stdDev(field) {\n    return standardDeviation(this.extractNumerical(field));\n  }\n\n  /**\n   \n   * @param {string} field\n   */\n  mode(field) {\n    const dict = {};\n    const data = this.extract(field);\n    data.forEach((obj) => {\n      if (dict[obj]) {\n        dict[obj] += 1;\n      } else {\n        dict[obj] = 1;\n      }\n    });\n    let max;\n    let prop;\n    let mode;\n    for (prop in dict) {\n      if (max) {\n        if (max < dict[prop]) {\n          mode = prop;\n        }\n      } else {\n        mode = prop;\n        max = dict[prop];\n      }\n    }\n    return mode;\n  }\n\n  /**\n   \n   * @param {string} field - property name\n   */\n  median(field) {\n    const values = this.extractNumerical(field);\n    values.sort(sub);\n\n    const half = Math.floor(values.length / 2);\n\n    if (values.length % 2) {\n      return values[half];\n    } else {\n      return (values[half - 1] + values[half]) / 2.0;\n    }\n  }\n\n  lokiConsoleWrapper = {\n    log(message: string) {},\n    warn(message: string) {},\n    error(message: string) {},\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\n\nexport function binarySearch(array, item, fun) {\n  var lo = 0,\n    hi = array.length,\n    compared,\n    mid;\n  while (lo < hi) {\n    mid = (lo + hi) >> 1;\n    compared = fun.apply(null, [item, array[mid]]);\n    if (compared === 0) {\n      return {\n        found: true,\n        index: mid,\n      };\n    } else if (compared < 0) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return {\n    found: false,\n    index: hi,\n  };\n}\n\nexport function BSonSort(fun) {\n  return function (array, item) {\n    return binarySearch(array, item, fun);\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\nimport { BSonSort, binarySearch } from \"../utils/binary-search\";\n\nexport function KeyValueStore() {}\n\nKeyValueStore.prototype = {\n  keys: [],\n  values: [],\n  sort(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n  },\n  setSort(fun) {\n    this.bs = BSonSort(fun);\n  },\n  bs() {\n    return BSonSort(this.sort);\n  },\n  set(key, value) {\n    const pos = this.bs(this.keys, key);\n    if (pos.found) {\n      this.values[pos.index] = value;\n    } else {\n      this.keys.splice(pos.index, 0, key);\n      this.values.splice(pos.index, 0, value);\n    }\n  },\n  get(key) {\n    return this.values[binarySearch(this.keys, key, this.sort).index];\n  },\n};\n", "/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\n\nexport function localStorageAvailable() {\n  try {\n    return (\n      window &&\n      window.localStorage !== undefined &&\n      window.localStorage !== null\n    );\n  } catch (e) {\n    return false;\n  }\n}\n", "/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\nimport { localStorageAvailable } from \"../utils/localStorageAvailable\";\nimport Sylvie from \"../modules/sylvie\";\nimport { NormalSyncPersistenceAdapter } from \"./persistence-adapter\";\n\n/**\n * A loki persistence adapter which persists to web browser's local storage object\n * @constructor LokiLocalStorageAdapter\n */\n\nexport class LocalStorageAdapter implements NormalSyncPersistenceAdapter {\n  mode: \"normal\";\n  /**\n   * loadDatabase() - Load data from localstorage\n   * @param {string} dbname - the name of the database to load\n   * @param {function} callback - the callback to handle the result\n   * @memberof LokiLocalStorageAdapter\n   */\n  loadDatabase(dbname, callback) {\n    if (localStorageAvailable()) {\n      callback(localStorage.getItem(dbname));\n    } else {\n      callback(new Error(\"localStorage is not available\"));\n    }\n  }\n\n  /**\n   * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n   * might want to expand this to avoid dataloss on partial save\n   * @param {string} dbname - the filename of the database to load\n   * @param {function} callback - the callback to handle the result\n   * @memberof LokiLocalStorageAdapter\n   */\n  saveDatabase(dbname, dbstring, callback) {\n    if (localStorageAvailable()) {\n      localStorage.setItem(dbname, dbstring);\n      callback(null);\n    } else {\n      callback(new Error(\"localStorage is not available\"));\n    }\n  }\n\n  /**\n   * deleteDatabase() - delete the database from localstorage, will throw an error if it\n   * can't be deleted\n   * @param {string} dbname - the filename of the database to delete\n   * @param {function} callback - the callback to handle the result\n   * @memberof LokiLocalStorageAdapter\n   */\n  deleteDatabase(dbname, callback) {\n    if (localStorageAvailable()) {\n      localStorage.removeItem(dbname);\n      callback(null);\n    } else {\n      callback(new Error(\"localStorage is not available\"));\n    }\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n/*------------------+\n  | PERSISTENCE       |\n  -------------------*/\n/** there are two build in persistence adapters for internal use\n * fs             for use in Nodejs type environments\n * localStorage   for use in browser environment\n * defined as helper classes here so its easy and clean to use\n */\n/**\n * In in-memory persistence adapter for an in-memory database.\n * This simple 'key/value' adapter is intended for unit testing and diagnostics.\n *\n * @param {object=} options - memory adapter options\n * @param {boolean} [options.asyncResponses=false] - whether callbacks are invoked asynchronously\n * @param {int} [options.asyncTimeout=50] - timeout in ms to queue callbacks\n * @constructor LokiMemoryAdapter\n */\n\nimport Sylvie from \"../modules/sylvie\";\nimport { NormalSyncPersistenceAdapter } from \"./persistence-adapter\";\n\ninterface MemoryAdapterOptions {\n  asyncResponses: boolean;\n  asyncTimeout: number;\n}\n\nexport class MemoryAdapter implements NormalSyncPersistenceAdapter {\n  mode: \"normal\";\n  hashStore: Record<string, any>;\n  options: Partial<MemoryAdapterOptions>;\n  constructor(options?: Partial<MemoryAdapterOptions>) {\n    this.hashStore = {};\n    this.options = options || {};\n\n    if (!this.options.hasOwnProperty(\"asyncResponses\")) {\n      this.options.asyncResponses = false;\n    }\n\n    if (!this.options.hasOwnProperty(\"asyncTimeout\")) {\n      this.options.asyncTimeout = 50; // 50 ms default\n    }\n  }\n\n  /**\n   * Loads a serialized database from its in-memory store.\n   * (Loki persistence adapter interface function)\n   *\n   * @param {string} dbname - name of the database (filename/keyname)\n   * @param {function} callback - adapter callback to return load result to caller\n   * @memberof LokiMemoryAdapter\n   */\n  loadDatabase(dbname, callback) {\n    const self = this;\n\n    if (this.options.asyncResponses) {\n      setTimeout(() => {\n        if (self.hashStore.hasOwnProperty(dbname)) {\n          callback(self.hashStore[dbname].value);\n        } else {\n          // database doesn't exist, return falsy\n          callback(null);\n        }\n      }, this.options.asyncTimeout);\n    } else {\n      if (this.hashStore.hasOwnProperty(dbname)) {\n        // database doesn't exist, return falsy\n        callback(this.hashStore[dbname].value);\n      } else {\n        callback(null);\n      }\n    }\n  }\n\n  /**\n   * Saves a serialized database to its in-memory store.\n   * (Loki persistence adapter interface function)\n   *\n   * @param {string} dbname - name of the database (filename/keyname)\n   * @param {function} callback - adapter callback to return load result to caller\n   * @memberof LokiMemoryAdapter\n   */\n  saveDatabase(dbname, dbstring, callback) {\n    const self = this;\n    let saveCount;\n\n    if (this.options.asyncResponses) {\n      setTimeout(() => {\n        saveCount = self.hashStore.hasOwnProperty(dbname)\n          ? self.hashStore[dbname].savecount\n          : 0;\n\n        self.hashStore[dbname] = {\n          savecount: saveCount + 1,\n          lastsave: new Date(),\n          value: dbstring,\n        };\n\n        callback();\n      }, this.options.asyncTimeout);\n    } else {\n      saveCount = this.hashStore.hasOwnProperty(dbname)\n        ? this.hashStore[dbname].savecount\n        : 0;\n\n      this.hashStore[dbname] = {\n        savecount: saveCount + 1,\n        lastsave: new Date(),\n        value: dbstring,\n      };\n\n      callback();\n    }\n  }\n\n  /**\n   * Deletes a database from its in-memory store.\n   *\n   * @param {string} dbname - name of the database (filename/keyname)\n   * @param {function} callback - function to call when done\n   * @memberof LokiMemoryAdapter\n   */\n  deleteDatabase(dbname, callback) {\n    if (this.hashStore.hasOwnProperty(dbname)) {\n      delete this.hashStore[dbname];\n    }\n\n    if (typeof callback === \"function\") {\n      callback();\n    }\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\n\nimport Sylvie from \"../modules/sylvie\";\n\nexport interface PartitioningAdapterOptions {\n  paging: boolean;\n  pageSize: number;\n  delimiter: string;\n}\n/**\n * An adapter for adapters.  Converts a non reference mode adapter into a reference mode adapter\n * which can perform destructuring and partioning.  Each collection will be stored in its own key/save and\n * only dirty collections will be saved.  If you  turn on paging with default page size of 25megs and save\n * a 75 meg collection it should use up roughly 3 save slots (key/value pairs sent to inner adapter).\n * A dirty collection that spans three pages will save all three pages again\n * Paging mode was added mainly because Chrome has issues saving 'too large' of a string within a\n * single indexeddb row.  If a single document update causes the collection to be flagged as dirty, all\n * of that collection's pages will be written on next save.\n *\n * @param {object} adapter - reference to a 'non-reference' mode loki adapter instance.\n * @param {object=} options - configuration options for partitioning and paging\n * @param {bool} options.paging - (default: false) set to true to enable paging collection data.\n * @param {int} options.pageSize - (default : 25MB) you can use this to limit size of strings passed to inner adapter.\n * @param {string} options.delimiter - allows you to override the default delimeter\n * @constructor LokiPartitioningAdapter\n */\nexport function PartitioningAdapter(\n  adapter,\n  options?: Partial<PartitioningAdapterOptions>,\n) {\n  this.mode = \"reference\";\n  this.adapter = null;\n  this.options = options || {};\n  this.dbref = null;\n  this.dbname = \"\";\n  this.pageIterator = {};\n\n  // verify user passed an appropriate adapter\n  if (adapter) {\n    if (adapter.mode === \"reference\") {\n      throw new Error(\n        \"LokiPartitioningAdapter cannot be instantiated with a reference mode adapter\",\n      );\n    } else {\n      this.adapter = adapter;\n    }\n  } else {\n    throw new Error(\n      \"LokiPartitioningAdapter requires a (non-reference mode) adapter on construction\",\n    );\n  }\n\n  // set collection paging defaults\n  if (!this.options.hasOwnProperty(\"paging\")) {\n    this.options.paging = false;\n  }\n\n  // default to page size of 25 megs (can be up to your largest serialized object size larger than this)\n  if (!this.options.hasOwnProperty(\"pageSize\")) {\n    this.options.pageSize = 25 * 1024 * 1024;\n  }\n\n  if (!this.options.hasOwnProperty(\"delimiter\")) {\n    this.options.delimiter = \"$<\\n\";\n  }\n}\n\n/**\n * Loads a database which was partitioned into several key/value saves.\n * (Loki persistence adapter interface function)\n *\n * @param {string} dbname - name of the database (filename/keyname)\n * @param {function} callback - adapter callback to return load result to caller\n * @memberof LokiPartitioningAdapter\n */\nPartitioningAdapter.prototype.loadDatabase = function (dbname, callback) {\n  var self = this;\n  this.dbname = dbname;\n  this.dbref = new Sylvie(dbname);\n\n  // load the db container (without data)\n  this.adapter.loadDatabase(dbname, function (result) {\n    // empty database condition is for inner adapter return null/undefined/falsy\n    if (!result) {\n      // partition 0 not found so new database, no need to try to load other partitions.\n      // return same falsy result to loadDatabase to signify no database exists (yet)\n      callback(result);\n      return;\n    }\n\n    if (typeof result !== \"string\") {\n      callback(\n        new Error(\n          \"LokiPartitioningAdapter received an unexpected response from inner adapter loadDatabase()\",\n        ),\n      );\n    }\n\n    // I will want to use loki destructuring helper methods so i will inflate into typed instance\n    var db = JSON.parse(result);\n    self.dbref.loadJSONObject(db);\n    db = null;\n\n    if (self.dbref.collections.length === 0) {\n      callback(self.dbref);\n      return;\n    }\n\n    self.pageIterator = {\n      collection: 0,\n      pageIndex: 0,\n    };\n\n    self.loadNextPartition(0, function () {\n      callback(self.dbref);\n    });\n  });\n};\n\n/**\n * Used to sequentially load each collection partition, one at a time.\n *\n * @param {int} partition - ordinal collection position to load next\n * @param {function} callback - adapter callback to return load result to caller\n */\nPartitioningAdapter.prototype.loadNextPartition = function (\n  partition,\n  callback,\n) {\n  var keyname = this.dbname + \".\" + partition;\n  var self = this;\n\n  if (this.options.paging === true) {\n    this.pageIterator.pageIndex = 0;\n    this.loadNextPage(callback);\n    return;\n  }\n\n  this.adapter.loadDatabase(keyname, function (result) {\n    var data = self.dbref.deserializeCollection(result, {\n      delimited: true,\n      collectionIndex: partition,\n    });\n    self.dbref.collections[partition].data = data;\n\n    if (++partition < self.dbref.collections.length) {\n      self.loadNextPartition(partition, callback);\n    } else {\n      callback();\n    }\n  });\n};\n\n/**\n * Used to sequentially load the next page of collection partition, one at a time.\n *\n * @param {function} callback - adapter callback to return load result to caller\n */\nPartitioningAdapter.prototype.loadNextPage = function (callback) {\n  // calculate name for next saved page in sequence\n  var keyname =\n    this.dbname +\n    \".\" +\n    this.pageIterator.collection +\n    \".\" +\n    this.pageIterator.pageIndex;\n  var self = this;\n\n  // load whatever page is next in sequence\n  this.adapter.loadDatabase(keyname, function (result) {\n    var data = result.split(self.options.delimiter);\n    result = \"\"; // free up memory now that we have split it into array\n    var dlen = data.length;\n    var idx;\n\n    // detect if last page by presence of final empty string element and remove it if so\n    var isLastPage = data[dlen - 1] === \"\";\n    if (isLastPage) {\n      data.pop();\n      dlen = data.length;\n      // empty collections are just a delimiter meaning two blank items\n      if (data[dlen - 1] === \"\" && dlen === 1) {\n        data.pop();\n        dlen = data.length;\n      }\n    }\n\n    // convert stringified array elements to object instances and push to collection data\n    for (idx = 0; idx < dlen; idx++) {\n      self.dbref.collections[self.pageIterator.collection].data.push(\n        JSON.parse(data[idx]),\n      );\n      data[idx] = null;\n    }\n    data = [];\n\n    // if last page, we are done with this partition\n    if (isLastPage) {\n      // if there are more partitions, kick off next partition load\n      if (++self.pageIterator.collection < self.dbref.collections.length) {\n        self.loadNextPartition(self.pageIterator.collection, callback);\n      } else {\n        callback();\n      }\n    } else {\n      self.pageIterator.pageIndex++;\n      self.loadNextPage(callback);\n    }\n  });\n};\n\n/**\n * Saves a database by partioning into separate key/value saves.\n * (Loki 'reference mode' persistence adapter interface function)\n *\n * @param {string} dbname - name of the database (filename/keyname)\n * @param {object} dbref - reference to database which we will partition and save.\n * @param {function} callback - adapter callback to return load result to caller\n *\n * @memberof LokiPartitioningAdapter\n */\nPartitioningAdapter.prototype.exportDatabase = function (\n  dbname,\n  dbref,\n  callback,\n) {\n  var idx,\n    clen = dbref.collections.length;\n\n  this.dbref = dbref;\n  this.dbname = dbname;\n\n  // queue up dirty partitions to be saved\n  this.dirtyPartitions = [-1];\n  for (idx = 0; idx < clen; idx++) {\n    if (dbref.collections[idx].dirty) {\n      this.dirtyPartitions.push(idx);\n    }\n  }\n\n  this.saveNextPartition(function (err) {\n    callback(err);\n  });\n};\n\n/**\n * Helper method used internally to save each dirty collection, one at a time.\n *\n * @param {function} callback - adapter callback to return load result to caller\n */\nPartitioningAdapter.prototype.saveNextPartition = function (callback) {\n  var self = this;\n  var partition = this.dirtyPartitions.shift();\n  var keyname = this.dbname + (partition === -1 ? \"\" : \".\" + partition);\n\n  // if we are doing paging and this is collection partition\n  if (this.options.paging && partition !== -1) {\n    this.pageIterator = {\n      collection: partition,\n      docIndex: 0,\n      pageIndex: 0,\n    };\n\n    // since saveNextPage recursively calls itself until done, our callback means this whole paged partition is finished\n    this.saveNextPage(function (err) {\n      if (self.dirtyPartitions.length === 0) {\n        callback(err);\n      } else {\n        self.saveNextPartition(callback);\n      }\n    });\n    return;\n  }\n\n  // otherwise this is 'non-paged' partioning...\n  var result = this.dbref.serializeDestructured({\n    partitioned: true,\n    delimited: true,\n    partition: partition,\n  });\n\n  this.adapter.saveDatabase(keyname, result, function (err) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    if (self.dirtyPartitions.length === 0) {\n      callback(null);\n    } else {\n      self.saveNextPartition(callback);\n    }\n  });\n};\n\n/**\n * Helper method used internally to generate and save the next page of the current (dirty) partition.\n *\n * @param {function} callback - adapter callback to return load result to caller\n */\nPartitioningAdapter.prototype.saveNextPage = function (\n  callback: (err?: Error) => void,\n): void {\n  var self = this;\n  var coll = this.dbref.collections[this.pageIterator.collection];\n  var keyname =\n    this.dbname +\n    \".\" +\n    this.pageIterator.collection +\n    \".\" +\n    this.pageIterator.pageIndex;\n  var pageLen = 0,\n    cdlen = coll.data.length,\n    delimlen = this.options.delimiter.length;\n  var serializedObject = \"\",\n    pageBuilder = \"\";\n  var doneWithPartition = false,\n    doneWithPage = false;\n\n  var pageSaveCallback = function (err) {\n    pageBuilder = \"\";\n\n    if (err) {\n      callback(err);\n    }\n\n    // update meta properties then continue process by invoking callback\n    if (doneWithPartition) {\n      callback(null);\n    } else {\n      self.pageIterator.pageIndex++;\n      self.saveNextPage(callback);\n    }\n  };\n\n  if (coll.data.length === 0) {\n    doneWithPartition = true;\n  }\n\n  let completed = false;\n  while (!completed) {\n    if (!doneWithPartition) {\n      // serialize object\n      serializedObject = JSON.stringify(coll.data[this.pageIterator.docIndex]);\n      pageBuilder += serializedObject;\n      pageLen += serializedObject.length;\n\n      // if no more documents in collection to add, we are done with partition\n      if (++this.pageIterator.docIndex >= cdlen) doneWithPartition = true;\n    }\n    // if our current page is bigger than defined pageSize, we are done with page\n    if (pageLen >= this.options.pageSize) doneWithPage = true;\n\n    // if not done with current page, need delimiter before next item\n    // if done with partition we also want a delmiter to indicate 'end of pages' final empty row\n    if (!doneWithPage || doneWithPartition) {\n      pageBuilder += this.options.delimiter;\n      pageLen += delimlen;\n    }\n\n    // if we are done with page save it and pass off to next recursive call or callback\n    if (doneWithPartition || doneWithPage) {\n      this.adapter.saveDatabase(keyname, pageBuilder, pageSaveCallback);\n      completed = true;\n    }\n  }\n};\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n/* eslint-disable no-var */\n\"use strict\";\n\nimport { FsAdapter } from \"../storage-adapter/fs-adapter\";\nimport { Collection, CollectionDocument } from \"./collection\";\nimport { deepFreeze, freeze, unFreeze } from \"../utils/icebox\";\nimport { Utils } from \"../utils/index\";\nimport { SylvieEventEmitter } from \"./sylvie-event-emitter\";\nimport { LokiOps } from \"../utils/ops\";\nimport { aeqHelper, ltHelper, gtHelper, Comparators } from \"../utils/sort\";\nimport { DynamicView } from \"./dynamic-view\";\nimport { KeyValueStore } from \"./key-value-store\";\nimport { ResultSet } from \"./result-set\";\nimport { LocalStorageAdapter } from \"../storage-adapter/local-storage-adapter\";\nimport { MemoryAdapter } from \"../storage-adapter/memory-adapter\";\nimport {\n  PartitioningAdapter,\n  PartitioningAdapterOptions,\n} from \"../storage-adapter/partitioning-adapter\";\nimport {\n  AsyncPersistenceAdapter,\n  SyncPersistenceAdapter,\n} from \"../storage-adapter/persistence-adapter\";\n\nexport type ChangeOpsLoadJSONUsersOptions = {\n  inflate:\n    | ((src: any) => ChangeOpsLoadJSONOptionsMeta)\n    | ((src: any, dest: ChangeOpsLoadJSONOptionsMeta) => void);\n  proto: (n: any) => void;\n};\n\nexport interface ChangeOpsLoadJSONOptionsMeta {\n  $loki: any;\n  meta: any;\n  onlyInflater: any;\n  customInflater: boolean;\n}\n\nexport interface ChangeOpsLoadJSONOptions extends ChangeOpsLoadJSONOptionsMeta {\n  retainDirtyFlags: boolean;\n  users: Partial<ChangeOpsLoadJSONUsersOptions>;\n}\n\nexport interface ChangeOps {\n  name: string;\n  operation: \"U\" | \"I\" | \"R\";\n  obj: Record<string, any>;\n}\n\nexport interface Obj {\n  name?: string;\n  owner?: string;\n  maker?: string | { count: number };\n  count: number;\n  meta: Meta;\n  $loki: number;\n}\n\nexport interface Meta {\n  revision: number;\n  created: number;\n  version: number;\n  updated?: number;\n}\n\ninterface SerializationOptions {\n  partitioned: boolean;\n  partition: number;\n  delimited: boolean;\n  delimiter: string;\n}\n\ninterface ConstructorOptions {\n  verbose: boolean;\n  env: \"NATIVESCRIPT\" | \"NODEJS\" | \"CORDOVA\" | \"BROWSER\" | \"NA\";\n}\n\ninterface ConfigOptions {\n  adapter: SyncPersistenceAdapter | AsyncPersistenceAdapter | null;\n  autoload: boolean;\n  autoloadCallback: (err: any) => void;\n  autosave: boolean;\n  autosaveCallback: (err?: any) => void;\n  autosaveInterval: string | number;\n  persistenceMethod: \"fs\" | \"localStorage\" | \"memory\" | null;\n  destructureDelimiter: string;\n  serializationMethod: \"normal\" | \"pretty\" | \"destructured\" | null;\n  throttledSaves: boolean;\n}\n\n/**\n * Sylvie: The main database class\n * @implements SylvieEventEmitter\n */\nexport default class Sylvie extends SylvieEventEmitter {\n  filename: string;\n  collections: Collection<Partial<CollectionDocument>>[];\n  databaseVersion: number;\n  engineVersion: number;\n  autosave: boolean;\n  autosaveInterval: number;\n  autosaveHandle: any;\n  throttledSaves: boolean;\n  options?: Partial<ConfigOptions & ConstructorOptions>;\n  persistenceMethod: any;\n  persistenceAdapter: SyncPersistenceAdapter | AsyncPersistenceAdapter | null;\n  throttledSavePending: boolean;\n  throttledCallbacks: any[];\n  verbose: boolean;\n  ENV: string;\n  isIncremental: boolean;\n  name: string;\n  ignoreAutosave: boolean;\n  static deepFreeze: (obj: object) => void;\n  static freeze: (obj: object) => void;\n  static unFreeze: (obj: object) => any;\n  static LokiOps: {\n    $eq: (a: any, b: any) => boolean;\n    $aeq: (a: any, b: any) => boolean;\n    $ne: (a: any, b: any) => boolean;\n    $dteq: (a: any, b: any) => boolean;\n    $gt: (a: any, b: any) => any;\n    $gte: (a: any, b: any) => any;\n    $lt: (a: any, b: any) => any;\n    $lte: (a: any, b: any) => any;\n    $jgt: (a: any, b: any) => boolean;\n    $jgte: (a: any, b: any) => boolean;\n    $jlt: (a: any, b: any) => boolean;\n    $jlte: (a: any, b: any) => boolean;\n    $between: (a: any, vals: any) => any;\n    $jbetween: (a: any, vals: any) => boolean;\n    $in: (a: any, b: any) => boolean;\n    $inSet: (a: any, b: any) => any;\n    $nin: (a: any, b: any) => boolean;\n    $keyin: (a: any, b: any) => boolean;\n    $nkeyin: (a: any, b: any) => boolean;\n    $definedin: (a: any, b: any) => boolean;\n    $undefinedin: (a: any, b: any) => boolean;\n    $regex: (a: any, b: any) => any;\n    $containsString: (a: any, b: any) => boolean;\n    $containsNone: (a: any, b: any) => boolean;\n    $containsAny: (a: any, b: any) => boolean;\n    $contains: (a: any, b: any) => boolean;\n    $elemMatch: (a: any, b: any) => boolean;\n    $type: (a: any, b: any, record: any) => any;\n    $finite: (a: any, b: any) => boolean;\n    $size: (a: any, b: any, record: any) => any;\n    $len: (a: any, b: any, record: any) => any;\n    $where: (a: any, b: any) => boolean;\n    $not: (a: any, b: any, record: any) => boolean;\n    $and: (a: any, b: any, record: any) => boolean;\n    $or: (a: any, b: any, record: any) => boolean;\n    $exists: (a: any, b: any) => boolean;\n  };\n  static Collection: typeof Collection;\n  static DynamicView: typeof DynamicView;\n  static Resultset: typeof ResultSet;\n  static KeyValueStore: () => void;\n  static LokiMemoryAdapter: typeof MemoryAdapter;\n  static LokiPartitioningAdapter: (\n    adapter: any,\n    options?: Partial<PartitioningAdapterOptions>,\n  ) => void;\n  static LokiLocalStorageAdapter: typeof LocalStorageAdapter;\n  static LokiFsAdapter: typeof FsAdapter;\n  static persistenceAdapters: {\n    fs: typeof FsAdapter;\n    localStorage: typeof LocalStorageAdapter;\n  };\n  static aeq: (prop1: any, prop2: any) => boolean;\n  static lt: (prop1: any, prop2: any, equal: any) => any;\n  static gt: (prop1: any, prop2: any, equal: any) => any;\n  static Comparators: {\n    aeq: (prop1: any, prop2: any) => boolean;\n    lt: (prop1: any, prop2: any, equal: any) => any;\n    gt: (prop1: any, prop2: any, equal: any) => any;\n  };\n  toJson: (options?: Partial<ConfigOptions>) => any;\n\n  /**\n   * Create a instance of the SylvieJS database.\n   * @param {string} filename - name of the file to be saved to\n   * @param {object=} options - (Optional) config options object\n   * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n   * @param {boolean} [options.verbose=false] - enable console output\n   * @param {boolean} [options.autosave=false] - enables autosave\n   * @param {int} [options.autosaveInterval=5000] - time interval (in milliseconds) between saves (if dirty)\n   * @param {boolean} [options.autoload=false] - enables autoload on loki instantiation\n   * @param {function} options.autoloadCallback - user callback called after database load\n   * @param {adapter} options.adapter - an instance of a loki persistence adapter\n   * @param {string} [options.serializationMethod='normal'] - ['normal', 'pretty', 'destructured']\n   * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n   * @param {boolean} [options.throttledSaves=true] - debounces multiple calls to to saveDatabase reducing number of disk I/O operations\n   *                                           and guaranteeing proper serialization of the calls.\n   */\n  constructor(\n    filename?: string,\n    options?: Partial<ConfigOptions & ConstructorOptions>,\n  ) {\n    super();\n    this.filename = filename || \"loki.db\";\n    this.collections = [];\n\n    // persist version of code which created the database to the database.\n    // could use for upgrade scenarios\n    this.databaseVersion = 1.5;\n    this.engineVersion = 1.5;\n\n    // autosave support (disabled by default)\n    // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n    this.autosave = false;\n    this.autosaveInterval = 5000;\n    this.autosaveHandle = null;\n    this.throttledSaves = true;\n\n    this.options = {};\n\n    // currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n    // will not or cannot be deserialized.  You are required to configure persistence every time\n    // you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n    // persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n    // this is optional option param, otherwise environment detection will be used\n    // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n    this.persistenceMethod = null;\n\n    // retain reference to optional (non-serializable) persistenceAdapter 'instance'\n    this.persistenceAdapter = null;\n\n    // flags used to throttle saves\n    this.throttledSavePending = false;\n    this.throttledCallbacks = [];\n\n    // enable console output if verbose flag is set (disabled by default)\n    this.verbose =\n      options && Object.hasOwn(options, \"verbose\") ? options.verbose : false;\n\n    this.events = {\n      init: [],\n      loaded: [],\n      flushChanges: [],\n      close: [],\n      changes: [],\n      warning: [],\n    };\n\n    const getENV = () => {\n      if (\n        typeof global !== \"undefined\" &&\n        (global.android || global.NSObject)\n      ) {\n        // If no adapter assume nativescript which needs adapter to be passed manually\n        return \"NATIVESCRIPT\"; //nativescript\n      }\n\n      if (typeof window === \"undefined\") {\n        return \"NODEJS\";\n      }\n\n      if (\n        typeof global !== \"undefined\" &&\n        global.window &&\n        typeof process !== \"undefined\"\n      ) {\n        return \"NODEJS\"; //node-webkit\n      }\n\n      if (typeof document !== \"undefined\") {\n        if (\n          !document.URL.includes(\"http://\") &&\n          !document.URL.includes(\"https://\")\n        ) {\n          return \"CORDOVA\";\n        }\n        return \"BROWSER\";\n      }\n      return \"CORDOVA\";\n    };\n\n    // refactored environment detection due to invalid detection for browser environments.\n    // if they do not specify an options.env we want to detect env rather than default to nodejs.\n    // currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n    //   might want to review whether we can consolidate.\n    if (options && Object.hasOwn(options, \"env\")) {\n      this.ENV = options.env;\n    } else {\n      this.ENV = getENV();\n    }\n\n    // not sure if this is necessary now that i have refactored the line above\n    if (this.ENV === \"undefined\") {\n      this.ENV = \"NODEJS\";\n    }\n\n    this.configureOptions(options, true);\n\n    this.on(\"init\", this.clearChanges);\n  }\n\n  // experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n  // Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n  getIndexedAdapter() {\n    let adapter;\n\n    if (typeof require === \"function\") {\n      adapter = require(\"../storage-adapter/indexeddb-adapter.js\");\n    }\n\n    return adapter;\n  }\n\n  /**\n   * Allows reconfiguring database options\n   *\n   * @param {object} options - configuration options to apply to loki db object\n   * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n   * @param {boolean} options.verbose - enable console output (default is 'false')\n   * @param {boolean} options.autosave - enables autosave\n   * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n   * @param {boolean} options.autoload - enables autoload on loki instantiation\n   * @param {function} options.autoloadCallback - user callback called after database load\n   * @param {adapter} options.adapter - an instance of a loki persistence adapter\n   * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']\n   * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n   * @param {boolean} initialConfig - (internal) true is passed when loki ctor is invoking\n   * @memberof Loki\n   */\n  configureOptions(options, initialConfig) {\n    const defaultPersistence = {\n      NODEJS: \"fs\",\n      BROWSER: \"localStorage\",\n      CORDOVA: \"localStorage\",\n      MEMORY: \"memory\",\n    };\n\n    const persistenceMethods = {\n      fs: FsAdapter,\n      localStorage: LocalStorageAdapter,\n      memory: MemoryAdapter,\n    };\n\n    this.options = {};\n\n    this.persistenceMethod = null;\n    // retain reference to optional persistence adapter 'instance'\n    // currently keeping outside options because it can't be serialized\n    this.persistenceAdapter = null;\n\n    // process the options\n    if (typeof options !== \"undefined\") {\n      this.options = options;\n\n      if (Object.hasOwn(this.options, \"persistenceMethod\")) {\n        // check if the specified persistence method is known\n        if (\n          typeof persistenceMethods[options.persistenceMethod] == \"function\"\n        ) {\n          this.persistenceMethod = options.persistenceMethod;\n          this.persistenceAdapter = new persistenceMethods[\n            options.persistenceMethod\n          ]();\n        }\n        // should be throw an error here, or just fall back to defaults ??\n      }\n\n      // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n      if (Object.hasOwn(this.options, \"adapter\")) {\n        this.persistenceMethod = \"adapter\";\n        this.persistenceAdapter = options.adapter;\n        this.options.adapter = null;\n\n        // if true, will keep track of dirty ids\n        this.isIncremental = this.persistenceAdapter.mode === \"incremental\";\n      }\n\n      // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n      if (options.autoload && initialConfig) {\n        // for autoload, let the constructor complete before firing callback\n        const self = this;\n        setTimeout(() => {\n          self.loadDatabase(options, options.autoloadCallback);\n        }, 1);\n      }\n\n      if (Object.hasOwn(this.options, \"autosaveInterval\")) {\n        this.autosaveDisable();\n        this.autosaveInterval = parseInt(\n          this.options.autosaveInterval as string,\n          10,\n        );\n      }\n\n      if (Object.hasOwn(this.options, \"autosave\") && this.options.autosave) {\n        this.autosaveDisable();\n        this.autosave = true;\n\n        if (Object.hasOwn(this.options, \"autosaveCallback\")) {\n          this.autosaveEnable(options, options.autosaveCallback);\n        } else {\n          this.autosaveEnable();\n        }\n      }\n\n      if (Object.hasOwn(this.options, \"throttledSaves\")) {\n        this.throttledSaves = this.options.throttledSaves;\n      }\n    } // end of options processing\n\n    // ensure defaults exists for options which were not set\n    if (!Object.hasOwn(this.options, \"serializationMethod\")) {\n      this.options.serializationMethod = \"normal\";\n    }\n\n    // ensure passed or default option exists\n    if (!Object.hasOwn(this.options, \"destructureDelimiter\")) {\n      this.options.destructureDelimiter = \"$<\\n\";\n    }\n\n    // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n    if (this.persistenceAdapter === null) {\n      this.persistenceMethod = defaultPersistence[this.ENV];\n      if (this.persistenceMethod) {\n        this.persistenceAdapter = new persistenceMethods[\n          this.persistenceMethod\n        ]();\n      }\n    }\n  }\n\n  /**\n   * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n   *\n   * @param {object} options - apply or override collection level settings\n   * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n   * @memberof Loki\n   */\n  copy(options?: { removeNonSerializable?: boolean }): Sylvie {\n    // in case running in an environment without accurate environment detection, pass 'NA'\n    const databaseCopy = new Sylvie(this.filename, { env: \"NA\" });\n    let clen;\n    let idx;\n\n    options = options || {};\n\n    // currently inverting and letting loadJSONObject do most of the work\n    databaseCopy.loadJSONObject(this, { retainDirtyFlags: true });\n\n    // since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic\n    if (\n      options.hasOwnProperty(\"removeNonSerializable\") &&\n      options.removeNonSerializable === true\n    ) {\n      databaseCopy.autosaveHandle = null;\n      databaseCopy.persistenceAdapter = null;\n\n      clen = databaseCopy.collections.length;\n      for (idx = 0; idx < clen; idx++) {\n        databaseCopy.collections[idx].constraints = null;\n        databaseCopy.collections[idx].ttl = null;\n      }\n    }\n\n    return databaseCopy;\n  }\n\n  /**\n   * Adds a collection to the database.\n   * @param {string} name - name of collection to add\n   * @param {object=} options - (optional) options to configure collection with.\n   * @param {array=} [options.unique=[]] - array of property names to define unique constraints for\n   * @param {array=} [options.exact=[]] - array of property names to define exact constraints for\n   * @param {array=} [options.indices=[]] - array property names to define binary indexes for\n   * @param {boolean} [options.asyncListeners=false] - whether listeners are called asynchronously\n   * @param {boolean} [options.disableMeta=false] - set to true to disable meta property on documents\n   * @param {boolean} [options.disableChangesApi=true] - set to false to enable Changes Api\n   * @param {boolean} [options.disableDeltaChangesApi=true] - set to false to enable Delta Changes API (requires Changes API, forces cloning)\n   * @param {boolean} [options.autoupdate=false] - use Object.observe to update objects automatically\n   * @param {boolean} [options.clone=false] - specify whether inserts and queries clone to/from user\n   * @param {string} [options.cloneMethod='parse-stringify'] - 'parse-stringify', 'jquery-extend-deep', 'shallow, 'shallow-assign'\n   * @param {int=} options.ttl - age of document (in ms.) before document is considered aged/stale.\n   * @param {int=} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n   * @returns {Collection} a reference to the collection which was just added\n   * @memberof Loki\n   */\n  addCollection(\n    name,\n    options?: Record<string, any>,\n  ): Collection<Partial<CollectionDocument>> {\n    let i;\n    const len = this.collections.length;\n\n    if (options && options.disableMeta === true) {\n      if (options.disableChangesApi === false) {\n        throw new Error(\n          \"disableMeta option cannot be passed as true when disableChangesApi is passed as false\",\n        );\n      }\n      if (options.disableDeltaChangesApi === false) {\n        throw new Error(\n          \"disableMeta option cannot be passed as true when disableDeltaChangesApi is passed as false\",\n        );\n      }\n      if (typeof options.ttl === \"number\" && options.ttl > 0) {\n        throw new Error(\n          \"disableMeta option cannot be passed as true when ttl is enabled\",\n        );\n      }\n    }\n\n    for (i = 0; i < len; i += 1) {\n      if (this.collections[i].name === name) {\n        return this.collections[i];\n      }\n    }\n\n    const collection = new Collection(name, options);\n    collection.isIncremental = this.isIncremental;\n    this.collections.push(collection);\n\n    if (this.verbose) collection.lokiConsoleWrapper = console;\n\n    return collection;\n  }\n\n  loadCollection(collection) {\n    if (!collection.name) {\n      throw new Error(\"Collection must have a name property to be loaded\");\n    }\n    this.collections.push(collection);\n  }\n\n  /**\n   * Retrieves reference to a collection by name.\n   * @param {string} collectionName - name of collection to look up\n   * @returns {Collection} Reference to collection in database by that name, or null if not found\n   * @memberof Loki\n   */\n  getCollection(collectionName) {\n    let i;\n    const len = this.collections.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.collections[i].name === collectionName) {\n        return this.collections[i];\n      }\n    }\n\n    // no such collection\n    this.emit(\"warning\", `collection ${collectionName} not found`);\n    return null;\n  }\n\n  /**\n   * Renames an existing loki collection\n   * @param {string} oldName - name of collection to rename\n   * @param {string} newName - new name of collection\n   * @returns {Collection} reference to the newly renamed collection\n   * @memberof Loki\n   */\n  renameCollection(oldName, newName) {\n    const c = this.getCollection(oldName);\n\n    if (c) {\n      c.name = newName;\n    }\n\n    return c;\n  }\n\n  /**\n   * Returns a list of collections in the database.\n   * @returns {object[]} array of objects containing 'name', 'type', and 'count' properties.\n   * @memberof Loki\n   */\n  listCollections() {\n    let i = this.collections.length;\n    const colls = [];\n\n    while (i--) {\n      colls.push({\n        name: this.collections[i].name,\n        type: this.collections[i].objType,\n        count: this.collections[i].data.length,\n      });\n    }\n    return colls;\n  }\n\n  /**\n   * Removes a collection from the database.\n   * @param {string} collectionName - name of collection to remove\n   * @memberof Loki\n   */\n  removeCollection(collectionName) {\n    let i;\n    const len = this.collections.length;\n\n    for (i = 0; i < len; i += 1) {\n      if (this.collections[i].name === collectionName) {\n        const tmpcol = new Collection(collectionName, {});\n        const curcol = this.collections[i];\n        for (const prop in curcol) {\n          if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n            curcol[prop] = tmpcol[prop];\n          }\n        }\n        this.collections.splice(i, 1);\n        return;\n      }\n    }\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  /**\n   * serializeReplacer - used to prevent certain properties from being serialized\n   *\n   */\n  serializeReplacer(key, value) {\n    switch (key) {\n      case \"autosaveHandle\":\n      case \"persistenceAdapter\":\n      case \"constraints\":\n      case \"ttl\":\n        return null;\n      case \"throttledSavePending\":\n      case \"throttledCallbacks\":\n        return undefined;\n      case \"lokiConsoleWrapper\":\n        return null;\n      default:\n        return value;\n    }\n  }\n\n  /**\n   * Serialize database to a string which can be loaded via {@link Sylvie#loadJSON}\n   *\n   * @returns {string} Stringified representation of the loki database.\n   * @memberof Loki\n   */\n  serialize(options: Partial<ConfigOptions> = {}) {\n    if (!options.hasOwnProperty(\"serializationMethod\")) {\n      options.serializationMethod = this.options.serializationMethod;\n    }\n\n    switch (options.serializationMethod) {\n      case \"normal\":\n        return JSON.stringify(this, this.serializeReplacer);\n      case \"pretty\":\n        return JSON.stringify(this, this.serializeReplacer, 2);\n      case \"destructured\":\n        return this.serializeDestructured(); // use default options\n      default:\n        return JSON.stringify(this, this.serializeReplacer);\n    }\n  }\n\n  /**\n   * Database level destructured JSON serialization routine to allow alternate serialization methods.\n   * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n   * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n   * your own structured persistence or data exchange.\n   *\n   * @param {object=} options - output format options for use externally to loki\n   * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n   * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n   * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n   * @param {string=} options.delimiter - override default delimiter\n   *\n   * @returns {string|array} A custom, restructured aggregation of independent serializations.\n   * @memberof Loki\n   */\n  serializeDestructured(options?: Partial<SerializationOptions>) {\n    let idx;\n    let sidx;\n    let result;\n    let resultlen;\n    const reconstruct = [];\n    let dbcopy;\n\n    options = options || {};\n\n    if (!options.hasOwnProperty(\"partitioned\")) {\n      options.partitioned = false;\n    }\n\n    if (!options.hasOwnProperty(\"delimited\")) {\n      options.delimited = true;\n    }\n\n    if (!options.hasOwnProperty(\"delimiter\")) {\n      options.delimiter = this.options.destructureDelimiter;\n    }\n\n    // 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n    if (\n      options.partitioned === true &&\n      options.hasOwnProperty(\"partition\") &&\n      options.partition >= 0\n    ) {\n      return this.serializeCollection({\n        delimited: options.delimited,\n        delimiter: options.delimiter,\n        collectionIndex: options.partition,\n      });\n    }\n\n    // not just an individual collection, so we will need to serialize db container via shallow copy\n    dbcopy = new Sylvie(this.filename);\n    dbcopy.loadJSONObject(this);\n\n    for (idx = 0; idx < dbcopy.collections.length; idx++) {\n      dbcopy.collections[idx].data = [];\n    }\n\n    // if we -only- wanted the db container portion, return it now\n    if (options.partitioned === true && options.partition === -1) {\n      // since we are deconstructing, override serializationMethod to normal for here\n      return dbcopy.serialize({\n        serializationMethod: \"normal\",\n      });\n    }\n\n    // at this point we must be deconstructing the entire database\n    // start by pushing db serialization into first array element\n    reconstruct.push(\n      dbcopy.serialize({\n        serializationMethod: \"normal\",\n      }),\n    );\n\n    dbcopy = null;\n\n    // push collection data into subsequent elements\n    for (idx = 0; idx < this.collections.length; idx++) {\n      result = this.serializeCollection({\n        delimited: options.delimited,\n        delimiter: options.delimiter,\n        collectionIndex: idx,\n      });\n\n      // NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n      if (options.partitioned === false && options.delimited === false) {\n        if (!Array.isArray(result)) {\n          throw new Error(\n            \"a nondelimited, non partitioned collection serialization did not return an expected array\",\n          );\n        }\n\n        // Array.concat would probably duplicate memory overhead for copying strings.\n        // Instead copy each individually, and clear old value after each copy.\n        // Hopefully this will allow g.c. to reduce memory pressure, if needed.\n        resultlen = result.length;\n\n        for (sidx = 0; sidx < resultlen; sidx++) {\n          reconstruct.push(result[sidx]);\n          result[sidx] = null;\n        }\n\n        reconstruct.push(\"\");\n      } else {\n        reconstruct.push(result);\n      }\n    }\n\n    // Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n    if (options.partitioned) {\n      // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n      // useful for simple future adaptations of existing persistence adapters to save collections separately\n      if (options.delimited) {\n        return reconstruct;\n      }\n      // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n      // This format might be the most versatile for 'rolling your own' partitioned sync or save.\n      // Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n      else {\n        return reconstruct;\n      }\n    } else {\n      // D : one big Delimited string { partitioned: false, delimited : true }\n      // This is the method Loki will use internally if 'destructured'.\n      // Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n      if (options.delimited) {\n        // indicate no more collections\n        reconstruct.push(\"\");\n\n        return reconstruct.join(options.delimiter);\n      }\n      // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n      // This format might be best candidate for custom synchronous syncs or saves\n      else {\n        // indicate no more collections\n        reconstruct.push(\"\");\n\n        return reconstruct;\n      }\n    }\n  }\n\n  /**\n   * Collection level utility method to serialize a collection in a 'destructured' format\n   *\n   * @param {object=} options - used to determine output of method\n   * @param {int} options.delimited - whether to return single delimited string or an array\n   * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n   * @param {int} options.collectionIndex -  specify which collection to serialize data for\n   *\n   * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n   * @memberof Loki\n   */\n  serializeCollection(options) {\n    let docidx;\n    let resultlines = [];\n\n    options = options || {};\n\n    if (!options.hasOwnProperty(\"delimited\")) {\n      options.delimited = true;\n    }\n\n    if (!options.hasOwnProperty(\"collectionIndex\")) {\n      throw new Error(\n        \"serializeCollection called without 'collectionIndex' option\",\n      );\n    }\n\n    const doccount = this.collections[options.collectionIndex].data.length;\n\n    resultlines = [];\n\n    for (docidx = 0; docidx < doccount; docidx++) {\n      resultlines.push(\n        JSON.stringify(this.collections[options.collectionIndex].data[docidx]),\n      );\n    }\n\n    // D and DA\n    if (options.delimited) {\n      // indicate no more documents in collection (via empty delimited string)\n      resultlines.push(\"\");\n\n      return resultlines.join(options.delimiter);\n    } else {\n      // NDAA and NDA\n      return resultlines;\n    }\n  }\n\n  /**\n   * Database level destructured JSON deserialization routine to minimize memory overhead.\n   * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n   * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n   * your own structured persistence or data exchange.\n   *\n   * @param {string|array} destructuredSource - destructured json or array to deserialize from\n   * @param {object=} options - source format options\n   * @param {bool=} [options.partitioned=false] - whether db and each collection are separate\n   * @param {int=} options.partition - can be used to deserialize only a single partition\n   * @param {bool=} [options.delimited=true] - whether subitems are delimited or subarrays\n   * @param {string=} options.delimiter - override default delimiter\n   *\n   * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n   * @memberof Loki\n   */\n  deserializeDestructured(\n    destructuredSource,\n    options?: Partial<SerializationOptions>,\n  ) {\n    let workarray = [];\n    let len;\n    let cdb;\n    let collIndex = 0;\n    let collCount;\n    let lineIndex = 1;\n    let done = false;\n    let currLine;\n    let currObject;\n\n    options = options || {};\n\n    if (!options.hasOwnProperty(\"partitioned\")) {\n      options.partitioned = false;\n    }\n\n    if (!options.hasOwnProperty(\"delimited\")) {\n      options.delimited = true;\n    }\n\n    if (!options.hasOwnProperty(\"delimiter\")) {\n      options.delimiter = this.options.destructureDelimiter;\n    }\n\n    // Partitioned\n    // DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n    // NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n    // -or- single partition\n    if (options.partitioned) {\n      // handle single partition\n      if (options.hasOwnProperty(\"partition\")) {\n        // db only\n        if (options.partition === -1) {\n          cdb = JSON.parse(destructuredSource[0]);\n\n          return cdb;\n        }\n\n        // single collection, return doc array\n        return this.deserializeCollection(\n          destructuredSource[options.partition + 1],\n          options,\n        );\n      }\n\n      // Otherwise we are restoring an entire partitioned db\n      cdb = JSON.parse(destructuredSource[0]);\n      collCount = cdb.collections.length;\n      for (collIndex = 0; collIndex < collCount; collIndex++) {\n        // attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n        cdb.collections[collIndex].data = this.deserializeCollection(\n          destructuredSource[collIndex + 1],\n          options,\n        );\n      }\n\n      return cdb;\n    }\n\n    // Non-Partitioned\n    // D : one big Delimited string { partitioned: false, delimited : true }\n    // NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\n    // D\n    if (options.delimited) {\n      workarray = destructuredSource.split(options.delimiter);\n      destructuredSource = null; // lower memory pressure\n      len = workarray.length;\n\n      if (len === 0) {\n        return null;\n      }\n    }\n    // NDA\n    else {\n      workarray = destructuredSource;\n    }\n\n    // first line is database and collection shells\n    cdb = JSON.parse(workarray[0]);\n    collCount = cdb.collections.length;\n    workarray[0] = null;\n\n    while (!done) {\n      currLine = workarray[lineIndex];\n\n      // empty string indicates either end of collection or end of file\n      if (workarray[lineIndex] === \"\") {\n        // if no more collections to load into, we are done\n        if (++collIndex > collCount) {\n          done = true;\n        }\n      } else {\n        currObject = JSON.parse(workarray[lineIndex]);\n        cdb.collections[collIndex].data.push(currObject);\n      }\n\n      // lower memory pressure and advance iterator\n      workarray[lineIndex++] = null;\n    }\n\n    return cdb;\n  }\n\n  /**\n   * Collection level utility function to deserializes a destructured collection.\n   *\n   * @param {string|array} destructuredSource - destructured representation of collection to inflate\n   * @param {object=} options - used to describe format of destructuredSource input\n   * @param {int=} [options.delimited=false] - whether source is delimited string or an array\n   * @param {string=} options.delimiter - if delimited, this is delimiter to use (if other than default)\n   *\n   * @returns {array} an array of documents to attach to collection.data.\n   * @memberof Loki\n   */\n  deserializeCollection(\n    destructuredSource,\n    options?: Partial<{\n      partitioned: boolean;\n      delimited: boolean;\n      delimiter: string;\n    }>,\n  ) {\n    let workarray = [];\n    let idx;\n\n    options = options || {};\n\n    if (!options.hasOwnProperty(\"partitioned\")) {\n      options.partitioned = false;\n    }\n\n    if (!options.hasOwnProperty(\"delimited\")) {\n      options.delimited = true;\n    }\n\n    if (!options.hasOwnProperty(\"delimiter\")) {\n      options.delimiter = this.options.destructureDelimiter;\n    }\n\n    if (options.delimited) {\n      workarray = destructuredSource.split(options.delimiter);\n      workarray.pop();\n    } else {\n      workarray = destructuredSource;\n    }\n\n    const len = workarray.length;\n    for (idx = 0; idx < len; idx++) {\n      workarray[idx] = JSON.parse(workarray[idx]);\n    }\n\n    return workarray;\n  }\n\n  /**\n   * Inflates a loki database from a serialized JSON string\n   *\n   * @param {string} serializedDb - a serialized loki database string\n   * @param {object=} options - apply or override collection level settings\n   * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved\n   * @memberof Loki\n   */\n  loadJSON(serializedDb, options?: Partial<ChangeOpsLoadJSONOptions>) {\n    let dbObject;\n    if (serializedDb.length === 0) {\n      dbObject = {};\n    } else {\n      // using option defined in instantiated db not what was in serialized db\n      switch (this.options.serializationMethod) {\n        case \"normal\":\n        case \"pretty\":\n          dbObject = JSON.parse(serializedDb);\n          break;\n        case \"destructured\":\n          dbObject = this.deserializeDestructured(serializedDb);\n          break;\n        default:\n          dbObject = JSON.parse(serializedDb);\n          break;\n      }\n    }\n\n    this.loadJSONObject(dbObject, options);\n  }\n\n  /**\n   * Inflates a loki database from a JS object\n   *\n   * @param {object} dbObject - a serialized loki database string\n   * @param {object=} options - apply or override collection level settings\n   * @param {bool} options.retainDirtyFlags - whether collection dirty flags will be preserved\n   * @memberof Loki\n   */\n  loadJSONObject(\n    dbObject,\n    options?: { throttledSaves?: boolean; retainDirtyFlags?: boolean },\n  ) {\n    let i = 0;\n    const len = dbObject.collections ? dbObject.collections.length : 0;\n    let coll;\n    let copyColl;\n    let clen;\n    let j;\n    let loader;\n    let collObj;\n\n    this.name = dbObject.name;\n\n    // restore save throttled boolean only if not defined in options\n    if (\n      dbObject.hasOwnProperty(\"throttledSaves\") &&\n      options &&\n      !options.hasOwnProperty(\"throttledSaves\")\n    ) {\n      this.throttledSaves = dbObject.throttledSaves;\n    }\n\n    this.collections = [];\n\n    function makeLoader({ name }) {\n      const collOptions = options[name];\n      let inflater;\n\n      if (collOptions.proto) {\n        inflater = collOptions.inflate || Utils.copyProperties;\n\n        return (data) => {\n          const collObj = new collOptions.proto();\n          inflater(data, collObj);\n          return collObj;\n        };\n      }\n\n      return collOptions.inflate;\n    }\n\n    for (i; i < len; i += 1) {\n      coll = dbObject.collections[i];\n\n      copyColl = this.addCollection(coll.name, {\n        disableChangesApi: coll.disableChangesApi,\n        disableDeltaChangesApi: coll.disableDeltaChangesApi,\n        disableMeta: coll.disableMeta,\n        disableFreeze: coll.hasOwnProperty(\"disableFreeze\")\n          ? coll.disableFreeze\n          : true,\n      });\n\n      copyColl.adaptiveBinaryIndices = coll.hasOwnProperty(\n        \"adaptiveBinaryIndices\",\n      )\n        ? coll.adaptiveBinaryIndices === true\n        : false;\n      copyColl.transactional = coll.transactional;\n      copyColl.asyncListeners = coll.asyncListeners;\n      copyColl.cloneObjects = coll.cloneObjects;\n      copyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n      copyColl.autoupdate = coll.autoupdate;\n      copyColl.changes = coll.changes;\n      copyColl.dirtyIds = coll.dirtyIds || [];\n\n      if (options && options.retainDirtyFlags === true) {\n        copyColl.dirty = coll.dirty;\n      } else {\n        copyColl.dirty = false;\n      }\n\n      if (coll.getData) {\n        if (\n          (options && options.hasOwnProperty(coll.name)) ||\n          !copyColl.disableFreeze ||\n          copyColl.autoupdate\n        ) {\n          throw new Error(\n            `this collection cannot be loaded lazily: ${coll.name}`,\n          );\n        }\n        copyColl.getData = coll.getData;\n        Object.defineProperty(copyColl, \"data\", {\n          /* jshint loopfunc:true */\n          get() {\n            const data = this.getData();\n            this.getData = null;\n            Object.defineProperty(this, \"data\", { value: data });\n            return data;\n          },\n          /* jshint loopfunc:false */\n        });\n      } else {\n        // load each element individually\n        clen = coll.data.length;\n        j = 0;\n        if (options && options.hasOwnProperty(coll.name)) {\n          loader = makeLoader(coll);\n\n          for (j; j < clen; j++) {\n            collObj = loader(coll.data[j]);\n            copyColl.data[j] = collObj;\n            copyColl.addAutoUpdateObserver(collObj);\n            if (!copyColl.disableFreeze) {\n              deepFreeze(copyColl.data[j]);\n            }\n          }\n        } else {\n          for (j; j < clen; j++) {\n            copyColl.data[j] = coll.data[j];\n            copyColl.addAutoUpdateObserver(copyColl.data[j]);\n            if (!copyColl.disableFreeze) {\n              deepFreeze(copyColl.data[j]);\n            }\n          }\n        }\n      }\n\n      copyColl.maxId = typeof coll.maxId === \"undefined\" ? 0 : coll.maxId;\n      if (typeof coll.binaryIndices !== \"undefined\") {\n        copyColl.binaryIndices = coll.binaryIndices;\n      }\n      if (typeof coll.transforms !== \"undefined\") {\n        copyColl.transforms = coll.transforms;\n      }\n\n      // regenerate unique indexes\n      copyColl.uniqueNames = [];\n      if (coll.hasOwnProperty(\"uniqueNames\")) {\n        copyColl.uniqueNames = coll.uniqueNames;\n      }\n\n      // in case they are loading a database created before we added dynamic views, handle undefined\n      if (typeof coll.DynamicViews === \"undefined\") continue;\n\n      // reinflate DynamicViews and attached Resultsets\n      for (let idx = 0; idx < coll.DynamicViews.length; idx++) {\n        const colldv = coll.DynamicViews[idx];\n\n        const dv = copyColl.addDynamicView(colldv.name, colldv.options);\n        dv.resultdata = colldv.resultdata;\n        dv.resultsdirty = colldv.resultsdirty;\n        dv.filterPipeline = colldv.filterPipeline;\n        dv.sortCriteriaSimple = colldv.sortCriteriaSimple;\n        dv.sortCriteria = colldv.sortCriteria;\n        dv.sortFunction = null;\n        dv.sortDirty = colldv.sortDirty;\n        if (!copyColl.disableFreeze) {\n          deepFreeze(dv.filterPipeline);\n          if (dv.sortCriteriaSimple) {\n            deepFreeze(dv.sortCriteriaSimple);\n          } else if (dv.sortCriteria) {\n            deepFreeze(dv.sortCriteria);\n          }\n        }\n        dv.resultset.filteredrows = colldv.resultset.filteredrows;\n        dv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\n        dv.rematerialize({\n          removeWhereFilters: true,\n        });\n      }\n\n      // Upgrade Logic for binary index refactoring at version 1.5\n      if (dbObject.databaseVersion < 1.5) {\n        // rebuild all indices\n        copyColl.ensureAllIndexes(true);\n        copyColl.dirty = true;\n      }\n    }\n  }\n\n  /**\n   * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n   * Does not actually destroy the db.\n   *\n   * @param {function=} callback - (Optional) if supplied will be registered with close event before emitting.\n   * @memberof Loki\n   */\n  close(callback) {\n    // for autosave scenarios, we will let close perform final save (if dirty)\n    // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n    if (this.autosave) {\n      this.autosaveDisable();\n      if (this.autosaveDirty()) {\n        this.saveDatabase(callback);\n        callback = undefined;\n      }\n    }\n\n    if (callback) {\n      this.on(\"close\", callback);\n    }\n    this.emit(\"close\");\n  }\n\n  // TODO: add tests\n  async closeAsync() {\n    if (this.autosave) {\n      this.autosaveDisable();\n      if (this.autosaveDirty()) {\n        await this.saveDatabaseAsync();\n      }\n    }\n    this.emit(\"close\");\n  }\n\n  /**-------------------------+\n  | Changes API               |\n  +--------------------------*/\n\n  /**\n   * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n   * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n   */\n\n  /**\n   * (Changes API) : takes all the changes stored in each\n   * collection and creates a single array for the entire database. If an array of names\n   * of collections is passed then only the included collections will be tracked.\n   *\n   * @param {array=} optional array of collection names. No arg means all collections are processed.\n   * @returns {array} array of changes\n   * @see private method createChange() in Collection\n   * @memberof Loki\n   */\n  generateChangesNotification(\n    arrayOfCollectionNames?: string[] | string,\n  ): ChangeOps[] {\n    function getCollName({ name }) {\n      return name;\n    }\n    let changes = [];\n\n    const selectedCollections =\n      arrayOfCollectionNames || this.collections.map(getCollName);\n\n    this.collections.forEach((coll) => {\n      if (selectedCollections.includes(getCollName(coll))) {\n        changes = changes.concat(coll.getChanges());\n      }\n    });\n    return changes;\n  }\n\n  /**\n   * (Changes API) - stringify changes for network transmission\n   * @returns {string} string representation of the changes\n   * @memberof Loki\n   */\n  serializeChanges(collectionNamesArray?): string {\n    return JSON.stringify(\n      this.generateChangesNotification(collectionNamesArray),\n    );\n  }\n\n  /**\n   * (Changes API) - deserialize a serialized changes array\n   * @returns {ChangeOps[]} string representation of the changes\n   * @memberof Loki\n   */\n  deserializeChanges(collectionString): ChangeOps[] {\n    return JSON.parse(collectionString);\n  }\n\n  /**\n   * (Changes API) : clears all the changes in all collections.\n   * @memberof Loki\n   */\n  clearChanges() {\n    this.collections.forEach((coll) => {\n      if (coll.flushChanges) {\n        coll.flushChanges();\n      }\n    });\n  }\n\n  /**\n   * Wait for throttledSaves to complete and invoke your callback when drained or duration is met.\n   *\n   * @param {function} callback - callback to fire when save queue is drained, it is passed a sucess parameter value\n   * @param {object=} options - configuration options\n   * @param {boolean} options.recursiveWait - (default: true) if after queue is drained, another save was kicked off, wait for it\n   * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n   * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n   * @memberof Loki\n   */\n  throttledSaveDrain(\n    callback,\n    options?: {\n      recursiveWait?: boolean;\n      recursiveWaitLimit?: boolean;\n      recursiveWaitLimitDelay?: boolean;\n      recursiveWaitLimitDuration?: number;\n      started?: number;\n    },\n  ) {\n    const self = this;\n    const now = new Date().getTime();\n\n    if (!this.throttledSaves) {\n      callback(true);\n    }\n\n    options =\n      options ||\n      ({} as {\n        recursiveWait?: boolean;\n        recursiveWaitLimit?: boolean;\n        recursiveWaitLimitDelay?: boolean;\n      });\n    if (!options.hasOwnProperty(\"recursiveWait\")) {\n      options.recursiveWait = true;\n    }\n    if (!options.hasOwnProperty(\"recursiveWaitLimit\")) {\n      options.recursiveWaitLimit = false;\n    }\n    if (!options.hasOwnProperty(\"recursiveWaitLimitDuration\")) {\n      options.recursiveWaitLimitDuration = 2000;\n    }\n    if (!options.hasOwnProperty(\"started\")) {\n      options.started = new Date().getTime();\n    }\n\n    // if save is pending\n    if (this.throttledSaves && this.throttledSavePending) {\n      // if we want to wait until we are in a state where there are no pending saves at all\n      if (options.recursiveWait) {\n        // queue the following meta callback for when it completes\n        this.throttledCallbacks.push(() => {\n          // if there is now another save pending...\n          if (self.throttledSavePending) {\n            // if we wish to wait only so long and we have exceeded limit of our waiting, callback with false success value\n            if (\n              options.recursiveWaitLimit &&\n              now - options.started > options.recursiveWaitLimitDuration\n            ) {\n              callback(false);\n              return;\n            }\n            // it must be ok to wait on next queue drain\n            self.throttledSaveDrain(callback, options);\n            return;\n          }\n          // no pending saves so callback with true success\n          else {\n            callback(true);\n            return;\n          }\n        });\n      }\n      // just notify when current queue is depleted\n      else {\n        this.throttledCallbacks.push(callback);\n        return;\n      }\n    }\n    // no save pending, just callback\n    else {\n      callback(true);\n    }\n  }\n\n  /**\n   * Internal load logic, decoupled from throttling/contention logic\n   *\n   * @param {object} options - not currently used (remove or allow overrides?)\n   * @param {function=} callback - (Optional) user supplied async callback / error handler\n   */\n  loadDatabaseInternal = (\n    options,\n    callback?: (\n      _: Error | { success: true } | { success: false; error: Error },\n    ) => void,\n  ) => {\n    const cFun =\n      callback ||\n      ((err) => {\n        if (err) {\n          throw err;\n        }\n      });\n\n    const handleValidDbString = (dbString) => {\n      let parseSuccess = false;\n      try {\n        this.loadJSON(dbString, options || {});\n        parseSuccess = true;\n      } catch (err) {\n        cFun(err);\n      }\n      if (parseSuccess) {\n        cFun(null);\n        this.emit(\"loaded\", `database ${this.filename} loaded`);\n      }\n    };\n\n    const handleLoadError = (dbString: undefined | Error | object) => {\n      // falsy result means new database\n      if (!dbString) {\n        cFun(null);\n        this.emit(\"loaded\", `empty database ${this.filename} loaded`);\n        return;\n      }\n\n      // instanceof error means load faulted\n      if (dbString instanceof Error) {\n        cFun(dbString);\n        return;\n      }\n\n      // if adapter has returned an js object (other than null or error) attempt to load from JSON object\n      if (typeof dbString === \"object\") {\n        this.loadJSONObject(dbString, options || {});\n        cFun(null); // return null on success\n        this.emit(\"loaded\", `database ${this.filename} loaded`);\n        return;\n      }\n\n      cFun({\n        success: false,\n        error: Error(`unexpected adapter response : ${dbString}`),\n      });\n    };\n\n    const loadDatabaseCallback = (\n      dbString: string | undefined | Error | object,\n    ) => {\n      if (typeof dbString === \"string\") {\n        handleValidDbString(dbString);\n      } else {\n        handleLoadError(dbString);\n      }\n    };\n\n    // the persistenceAdapter should be present if all is ok, but check to be sure.\n    if (this.persistenceAdapter !== null) {\n      if (\"isAsync\" in this.persistenceAdapter) {\n        this.persistenceAdapter\n          .loadDatabaseAsync(this.filename)\n          .then((dbstring) => handleValidDbString(dbstring))\n          .catch((error) => handleLoadError(error));\n      } else {\n        this.persistenceAdapter.loadDatabase(\n          this.filename,\n          loadDatabaseCallback,\n        );\n      }\n    } else {\n      cFun(new Error(\"persistenceAdapter not configured\"));\n    }\n  };\n\n  /**\n   * Handles manually loading from file system, local storage, or adapter (such as indexeddb)\n   *    This method utilizes loki configuration options (if provided) to determine which\n   *    persistence method to use, or environment detection (if configuration was not provided).\n   *    To avoid contention with any throttledSaves, we will drain the save queue first.\n   *\n   * If you are configured with autosave, you do not need to call this method yourself.\n   *\n   * @param {object} options - if throttling saves and loads, this controls how we drain save queue before loading\n   * @param {boolean} options.recursiveWait - (default: true) wait recursively until no saves are queued\n   * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n   * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n   * @param {function=} callback - (Optional) user supplied async callback / error handler\n   * @memberof Loki\n   * @example\n   * db.loadDatabase({}, function(err) {\n   *   if (err) {\n   *     console.log(\"error : \" + err);\n   *   }\n   *   else {\n   *     console.log(\"database loaded.\");\n   *   }\n   * });\n   */\n  loadDatabase(\n    options?: {\n      recursiveWait?: boolean;\n      recursiveWaitLimit?: boolean;\n      recursiveWaitLimitDelay?: boolean;\n    },\n    callback?: (\n      _: Error | { success: true } | { success: false; error: Error },\n    ) => void,\n  ) {\n    const self = this;\n\n    // if throttling disabled, just call internal\n    if (!this.throttledSaves) {\n      this.loadDatabaseInternal(options, callback);\n      return;\n    }\n\n    // try to drain any pending saves in the queue to lock it for loading\n    this.throttledSaveDrain((success) => {\n      if (success) {\n        // pause/throttle saving until loading is done\n        self.throttledSavePending = true;\n\n        self.loadDatabaseInternal(options, (err) => {\n          // now that we are finished loading, if no saves were throttled, disable flag\n          if (self.throttledCallbacks.length === 0) {\n            self.throttledSavePending = false;\n          }\n          // if saves requests came in while loading, kick off new save to kick off resume saves\n          else {\n            self.saveDatabase();\n          }\n\n          if (typeof callback === \"function\") {\n            callback(err);\n          }\n        });\n        return;\n      } else {\n        if (typeof callback === \"function\") {\n          callback(\n            new Error(\n              \"Unable to pause save throttling long enough to read database\",\n            ),\n          );\n        }\n      }\n    }, options);\n  }\n\n  async loadDatabaseAsync(options?: {\n    recursiveWait?: boolean;\n    recursiveWaitLimit?: boolean;\n    recursiveWaitLimitDelay?: boolean;\n  }) {\n    return new Promise((resolve, reject) => {\n      const resolveCallback = (_: { success: true }) => resolve(_);\n      const rejectCallback = (_: Error | { success: false; error: Error }) =>\n        reject(_);\n      const self = this;\n\n      // if throttling disabled, just call internal\n      if (!this.throttledSaves) {\n        this.loadDatabaseInternal(options, resolveCallback);\n        return;\n      }\n\n      // try to drain any pending saves in the queue to lock it for loading\n      this.throttledSaveDrain((success) => {\n        if (success) {\n          // pause/throttle saving until loading is done\n          self.throttledSavePending = true;\n\n          self.loadDatabaseInternal(options, (err) => {\n            // now that we are finished loading, if no saves were throttled, disable flag\n            if (self.throttledCallbacks.length === 0) {\n              self.throttledSavePending = false;\n            }\n            // if saves requests came in while loading, kick off new save to kick off resume saves\n            else {\n              self.saveDatabase();\n            }\n\n            resolve(err as { success: true });\n          });\n          return;\n        } else {\n          rejectCallback(\n            new Error(\n              \"Unable to pause save throttling long enough to read database\",\n            ),\n          );\n        }\n      }, options);\n    });\n  }\n\n  /**\n   * Internal save logic, decoupled from save throttling logic\n   */\n  saveDatabaseInternal(callback) {\n    const cFun =\n      callback ||\n      ((err) => {\n        if (err) {\n          throw err;\n        }\n        return;\n      });\n    const self = this;\n\n    // the persistenceAdapter should be present if all is ok, but check to be sure.\n    if (!this.persistenceAdapter) {\n      cFun(new Error(\"persistenceAdapter not configured\"));\n      return;\n    }\n\n    // run incremental, reference, or normal mode adapters, depending on what's available\n    if (this.persistenceAdapter.mode === \"incremental\") {\n      let cachedDirty;\n      // ignore autosave until we copy loki (only then we can clear dirty flags,\n      // but if we don't do it now, autosave will be triggered a lot unnecessarily)\n      this.ignoreAutosave = true;\n      if (!(\"isAsync\" in this.persistenceAdapter)) {\n        this.persistenceAdapter.saveDatabase(\n          this.filename,\n          function getLokiCopy() {\n            self.ignoreAutosave = false;\n            if (cachedDirty) {\n              cFun(\n                new Error(\"adapter error - getLokiCopy called more than once\"),\n              );\n              return;\n            }\n            const lokiCopy = self.copy({ removeNonSerializable: true });\n\n            // remember and clear dirty ids -- we must do it before the save so that if\n            // and update occurs between here and callback, it will get saved later\n            cachedDirty = self.collections.map(({ dirty, dirtyIds }) => [\n              dirty,\n              dirtyIds,\n            ]);\n            self.collections.forEach((col) => {\n              col.dirty = false;\n              col.dirtyIds = [];\n            });\n            return lokiCopy;\n          },\n          function exportDatabaseCallback(err) {\n            self.ignoreAutosave = false;\n            if (err && cachedDirty) {\n              // roll back dirty IDs to be saved later\n              self.collections.forEach((col, i) => {\n                const cached = cachedDirty[i];\n                col.dirty = col.dirty || cached[0];\n                col.dirtyIds = col.dirtyIds.concat(cached[1]);\n              });\n            }\n            cFun(err);\n          },\n        );\n      } else {\n        // TODO: figure out the intended behavior of incremental and reference modes\n        cFun(\n          new Error(\n            \"Async incremental persistenceAdapter handling not implemented in SylvieJS\",\n          ),\n        );\n        return;\n      }\n    } else if (this.persistenceAdapter.mode === \"reference\") {\n      // TODO: dirty should be cleared here\n      // filename may seem redundant but loadDatabase will need to expect this same filename\n      if (\n        !(\"isAsync\" in this.persistenceAdapter) &&\n        this.persistenceAdapter.mode === \"reference\" &&\n        typeof this.persistenceAdapter.exportDatabase === \"function\"\n      ) {\n        this.persistenceAdapter.exportDatabase(\n          this.filename,\n          // @ts-ignore\n          this.copy({ removeNonSerializable: true }),\n          function exportDatabaseCallback(err) {\n            self.autosaveClearFlags();\n            cFun(err);\n          },\n        );\n      } else {\n        cFun(\n          new Error(\n            \"Async reference persistenceAdapter handling not implemented in SylvieJS\",\n          ),\n        );\n        return;\n      }\n    }\n    // otherwise just pass the serialized database to adapter\n    else {\n      // persistenceAdapter might be asynchronous, so we must clear `dirty` immediately\n      // or autosave won't work if an update occurs between here and the callback\n      // TODO: This should be stored and rolled back in case of DB save failure\n      this.autosaveClearFlags();\n      const afterSaveCallback = (err) => {\n        cFun(err);\n      };\n      if (\"isAsync\" in this.persistenceAdapter) {\n        this.persistenceAdapter\n          .saveDatabaseAsync(this.filename, this.serialize())\n          .then(afterSaveCallback)\n          .catch(afterSaveCallback);\n      } else {\n        this.persistenceAdapter.saveDatabase(\n          this.filename,\n          this.serialize(),\n          afterSaveCallback,\n        );\n      }\n    }\n  }\n\n  /**\n   * Handles manually saving to file system, local storage, or adapter (such as indexeddb)\n   *    This method utilizes loki configuration options (if provided) to determine which\n   *    persistence method to use, or environment detection (if configuration was not provided).\n   *\n   * If you are configured with autosave, you do not need to call this method yourself.\n   *\n   * @param {function=} callback - (Optional) user supplied async callback / error handler\n   * @memberof Loki\n   * @example\n   * db.saveDatabase(function(err) {\n   *   if (err) {\n   *     console.log(\"error : \" + err);\n   *   }\n   *   else {\n   *     console.log(\"database saved.\");\n   *   }\n   * });\n   */\n  saveDatabase(callback?: (_: string | Error) => any) {\n    if (!this.throttledSaves) {\n      this.saveDatabaseInternal(callback);\n      return;\n    }\n\n    if (this.throttledSavePending) {\n      this.throttledCallbacks.push(callback);\n      return;\n    }\n\n    const localCallbacks = this.throttledCallbacks;\n    this.throttledCallbacks = [];\n    localCallbacks.unshift(callback);\n    this.throttledSavePending = true;\n\n    const self = this;\n    this.saveDatabaseInternal((err) => {\n      self.throttledSavePending = false;\n      localCallbacks.forEach((pcb) => {\n        if (typeof pcb === \"function\") {\n          // Queue the callbacks so we first finish this method execution\n          setTimeout(() => {\n            pcb(err);\n          }, 1);\n        }\n      });\n\n      // since this is called async, future requests may have come in, if so.. kick off next save\n      if (self.throttledCallbacks.length > 0) {\n        self.saveDatabase();\n      }\n    });\n  }\n\n  async saveDatabaseAsync(): Promise<void> {\n    return new Promise((resolve) => {\n      const resolveCallback = () => resolve();\n      if (!this.throttledSaves) {\n        this.saveDatabaseInternal(resolveCallback);\n        return;\n      }\n\n      if (this.throttledSavePending) {\n        this.throttledCallbacks.push(resolveCallback);\n        return;\n      }\n\n      const localCallbacks = this.throttledCallbacks;\n      this.throttledCallbacks = [];\n      localCallbacks.unshift(resolveCallback);\n      this.throttledSavePending = true;\n\n      const self = this;\n      this.saveDatabaseInternal((err) => {\n        self.throttledSavePending = false;\n        localCallbacks.forEach((pcb) => {\n          if (typeof pcb === \"function\") {\n            // Queue the callbacks so we first finish this method execution\n            setTimeout(() => {\n              pcb(err);\n            }, 1);\n          }\n        });\n\n        // since this is called async, future requests may have come in, if so.. kick off next save\n        if (self.throttledCallbacks.length > 0) {\n          self.saveDatabase();\n        }\n      });\n    });\n  }\n\n  /**\n   * Handles deleting a database from file system, local\n   *    storage, or adapter (indexeddb)\n   *    This method utilizes loki configuration options (if provided) to determine which\n   *    persistence method to use, or environment detection (if configuration was not provided).\n   *\n   * @param {function=} callback - (Optional) user supplied async callback / error handler\n   * @memberof Loki\n   */\n  deleteDatabase(\n    callback?: (\n      _: Error | { success: true } | { success: false; error: Error },\n    ) => void,\n  ) {\n    const cFun =\n      callback ||\n      ((err) => {\n        if (err) {\n          throw err;\n        }\n      });\n\n    // the persistenceAdapter should be present if all is ok, but check to be sure.\n    if (this.persistenceAdapter !== null) {\n      const afterDeleteCallback = (err) => {\n        cFun(err);\n      };\n      if (\"isAsync\" in this.persistenceAdapter) {\n        this.persistenceAdapter\n          .deleteDatabaseAsync(this.filename)\n          .then(() => {\n            afterDeleteCallback({ success: true });\n          })\n          .catch((err) => {\n            afterDeleteCallback(err);\n          });\n      } else {\n        this.persistenceAdapter.deleteDatabase(\n          this.filename,\n          afterDeleteCallback,\n        );\n      }\n    } else {\n      cFun(new Error(\"persistenceAdapter not configured\"));\n    }\n  }\n\n  async deleteDatabaseAsync(): Promise<{ success: true }> {\n    return new Promise((resolve, reject) => {\n      const afterDeleteCallback = (\n        res: Error | { success: true } | { success: false; error: Error },\n      ) => {\n        if (res instanceof Error) {\n          reject(res);\n        } else if ((res as { success: true })?.success) {\n          resolve(res as { success: true });\n        } else {\n          reject(res);\n        }\n      };\n      if (this.persistenceAdapter !== null) {\n        if (\"isAsync\" in this.persistenceAdapter) {\n          this.persistenceAdapter\n            .deleteDatabaseAsync(this.filename)\n            .then(() => {\n              afterDeleteCallback({ success: true });\n            })\n            .catch((err) => {\n              afterDeleteCallback(err);\n            });\n        } else {\n          this.persistenceAdapter.deleteDatabase(\n            this.filename,\n            afterDeleteCallback,\n          );\n        }\n      } else {\n        reject(new Error(\"persistenceAdapter not configured\"));\n      }\n    });\n  }\n\n  /**\n   * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n   *\n   * @returns {boolean} - true if database has changed since last autosave, false if not.\n   */\n  autosaveDirty() {\n    for (let idx = 0; idx < this.collections.length; idx++) {\n      if (this.collections[idx].dirty) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * autosaveClearFlags - resets dirty flags on all collections.\n   *    Called from saveDatabase() after db is saved.\n   *\n   */\n  autosaveClearFlags() {\n    for (let idx = 0; idx < this.collections.length; idx++) {\n      this.collections[idx].dirty = false;\n    }\n  }\n\n  /**\n   * autosaveEnable - begin a javascript interval to periodically save the database.\n   *\n   * @param {object} options - not currently used (remove or allow overrides?)\n   * @param {function=} callback - (Optional) user supplied async callback\n   */\n  autosaveEnable(options?: Record<string, any>, callback?: () => any) {\n    this.autosave = true;\n\n    let delay = 5000;\n    const self = this;\n\n    if (\n      typeof this.autosaveInterval !== \"undefined\" &&\n      this.autosaveInterval !== null\n    ) {\n      delay = this.autosaveInterval;\n    }\n\n    this.autosaveHandle = setInterval(function autosaveHandleInterval() {\n      // use of dirty flag will need to be hierarchical since mods are done at collection level with no visibility of 'db'\n      // so next step will be to implement collection level dirty flags set on insert/update/remove\n      // along with loki level isdirty() function which iterates all collections to see if any are dirty\n\n      if (self.autosaveDirty() && !self.ignoreAutosave) {\n        self.saveDatabase(callback);\n      }\n    }, delay);\n  }\n\n  /**\n   * autosaveDisable - stop the autosave interval timer.\n   *\n   */\n  autosaveDisable() {\n    if (\n      typeof this.autosaveHandle !== \"undefined\" &&\n      this.autosaveHandle !== null\n    ) {\n      clearInterval(this.autosaveHandle);\n      this.autosaveHandle = null;\n    }\n  }\n}\n\n// alias of serialize\nSylvie.prototype.toJson = Sylvie.prototype.serialize;\n\n// alias\nSylvie.prototype.save = Sylvie.prototype.saveDatabase;\n\nSylvie.deepFreeze = deepFreeze;\nSylvie.freeze = freeze;\nSylvie.unFreeze = unFreeze;\nSylvie.LokiOps = LokiOps;\nSylvie.Collection = Collection;\nSylvie.DynamicView = DynamicView;\nSylvie.Resultset = ResultSet;\nSylvie.KeyValueStore = KeyValueStore;\nSylvie.LokiMemoryAdapter = MemoryAdapter;\nSylvie.LokiPartitioningAdapter = PartitioningAdapter;\nSylvie.LokiLocalStorageAdapter = LocalStorageAdapter;\nSylvie.LokiFsAdapter = FsAdapter;\nSylvie.persistenceAdapters = {\n  fs: FsAdapter,\n  localStorage: LocalStorageAdapter,\n};\nSylvie.aeq = aeqHelper;\nSylvie.lt = ltHelper;\nSylvie.gt = gtHelper;\nSylvie.Comparators = Comparators;\n", "/* eslint-disable @typescript-eslint/no-this-alias */\n/* eslint-disable no-prototype-builtins */\n\n\"use strict\";\n\nimport Sylvie from \"./modules/sylvie\";\n\nexport const hasOwnProperty = Object.prototype.hasOwnProperty;\n\nif (typeof window !== \"undefined\") {\n  Object.assign(window, { loki: Sylvie, Sylvie: Sylvie });\n}\n\nexport default Sylvie;\n"],
  "mappings": "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",
  "names": ["indexeddb_adapter_exports", "DEBUG", "IndexedDBAdapter", "SylvieCatalog", "init_indexeddb_adapter", "__esmMin", "appname", "options", "dbname", "callback", "appName", "adapter", "catalog", "id", "val", "dbstring", "saveCallback", "result", "__name", "self", "str", "cat", "results", "names", "idx", "obj", "entries", "size", "oapp", "okey", "oval", "openRequest", "target", "thisDB", "objectStore", "e", "app", "key", "index", "appkey", "request", "usercallback", "lres", "data", "store", "res", "requestPut", "evt", "singleKeyRange", "cursor", "localdata", "currObject", "FsAdapter", "e", "dbname", "callback", "self", "err", "stats", "__name", "data", "dbstring", "tmpdbname", "deepProperty", "obj", "property", "isDeep", "pieces", "root", "__name", "cloneObjectArray", "objarray", "method", "clone", "result", "i", "len", "__name", "clone", "data", "method", "cloneMethod", "cloned", "i", "keys", "key", "cloneObjectArray", "__name", "freeze", "obj", "__name", "deepFreeze", "prop", "i", "unFreeze", "clone", "utils_exports", "__export", "copyProperties", "getIn", "resolveTransformObject", "resolveTransformParams", "copyProperties", "__name", "src", "dest", "prop", "resolveTransformObject", "subObj", "params", "depth", "pname", "utils_exports", "resolveTransformParams", "transform", "idx", "clonedStep", "resolvedTransform", "clone", "getIn", "object", "path", "usingDotNotation", "index", "length", "isDeepProperty", "field", "__name", "add", "b", "sub", "average", "array", "standardDeviation", "values", "avg", "squareDiffs", "value", "diff", "avgSquareDiff", "containsCheckFn", "b", "__name", "dotSubScan", "root", "paths", "fun", "value", "extra", "poffset", "pathOffset", "path", "valueFound", "element", "index", "len", "__name", "Comparators", "aeqHelper", "ltHelper", "gtHelper", "prop1", "prop2", "cv1", "cv2", "t1", "t2", "__name", "equal", "sortHelper", "desc", "compoundeval", "properties", "obj1", "obj2", "res", "prop", "field", "val1", "val2", "arr", "i", "len", "utils_exports", "doQueryOp", "val", "op", "record", "p", "LokiOps", "__name", "b", "Comparators", "vals", "checkFn", "containsCheckFn", "item", "property", "filter", "dotSubScan", "type", "idx", "len", "valueLevelOps", "fun", "a", "spec", "indexedOps", "precompileQuery", "operator", "value", "key", "__name", "ResultSet", "collection", "options", "copy", "qty", "rscopy", "pos", "result", "transform", "parameters", "idx", "step", "rs", "utils_exports", "comparefun", "wrappedComparer", "userComparer", "data", "a", "b", "propname", "eff", "targetEff", "dc", "frl", "hasBinaryIndex", "fr", "io", "pv", "n", "obj1", "obj2", "prop", "desc", "val1", "val2", "arr", "sortHelper", "properties", "len", "props", "compoundeval", "expressionArray", "fri", "frlen", "docset", "idxset", "ei", "elen", "i", "query", "firstOnly", "queryObject", "p", "property", "queryObjectOp", "obj", "operator", "value", "key", "searchByIndex", "filters", "index", "hasOwnProperty", "precompileQuery", "usingDotNotation", "indexedOps", "fun", "LokiOps", "t", "filter", "rowIdx", "record", "propertyArr", "dotSubScan", "segm", "viewFunction", "j", "k", "updateFunction", "rcd", "clone", "mapFunction", "reduceFunction", "joinData", "leftJoinKey", "rightJoinKey", "mapFun", "dataOptions", "leftData", "rightData", "leftKeyisFunction", "rightKeyisFunction", "joinMap", "leftDataLength", "Collection", "x", "rightDataLength", "__name", "left", "right", "method", "SylvieEventEmitter", "eventName", "listener", "event", "self", "currentEventName", "data", "arg", "selfArgs", "listeners", "__name", "DynamicView", "SylvieEventEmitter", "collection", "name", "options", "ResultSet", "fpl", "fpi", "idx", "wasFrozen", "ofp", "transform", "parameters", "rs", "copy", "filterChanged", "comparefun", "propname", "deepFreeze", "criteria", "uid", "len", "filter", "filters", "freeze", "query", "fun", "self", "objIndex", "isNew", "ofr", "oldPos", "oldlen", "evalResultset", "newPos", "rmidx", "rxo", "fxo", "adjels", "drs", "fr", "frlen", "rmlen", "di", "obj", "filt", "__name", "mapFunction", "reduceFunction", "_index", "ExactIndex", "exactField", "__privateAdd", "__privateSet", "key", "val", "__privateGet", "idxSet", "indexKey", "__name", "UniqueIndex", "uniqueField", "obj", "fieldValue", "key", "id", "doc", "old", "__name", "parseBase10", "num", "__name", "Collection", "SylvieEventEmitter", "name", "options", "__name", "query", "clone", "idx", "mapFunction", "reduceFunction", "message", "self", "prop", "ExactIndex", "indices", "observerCallback", "changes", "changedObjects", "object", "hasOwnProperty", "err", "getChangeDelta", "obj", "old", "getObjectDelta", "oldObject", "newObject", "propertyNames", "delta", "i", "propertyName", "propertyDelta", "flushChanges", "enabled", "warning", "op", "len", "unFreeze", "transform", "template", "collection", "age", "now", "member", "timestamp", "diff", "interval", "indexes", "property", "force", "index", "wrappedComparer", "data", "val1", "val2", "propPath", "a", "b", "utils_exports", "Comparators", "key", "bIndices", "results", "result", "valid", "iter", "pos", "biv", "usingDotNotation", "LokiOps", "idxvals", "field", "UniqueIndex", "callback", "dv", "DynamicView", "filterObject", "updateFunction", "doc", "overrideAdaptiveIndices", "adaptiveBatchOverride", "bulkInsert", "deepFreeze", "returnObj", "biname", "k", "arr", "newInternal", "oldInternal", "position", "newId", "addedPos", "dvlen", "filterFunction", "list", "positions", "xo", "dlen", "didx", "bic", "uic", "adaptiveOverride", "$loki", "id", "batch", "xlt", "posx", "docOrId", "freeze", "returnPosition", "retpos", "max", "min", "mid", "dataPosition", "binaryIndexName", "val", "range", "idxPos", "removedFromIndexOnly", "bi", "rmidx", "rmlen", "rxo", "curr", "shift", "di", "sortedPositions", "adaptive", "rcd", "lbound", "ubound", "lval", "uval", "minVal", "maxVal", "idxset", "segResult", "j", "seg", "value", "parameters", "rs", "ResultSet", "fun", "joinData", "leftJoinProp", "rightJoinProp", "mapFun", "dataOptions", "stageName", "copy", "stage", "isDotNotation", "isDeepProperty", "deepProperty", "deep", "parseBase10", "n", "average", "standardDeviation", "dict", "mode", "values", "sub", "half", "binarySearch", "array", "item", "fun", "lo", "hi", "compared", "mid", "__name", "BSonSort", "KeyValueStore", "__name", "b", "fun", "BSonSort", "key", "value", "pos", "binarySearch", "localStorageAvailable", "e", "__name", "LocalStorageAdapter", "dbname", "callback", "localStorageAvailable", "dbstring", "__name", "MemoryAdapter", "options", "dbname", "callback", "self", "dbstring", "saveCount", "__name", "PartitioningAdapter", "adapter", "options", "__name", "dbname", "callback", "self", "Sylvie", "result", "db", "partition", "keyname", "data", "dlen", "idx", "isLastPage", "dbref", "clen", "err", "coll", "pageLen", "cdlen", "delimlen", "serializedObject", "pageBuilder", "doneWithPartition", "doneWithPage", "pageSaveCallback", "completed", "Sylvie", "SylvieEventEmitter", "filename", "options", "__name", "callback", "cFun", "err", "handleValidDbString", "dbString", "parseSuccess", "handleLoadError", "loadDatabaseCallback", "dbstring", "error", "getENV", "adapter", "__require", "initialConfig", "defaultPersistence", "persistenceMethods", "FsAdapter", "LocalStorageAdapter", "MemoryAdapter", "self", "databaseCopy", "clen", "idx", "name", "len", "collection", "Collection", "collectionName", "i", "oldName", "newName", "c", "colls", "tmpcol", "curcol", "prop", "key", "value", "sidx", "result", "resultlen", "reconstruct", "dbcopy", "docidx", "resultlines", "doccount", "destructuredSource", "workarray", "cdb", "collIndex", "collCount", "lineIndex", "done", "currLine", "currObject", "serializedDb", "dbObject", "coll", "copyColl", "j", "loader", "collObj", "makeLoader", "collOptions", "inflater", "utils_exports", "data", "deepFreeze", "colldv", "dv", "__async", "arrayOfCollectionNames", "getCollName", "changes", "selectedCollections", "collectionNamesArray", "collectionString", "now", "success", "resolve", "reject", "resolveCallback", "_", "rejectCallback", "cachedDirty", "lokiCopy", "dirty", "dirtyIds", "col", "cached", "afterSaveCallback", "localCallbacks", "pcb", "afterDeleteCallback", "res", "delay", "freeze", "unFreeze", "LokiOps", "DynamicView", "ResultSet", "KeyValueStore", "PartitioningAdapter", "aeqHelper", "ltHelper", "gtHelper", "Comparators", "hasOwnProperty", "Sylvie", "sylviejs_default"]
}
