{
  "version": 3,
  "sources": ["../../src/storage-adapter/src/indexeddb-adapter/idb-catalog.ts", "../../src/storage-adapter/indexeddb-adapter.ts"],
  "sourcesContent": ["import { ResultType } from \"../models/result-type\";\n\n/**\n * IDBCatalog - underlying App/Key/Value catalog persistence\n *    This non-interface class implements the actual persistence\n *    using IndexedDBAdapter.\n */\nexport class IDBCatalog {\n  db?: IDBDatabase;\n  constructor() {\n    this.db = null;\n  }\n\n  /**\n   * Asynchronously initializes the catalog the database after creation. Must be run after the database is constructed but before using the database.\n   */\n  initialize(): Promise<IDBCatalog> {\n    return new Promise((resolve, reject) => {\n      this.#initializeCatalog()\n        .then((res) => {\n          resolve(res);\n        })\n        .catch((err) => {\n          console.log(err);\n          reject(err);\n        });\n    });\n  }\n\n  #openCatalog() {\n    const openRequest = indexedDB.open(\"IDBCatalog\", 1);\n\n    openRequest.onupgradeneeded = ({ target }) => {\n      const thisDB = (target as any).result;\n      if (thisDB.objectStoreNames.contains(\"IDBAKV\")) {\n        thisDB.deleteObjectStore(\"IDBAKV\");\n      }\n\n      if (!thisDB.objectStoreNames.contains(\"IDBAKV\")) {\n        const objectStore = thisDB.createObjectStore(\"IDBAKV\", {\n          keyPath: \"id\",\n          autoIncrement: true,\n        });\n        objectStore.createIndex(\"app\", \"app\", { unique: false });\n        objectStore.createIndex(\"key\", \"key\", { unique: false });\n        objectStore.createIndex(\"appkey\", \"appkey\", { unique: true });\n      }\n    };\n\n    return openRequest;\n  }\n\n  #initializeCatalog = async (): Promise<IDBCatalog> => {\n    const openRequest = this.#openCatalog();\n\n    return new Promise((resolve, reject) => {\n      openRequest.onsuccess = ({ target }) => {\n        this.db = (target as any).result;\n        resolve(this);\n      };\n\n      openRequest.onerror = (e) => {\n        reject(e);\n      };\n    });\n  };\n\n  async getAppKeyAsync(\n    app,\n    key,\n  ): Promise<\n    | {\n        app: string;\n        appkey: string;\n        id: number;\n        key: string;\n        val: string;\n      }\n    | {\n        id: 0;\n        success: false;\n      }\n  > {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"appkey\");\n    const appkey = `${app},${key}`;\n    const request = index.get(appkey);\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = ({ target }) => {\n        let lres = (target as any).result;\n\n        if (lres === null || typeof lres === \"undefined\") {\n          lres = {\n            id: 0,\n            success: false,\n          };\n        }\n\n        resolve(lres);\n      };\n\n      request.onerror = (e) => {\n        reject(e);\n      };\n    });\n  }\n\n  async setAppKeyAsync(app, key, val): Promise<ResultType> {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readwrite\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"appkey\");\n    const appkey = `${app},${key}`;\n    const request = index.get(appkey);\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = ({ target }) => {\n        let res = (target as any).result;\n\n        if (res === null || res === undefined) {\n          res = {\n            app,\n            key,\n            appkey: `${app},${key}`,\n            val,\n          };\n        } else {\n          res.val = val;\n        }\n\n        const requestPut = store.put(res);\n\n        requestPut.onerror = () => {\n          reject({ success: false, error: requestPut.error });\n          console.error(\"IDBCatalog.setAppKey (set) onerror\");\n          console.error(request.error);\n        };\n\n        requestPut.onsuccess = () => {\n          resolve({ success: true });\n        };\n      };\n\n      request.onerror = () => {\n        reject({ success: false, error: request.error });\n        console.error(\"IDBCatalog.setAppKey (get) onerror\");\n        console.error(request.error);\n      };\n    });\n  }\n\n  deleteAppKeyAsync(id): Promise<ResultType> {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readwrite\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const request = store.delete(id);\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        resolve({ success: true });\n      };\n\n      request.onerror = (e) => {\n        reject({ success: false, error: e });\n        console.error(\"IDBCatalog.deleteAppKey raised onerror\");\n        console.error(request.error);\n      };\n    });\n  }\n\n  async getAppKeysAsync(app): Promise<{ key: string }[]> {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"app\");\n\n    // We want cursor to all values matching our (single) app param\n    const singleKeyRange = IDBKeyRange.only(app);\n\n    // To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n    const cursor = index.openCursor(singleKeyRange);\n\n    // cursor internally, pushing results into this.data[] and return\n    // this.data[] when done (similar to service)\n    const localdata = [];\n\n    return new Promise((resolve, reject) => {\n      cursor.onsuccess = () => {\n        const cur = cursor.result;\n        if (cur) {\n          const currObject = cur.value;\n\n          localdata.push(currObject);\n\n          cur.continue();\n        } else {\n          resolve(localdata);\n        }\n      };\n\n      cursor.onerror = (e) => {\n        reject(e);\n      };\n    });\n  }\n\n  // Hide 'cursoring' and return array of { id: id, key: key }\n  getAllKeys(callback) {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const cursor = store.openCursor();\n\n    const localdata = [];\n\n    cursor.onsuccess = (\n      (data, callback) =>\n      ({ target }) => {\n        const cursor = (target as any).result;\n        if (cursor) {\n          const currObject = cursor.value;\n\n          data.push(currObject);\n\n          cursor.continue();\n        } else {\n          if (typeof callback === \"function\") {\n            callback(data);\n          } else {\n            console.log(data);\n          }\n        }\n      }\n    )(localdata, callback);\n\n    cursor.onerror = ((usercallback) => (e) => {\n      if (typeof usercallback === \"function\") usercallback(null);\n    })(callback);\n  }\n}\n", "/**\n  Sylvie IndexedDb Adapter (need to include this script to use it)\n*/\nimport { IDBCatalog } from \"./src/indexeddb-adapter/idb-catalog\";\nimport { NormalPersistenceAdapter } from \"./src/models/persistence-adapter\";\nimport { NormalAsyncPersistenceAdapter } from \"./src/models/async-persistence-adapter\";\n\n// @ts-ignore\nconst DEBUG = typeof window !== \"undefined\" && !!window.__loki_idb_debug;\n\nif (DEBUG) {\n  console.log(\"DEBUG: Running indexeddb-adapter in DEBUG mode\");\n}\n\ntype IndexedDBAdapterOptions = {\n  // (Optional) Application name context can be used to distinguish subdomains, 'sylvie' by default\n  appname: string;\n  // Whether the indexedDB database should be closed after saving.\n  closeAfterSave: boolean;\n  /**\n   * An optional function hook that is called before the database is written to IndexedDB. Use this to modify the raw string before it is written to disk. If you use this, you must also pass beforeRead.\n   * @param databaseSerialized - The serialized string dump from Sylvie.\n   * @returns The raw string to be written to IndexedDB.\n   */\n  beforeWriteToIDB: (databaseSerialized: string) => Promise<string>;\n  /**\n   *  An optional function hook that is called after the database is read from IndexedDB but before it is loaded into Sylvie. Use this to deserialize the string if you used the beforeWrite hook.\n   * @param rawString The raw string read from IndexedDB.\n   * @returns The deserialized string to be loaded into Sylvie.\n   */\n  beforeReadFromIDB: (rawString: string) => Promise<string>;\n};\n\n/**\n * Loki/Sylvie encrypted persistence adapter class for indexedDb.\n *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n *     Utilizes the included SylvieCatalog app/key/value database for actual database persistence.\n *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n *     allow separate contexts for separate apps within a domain.\n *\n * @example\n * var idbAdapter = new IndexedDBAdapter('finance');\n *\n */\nexport class IndexedDBAdapter\n  implements NormalPersistenceAdapter, NormalAsyncPersistenceAdapter\n{\n  isAsync: true;\n  app: string;\n  options: Partial<IndexedDBAdapterOptions>;\n  catalog: IDBCatalog;\n  mode: \"normal\";\n\n  /**\n   * Create a IndexedDBAdapter.\n   * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, 'sylvie' by default\n   * @param {object=} options - (Optional) configuration options for adapter\n   * @param {boolean} [options.closeAfterSave=false] - (Optional) whether the indexedDB database should be closed after saving.\n   * @param {function} [options.beforeWriteToIDB] - (Optional) an optional function hook that is called before the database is written to IndexedDB. Use this to modify the raw string before it is written to disk. If you use this, you must also pass beforeRead.\n   * @param {function} [options.beforeReadFromIDB] - (Optional) an optional function hook that is called after the database is read from IndexedDB but before it is loaded into Sylvie. Use this to deserialize the string if you used the beforeWrite hook.\n   */\n  constructor(options?: Partial<IndexedDBAdapterOptions>) {\n    DEBUG && console.log(\"Initialized crypted-indexeddb-adapter\");\n    this.app = \"sylvie\";\n    this.options = options || {};\n\n    if (typeof options?.appname !== \"undefined\") {\n      this.app = options?.appname;\n    }\n\n    // keep reference to catalog class for base AKV operations\n    this.catalog = null;\n\n    if (!this.#checkIDBAvailability()) {\n      throw new Error(\n        \"IndexedDB does not seem to be supported for your environment\",\n      );\n    }\n  }\n\n  /**\n   * Used for closing the indexeddb database.\n   */\n  #closeDatabase = () => {\n    if (this.catalog && this.catalog.db) {\n      this.catalog.db.close();\n      this.catalog.db = null;\n    }\n  };\n\n  /**\n   * Used to check if adapter is available\n   *\n   * @returns {boolean} true if indexeddb is available, false if not.\n   */\n  #checkIDBAvailability(): boolean {\n    if (typeof indexedDB !== \"undefined\" && indexedDB) return true;\n    return false;\n  }\n\n  /**\n   * Retrieves a serialized db string from the catalog.\n   *\n   * @example\n   * // LOAD\n   * var idbAdapter = new SylvieIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   *   db.loadDatabase(function(result) {\n   *   console.log('done');\n   * });\n   *\n   * @param {string} dbname - the name of the database to retrieve.\n   * @param {function} callback - callback should accept string param containing serialized db string.\n   */\n  loadDatabase = (\n    dbname: string,\n    callback: (serialized: string | null) => void,\n  ): void => {\n    DEBUG && console.debug(\"loading database\");\n\n    // lazy open/create db reference so dont -need- callback in constructor\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog().initialize().then((catalog) => {\n        this.catalog = catalog;\n        this.loadDatabase(dbname, callback);\n        return;\n      });\n      return;\n    }\n\n    // lookup up dbstring in AKV db\n    this.catalog\n      .getAppKeyAsync(this.app, dbname)\n      .then((props) => {\n        const { success } = props as { success: boolean };\n        if (success === false) {\n          callback(null);\n        } else {\n          const { val: unserializedString } = props as { val: string };\n          if (this.options.beforeReadFromIDB) {\n            this.options\n              .beforeReadFromIDB(unserializedString)\n              .then((deserializedString) => {\n                DEBUG &&\n                  console.debug(`DESERIALIZED STRING: ${deserializedString}`);\n                callback(deserializedString);\n              })\n              .catch((err) => {\n                console.error(err);\n                callback(err);\n              });\n          } else {\n            callback(unserializedString);\n          }\n        }\n      })\n      .catch((err) => {\n        console.error(err);\n        callback(err);\n      });\n  };\n\n  /**\n   * Retrieves a serialized db string from the catalog, returns a promise to a string of the serialized database.\n   * @param dbname\n   * @returns {Promise<string>} A promise to a string of the serialized database.\n   * @example\n   * const db = new Sylvie(TEST_DB_NAME, {\n   *  adapter: new IndexedDBAdapter();\n   * });\n   * await db.loadDatabaseAsync({});\n   * // db is now ready to use\n   * // you can also chain the promises\n   * await db.loadDatabaseAsync({}).then(() => {\n   * // db is now ready to use\n   * });\n   * // or use async await syntax\n   * await db.loadDatabaseAsync({});\n   * // db is now ready to use\n   * @memberof IndexedDBAdapter\n   * @throws {Error} If the database is not found.\n   * @throws {Error} If the database is not decrypted successfully.\n   * @throws {Error} If the database is not deserialized successfully.\n   */\n  loadDatabaseAsync = async (dbname: string): Promise<string> => {\n    DEBUG && console.debug(\"loading database\");\n\n    return new Promise((resolve, reject) => {\n      const doLoad = () =>\n        this.catalog.getAppKeyAsync(this.app, dbname).then((props) => {\n          const { success } = props as { success: boolean };\n          if (success === false) {\n            reject(null);\n          } else {\n            const { val } = props as { val: string };\n            const unserializedString = val;\n            if (this.options.beforeReadFromIDB) {\n              this.options\n                .beforeReadFromIDB(unserializedString)\n                .then((deserializedString) => {\n                  DEBUG &&\n                    console.debug(`DESERIALIZED STRING: ${deserializedString}`);\n                  resolve(deserializedString);\n                })\n                .catch((err) => {\n                  reject(err);\n                });\n            } else {\n              resolve(unserializedString);\n            }\n          }\n        });\n\n      // lazy open/create db reference so dont -need- callback in constructor\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            doLoad();\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog was already initialized, so just lookup object and delete by id\n        doLoad();\n      }\n    });\n  };\n\n  /**\n   * Saves a serialized db to the catalog.\n   *\n   * @example\n   * // SAVE : will save App/Key/Val as 'finance'/'test'/{serializedDb}\n   * var idbAdapter = new SylvieIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   * var coll = db.addCollection('testColl');\n   * coll.insert({test: 'val'});\n   * db.saveDatabase();  // could pass callback if needed for async complete\n   *\n   * @param {string} dbname - the name to give the serialized database within the catalog.\n   * @param {string} dbstring - the serialized db string to save.\n   * @param {function} callback - (Optional) callback passed obj.success with true or false\n   */\n  saveDatabase = (\n    dbname: string,\n    dbstring: string,\n    callback?: (\n      err: Error | { success: true } | { success: false; error: Error },\n    ) => void,\n  ) => {\n    DEBUG &&\n      console.debug(`in saveDatabase(${dbname}, ${dbstring}, ${callback})`);\n\n    const doSave = () => {\n      if (this.options.beforeWriteToIDB) {\n        this.options\n          .beforeWriteToIDB(dbstring)\n          .then((serializedString) => {\n            // lazy open/create db reference so dont -need- callback in constructor\n            DEBUG && console.debug(`SERIALIZED STRING: ${serializedString}`);\n            // set (add/update) entry to AKV database\n            this.catalog\n              .setAppKeyAsync(this.app, dbname, serializedString)\n              .then((res) => {\n                callback(res);\n              })\n              .catch((err) => {\n                callback(err);\n              });\n          })\n          .catch((err) => {\n            callback(err);\n          });\n      } else {\n        DEBUG && console.debug(`SERIALIZED STRING: ${dbstring}`);\n        this.catalog\n          .setAppKeyAsync(this.app, dbname, dbstring)\n          .then((res) => {\n            callback(res);\n          })\n          .catch((err) => {\n            callback(err);\n          });\n      }\n    };\n\n    if (this.catalog === null || this.catalog.db === null) {\n      // catalog not initialized yet\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.saveDatabaseAsync(dbname, dbstring)\n            .then(() => {\n              callback(undefined);\n            })\n            .catch((err) => {\n              callback(new Error(\"Error saving database: \" + err));\n            })\n            .finally(() => {\n              if (this.options.closeAfterSave === true) {\n                this.#closeDatabase();\n              }\n            });\n        })\n        .catch((err) => {\n          callback(new Error(\"Error saving database: \" + err));\n        });\n    } else {\n      // catalog was already initialized, so just lookup object and delete by id\n      doSave();\n    }\n  };\n\n  async saveDatabaseAsync(dbname: string, dbstring: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const doSave = () => {\n        if (this.options.beforeWriteToIDB) {\n          this.options\n            .beforeWriteToIDB(dbstring)\n            .then((encryptedDbString) => {\n              // lazy open/create db reference so dont -need- callback in constructor\n              DEBUG && console.debug(`ENCRYPTED STRING: ${encryptedDbString}`);\n              // set (add/update) entry to AKV database\n              this.catalog\n                .setAppKeyAsync(this.app, dbname, encryptedDbString)\n                .then((res) => {\n                  if (res.success === true) {\n                    resolve();\n                  } else {\n                    reject(res);\n                  }\n                })\n                .catch((err) => {\n                  reject(err);\n                });\n            })\n            .catch((err) => {\n              reject(err);\n            });\n        } else {\n          DEBUG && console.debug(`SERIALIZED STRING: ${dbstring}`);\n          this.catalog\n            .setAppKeyAsync(this.app, dbname, dbstring)\n            .then((res) => {\n              if (res.success === true) {\n                resolve();\n              } else {\n                reject(res);\n              }\n            })\n            .catch((err) => {\n              reject(err);\n            });\n        }\n      };\n\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            // Now that catalog is initialized, try again\n            this.saveDatabaseAsync(dbname, dbstring)\n              .then(resolve)\n              .catch((error) => {\n                reject(new Error(\"Error saving database: \" + error));\n              })\n              .finally(() => {\n                if (this.options.closeAfterSave === true) {\n                  this.#closeDatabase();\n                }\n              });\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog was already initialized, so just lookup object and delete by id\n        doSave();\n      }\n    });\n  }\n\n  /**\n   * Deletes a serialized db from the catalog.\n   *\n   * @example\n   * // DELETE DATABASE\n   * // delete 'finance'/'test' value from catalog\n   * idbAdapter.deleteDatabase('test', function {\n   *   // database deleted\n   * });\n   *\n   * @param {string} dbname - the name of the database to delete from the catalog.\n   * @param {function=} callback - (Optional) executed on database delete\n   * @memberof SylvieIndexedAdapter\n   */\n  deleteDatabase = (\n    dbname: string,\n    callback?: (\n      _: Error | { success: true } | { success: false; error: Error },\n    ) => any,\n  ) => {\n    // lazy open/create db reference and pass callback ahead\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.deleteDatabase(dbname, callback);\n        })\n        .catch((err) => {\n          callback(new Error(\"Error deleting database: \" + err));\n        });\n\n      return;\n    }\n\n    // catalog was already initialized, so just lookup object and delete by id\n    this.catalog\n      .getAppKeyAsync(this.app, dbname)\n      .then((result) => {\n        const id = result.id;\n        if (id !== 0) {\n          this.catalog\n            .deleteAppKeyAsync(id)\n            .then((res) => {\n              if (typeof callback === \"function\") {\n                callback(res);\n              }\n            })\n            .catch((err) => {\n              if (typeof callback === \"function\") {\n                callback({ success: false, error: err });\n              }\n            });\n        }\n      })\n      .catch((err) => {\n        if (typeof callback === \"function\") {\n          callback({ success: false, error: err });\n        }\n      });\n  };\n\n  async deleteDatabaseAsync(dbname: string): Promise<void> {\n    // lazy open/create db reference and pass callback ahead\n    return new Promise((resolve, reject) => {\n      const doDelete = () =>\n        this.catalog\n          .getAppKeyAsync(this.app, dbname)\n          .then((result) => {\n            const id = result.id;\n            if (id !== 0) {\n              this.catalog\n                .deleteAppKeyAsync(id)\n                .then((res) => {\n                  if (res.success === true) {\n                    resolve();\n                  } else {\n                    reject(res);\n                  }\n                })\n                .catch((err) => {\n                  reject(err);\n                });\n            }\n          })\n          .catch((err) => {\n            reject(err);\n          });\n\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            doDelete();\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog was already initialized, so just lookup object and delete by id\n        doDelete();\n      }\n    });\n  }\n\n  /**\n   * Removes all database partitions and pages with the base filename passed in.\n   * This utility method does not (yet) guarantee async deletions will be completed before returning\n   *\n   * @param {string} dbname - the base filename which container, partitions, or pages are derived\n   * @memberof SylvieIndexedAdapter\n   */\n  deleteDatabasePartitions = (dbname) => {\n    this.getDatabaseList((result) => {\n      if (result instanceof Error) {\n        throw result;\n      }\n      result.forEach((str) => {\n        if (str.startsWith(dbname)) {\n          this.deleteDatabase(str);\n        }\n      });\n    });\n  };\n\n  /**\n   * Retrieves object array of catalog entries for current app.\n   *\n   * @example\n   * idbAdapter.getDatabaseList(function(result) {\n   *   // result is array of string names for that appcontext ('finance')\n   *   result.forEach(function(str) {\n   *     console.log(str);\n   *   });\n   * });\n   *\n   * @param {function} callback - should accept array of database names in the catalog for current app.\n   * @memberof SylvieIndexedAdapter\n   */\n  getDatabaseList = (callback: (_: string[] | Error) => void) => {\n    // lazy open/create db reference so dont -need- callback in constructor\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.getDatabaseList(callback);\n        })\n        .catch((err) => {\n          callback(new Error(\"Error getting database list: \" + err));\n        });\n\n      return;\n    }\n\n    // catalog already initialized\n    // get all keys for current appName, and transpose results so just string array\n    this.catalog\n      .getAppKeysAsync(this.app)\n      .then((results) => {\n        const names = [];\n\n        for (let idx = 0; idx < results.length; idx++) {\n          names.push(results[idx].key);\n        }\n\n        if (typeof callback === \"function\") {\n          callback(names);\n        }\n      })\n      .catch((err) => {\n        callback(err);\n      });\n  };\n\n  getDatabaseListAsync = (): Promise<string[]> => {\n    return new Promise((resolve, reject) => {\n      // lazy open/create db reference\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            this.catalog\n              .getAppKeysAsync(this.app)\n              .then((results) => {\n                const names: string[] = results.map((result) => result.key);\n                resolve(names);\n              })\n              .catch((err) => {\n                reject(err);\n              });\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog already initialized\n        // get all keys for current appName, and transpose results so just string array\n        this.catalog\n          .getAppKeysAsync(this.app)\n          .then((results) => {\n            const names: string[] = results.map((result) => result.key);\n            resolve(names);\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      }\n    });\n  };\n\n  /**\n   * Allows retrieval of list of all keys in catalog along with size\n   *\n   * @param {function} callback - (Optional) callback to accept result array.\n   * @memberof LokiIndexedAdapter\n   */\n  getCatalogSummary = (callback) => {\n    // lazy open/create db reference\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.getCatalogSummary(callback);\n        })\n        .catch((err) => {\n          callback(new Error(\"Error getting database list: \" + err));\n        });\n\n      return;\n    }\n\n    // catalog already initialized\n    // get all keys for current appName, and transpose results so just string array\n    this.catalog.getAllKeys((results) => {\n      const entries = [];\n      let obj;\n      let size;\n      let oapp;\n      let okey;\n      let oval;\n\n      for (let idx = 0; idx < results.length; idx++) {\n        obj = results[idx];\n        oapp = obj.app || \"\";\n        okey = obj.key || \"\";\n        oval = obj.val || \"\";\n\n        // app and key are composited into an appkey column so we will mult by 2\n        size = oapp.length * 2 + okey.length * 2 + oval.length + 1;\n\n        entries.push({ app: obj.app, key: obj.key, size: size });\n      }\n\n      if (typeof callback === \"function\") {\n        callback(entries);\n      }\n    });\n  };\n}\n\nif (typeof window !== \"undefined\") {\n  Object.assign(window, {\n    IndexedDBAdapter: IndexedDBAdapter,\n  });\n}\n"],
  "mappings": "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",
  "names": ["_openCatalog", "openCatalog_fn", "_initializeCatalog", "IDBCatalog", "__privateAdd", "__name", "__async", "openRequest", "__privateMethod", "resolve", "reject", "target", "e", "__privateGet", "res", "err", "app", "key", "index", "appkey", "request", "lres", "val", "store", "requestPut", "id", "singleKeyRange", "cursor", "localdata", "cur", "currObject", "callback", "data", "usercallback", "thisDB", "objectStore", "DEBUG", "_closeDatabase", "_checkIDBAvailability", "checkIDBAvailability_fn", "IndexedDBAdapter", "options", "__privateAdd", "__name", "dbname", "callback", "IDBCatalog", "catalog", "props", "success", "unserializedString", "deserializedString", "err", "__async", "resolve", "reject", "doLoad", "val", "dbstring", "doSave", "serializedString", "res", "__privateGet", "result", "id", "str", "results", "names", "idx", "entries", "obj", "size", "oapp", "okey", "oval", "__privateMethod", "encryptedDbString", "error", "doDelete"]
}
