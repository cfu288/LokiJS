var B=Object.defineProperty;var u=(a,e)=>B(a,"name",{value:e,configurable:!0});var g=typeof window!="undefined"&&!!window.__loki_incremental_idb_debug,w=class{constructor(e){this.mode="incremental",this.options=e||{},this.chunkSize=100,this.megachunkCount=this.options.megachunkCount||20,this.idb=null,this.idbActualLokiObjectStoreName=null,this.keyResolver=null,this._prevLokiVersionId=null,this._prevCollectionVersionIds={};let r=!!this.options.encrypt;if(r){if(r&&!this.options.decrypt)throw Error("encrypt was provided, but decrypt was not. You must pass both functions.");if(r&&!D(this.options.encrypt))throw Error("encrypt was provided, but it is not a function!");if(r&&!D(this.options.decrypt))throw Error("decrypt was provided, but it is not a function!");this.encrypt=L(this.options.encrypt,t=>`Error while invoking encrypt function. Supplied args: ${t}`),this.decrypt=L(this.options.decrypt,t=>`Error while invoking decrypt function. Is the data really encrypted? Supplied args: ${t}`),this._names={objectStoreName:"LID",lokiKeyName:"lk_____________",chunk:"ck",metadata:"md___"}}else this.encrypt=$,this.decrypt=$,this._names={objectStoreName:"LokiIncrementalData",lokiKeyName:"loki",chunk:"chunk",metadata:"metadata"};if(!(this.megachunkCount>=4&&this.megachunkCount%2===0))throw new Error("megachunkCount must be >=4 and divisible by 2")}_getChunk(e,r){let t=r*this.chunkSize,n=t+this.chunkSize-1;e.ensureId();let o=e.idIndex,i=null,l=o.length-1,k=0,p;for(;o[k]<o[l];)p=k+l>>1,o[p]<t?k=p+1:l=p;if(l===k&&o[k]>=t&&o[k]<=n&&(i=k),i===null)return[];let s=null;for(let d=i+this.chunkSize-1;d>=i;d--)if(o[d]<=n){s=d;break}let f=e.data[i];if(!(f&&f.$loki>=t&&f.$loki<=n))throw new Error("broken invariant firstelement");let h=e.data[s];if(!(h&&h.$loki>=t&&h.$loki<=n))throw new Error("broken invariant lastElement");let c=e.data.slice(i,s+1);if(c.length>this.chunkSize)throw new Error("broken invariant - chunk size");return c}saveDatabase(e,r,t){let n=this;if(!this.idb){this._initializeIDB(e,t,()=>{n.saveDatabase(e,r,t)});return}if(this.operationInProgress)throw new Error("Error while saving to database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0,g&&console.log("saveDatabase - begin"),g&&console.time("saveDatabase");function o(i){g&&i&&console.error(i),g&&console.timeEnd("saveDatabase"),n.operationInProgress=!1,t(i)}u(o,"finish");try{let i=u(()=>{console.error("Unexpected successful tx - cannot update previous version ids")},"updatePrevVersionIds"),l=!1,k=this.idb.transaction([n.idbActualLokiObjectStoreName],"readwrite");k.oncomplete=()=>{i(),o(),l&&n.options.onDidOverwrite&&n.options.onDidOverwrite()},k.onerror=c=>{o(c)},k.onabort=c=>{o(c)};let p=k.objectStore(n.idbActualLokiObjectStoreName),s=u(c=>{try{let d=!c,y=n._putInChunks(p,r(),d,c);i=u(()=>{n._prevLokiVersionId=y.lokiVersionId,y.collectionVersionIds.forEach(({name:C,versionId:m})=>{n._prevCollectionVersionIds[C]=m})},"updatePrevVersionIds"),k.commit&&k.commit()}catch(d){console.error("idb performSave failed: ",d),k.abort()}},"performSave"),f=u(()=>{b(p.getAllKeys(),({target:c})=>{let d=z(c.result,n.keyResolver);s(d)},c=>{console.error("Getting all keys failed: ",c),k.abort()})},"getAllKeysThenSave");u(()=>{b(p.get(n.keyResolver.actualLokiKey),({target:c})=>{R(c.result,n.decrypt)===n._prevLokiVersionId?s():(g&&console.warn("Another writer changed Loki IDB, using slow path..."),l=!0,f())},c=>{console.error("Getting loki chunk failed: ",c),k.abort()})},"getLokiThenSave")()}catch(i){o(i)}}_putInChunks(e,r,t,n){let o=this,i=[],l=0,k=u((s,f)=>{let h=new Set;t&&s.dirtyIds.forEach(d=>{let y=d/o.chunkSize|0;h.add(y)}),s.dirtyIds=[];let c=u(d=>{let y=o._getChunk(s,d);o.options.serializeChunk&&(y=o.options.serializeChunk(s.name,y)),y=o.encrypt(JSON.stringify(y)),l+=y.length,g&&t&&console.log(`Saving: ${s.name}.chunk.${d}`),e.put({key:o.keyResolver.getOrGenerateCiphertextCollectionChunkKey(s.name,d),value:y})},"prepareChunk");if(t)h.forEach(c);else{let d=s.maxId/o.chunkSize|0;for(let C=0;C<=d;C+=1)c(C);let y=n[s.name]||0;for(let C=d+1;C<=y;C+=1){let m=o.keyResolver.getOrGenerateCiphertextCollectionChunkKey(s.name,C);e.delete(m),g&&console.warn(`Deleted chunk: ${m}`)}}if(s.dirty||h.size||!t){s.idIndex=[],s.data=[],s.idbVersionId=E(),i.push({name:s.name,versionId:s.idbVersionId});let d=o.encrypt(JSON.stringify(s));l+=d.length,g&&t&&console.log(`Saving: ${s.name}.metadata`),e.put({key:o.keyResolver.getOrGenerateCiphertextCollectionMetadataKey(s.name),value:d})}r.collections[f]={name:s.name}},"prepareCollection");r.collections.forEach(k),r.idbVersionId=E();let p=o.encrypt(JSON.stringify(r));return l+=p.length,g&&t&&console.log("Saving: loki"),e.put({key:o.keyResolver.actualLokiKey,value:p}),g&&console.log(`saved size: ${l}`),{lokiVersionId:r.idbVersionId,collectionVersionIds:i}}loadDatabase(e,r){let t=this;if(this.operationInProgress)throw new Error("Error while loading database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0,g&&console.log("loadDatabase - begin"),g&&console.time("loadDatabase");let n=u(o=>{g&&console.timeEnd("loadDatabase"),t.operationInProgress=!1,r(o)},"finish");this._getAllChunks(e,o=>{try{if(!Array.isArray(o))throw o;if(!o.length)return n(null);g&&console.log("Found chunks:",o.length),o=T(o,t.keyResolver);let i=o.loki;return o.loki=null,F(i,o.chunkMap),o=null,t._prevLokiVersionId=i.idbVersionId||null,t._prevCollectionVersionIds={},i.collections.forEach(({name:l,idbVersionId:k})=>{t._prevCollectionVersionIds[l]=k||null}),n(i)}catch(i){return t._prevLokiVersionId=null,t._prevCollectionVersionIds={},n(i)}})}_initializeIDB(e,r,t){let n=this;if(g&&console.log("initializing idb"),this.idbInitInProgress)throw new Error("Cannot open IndexedDB because open is already in progress");this.idbInitInProgress=!0;let o=indexedDB.open(e,1);o.onupgradeneeded=({target:i,oldVersion:l})=>{let k=i.result;if(g&&console.log(`onupgradeneeded, old version: ${l}`),l<1)k.createObjectStore(n.encrypt(n._names.objectStoreName),{keyPath:"key"});else throw new Error(`Invalid old version ${l} for IndexedDB upgrade`)},o.onsuccess=({target:i})=>{n.idbInitInProgress=!1;let l=i.result;if(n.idb=l,n.idbActualLokiObjectStoreName=J(l,n._names.objectStoreName,n.decrypt),!n.idbActualLokiObjectStoreName){r(new Error(`Missing IndexedDB objectStore: ${n._names.objectStoreName}${n.decrypt?" (searched using decrypt function)":""}`)),n.deleteDatabase(e);return}let p=n.idb.transaction([n.idbActualLokiObjectStoreName],"readonly").objectStore(n.idbActualLokiObjectStoreName);q(p,n._names,n.encrypt,n.decrypt).then(s=>{n.keyResolver=s,g&&console.log("init success"),l.onversionchange=f=>{n.idb===l&&(g&&console.log("IDB version change",f),n.idb.close(),n.idb=null,n.options.onversionchange&&n.options.onversionchange(f))},t()}).catch(s=>{throw console.error("Error while retrieving actual IDB lokiKeyName",s),s})},o.onblocked=i=>{console.error("IndexedDB open is blocked",i),r(new Error("IndexedDB open is blocked by open connection"))},o.onerror=i=>{n.idbInitInProgress=!1,console.error("IndexedDB open error",i),r(i)}}_getAllChunks(e,r){let t=this;if(!this.idb){this._initializeIDB(e,r,()=>{t._getAllChunks(e,r)});return}let o=this.idb.transaction([t.idbActualLokiObjectStoreName],"readonly").objectStore(t.idbActualLokiObjectStoreName);function i(p){let s=t.megachunkCount,f=W(p,s),h=[],c=0;function d({target:C},m,x){let v=C.result;v.forEach((K,V)=>{N(K,t.deserializeChunk,t.keyResolver,t.decrypt),h.push(K),v[V]=null}),c+=1,c===s&&r(h)}u(d,"processMegachunk");function y(C){let m=f[C];b(o.getAll(m),x=>{C<s/2&&y(C+s/2),d(x,C,m)},x=>{r(x)})}u(y,"requestMegachunk");for(let C=0;C<s/2;C+=1)y(C)}u(i,"getMegachunks");function l(){b(o.getAll(),({target:p})=>{let s=p.result;s.forEach(f=>{N(f,t.deserializeChunk,t.keyResolver,t.decrypt)}),r(s)},p=>{r(p)})}u(l,"getAllChunks");function k(){b(o.getAllKeys(),({target:p})=>{let s=p.result.sort();s.length>100?i(s):l()},p=>{r(p)}),t.options.onFetchStart&&t.options.onFetchStart()}u(k,"getAllKeys"),k()}deleteDatabase(e,r){if(this.operationInProgress)throw new Error("Error while deleting database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0;let t=this;g&&console.log("deleteDatabase - begin"),g&&console.time("deleteDatabase"),this._prevLokiVersionId=null,this._prevCollectionVersionIds={},this.idb&&(this.idb.close(),this.idb=null);let n=indexedDB.deleteDatabase(e);n.onsuccess=()=>{t.operationInProgress=!1,g&&console.timeEnd("deleteDatabase"),r({success:!0})},n.onerror=o=>{t.operationInProgress=!1,console.error("Error while deleting database",o),r({success:!1})},n.onblocked=o=>{console.error("Deleting database failed because it's blocked by another connection",o)}}};u(w,"IncrementalIndexedDBAdapter");function z(a,e){let r={};return a.forEach(t=>{if(e.isChunkKey(t)){let n=e.getCollectionNameForCiphertextChunkKey(t),o=M(t)||0,i=r[n];(!i||o>i)&&(r[n]=o)}}),r}u(z,"getMaxChunkIds");function R(a,e){try{return a&&JSON.parse(e(a.value)).idbVersionId||null}catch(r){return console.error("Error while parsing loki chunk",r),null}}u(R,"lokiChunkVersionId");function T(a,e){let r,t={};if(G(a,e),a.forEach(n=>{let o=n.key,i=n.value;if(e.isLokiKey(o)){r=i;return}else{if(e.isChunkKey(o)){let l=e.getCollectionNameForCiphertextChunkKey(o);t[l]?t[l].dataChunks.push(i):t[l]={metadata:null,dataChunks:[i]};return}if(e.isMetadataKey(o)){let l=e.getCollectionNameForMetadataKey(o);t[l]?t[l].metadata=i:t[l]={metadata:i,dataChunks:[]};return}}throw console.error(`Unknown chunk ${o}`),new Error("Corrupted database - unknown chunk found")}),!r)throw new Error("Corrupted database - missing database metadata");return{loki:r,chunkMap:t}}u(T,"chunksToMap");function F({collections:a},e){a.forEach(u(function(t,n){let o=e[t.name];if(o){if(!o.metadata)throw new Error(`Corrupted database - missing metadata chunk for ${t.name}`);let i=o.metadata;o.metadata=null,a[n]=i;let l=o.dataChunks;l.forEach(u(function(p,s){p.forEach(f=>{i.data.push(f)}),l[s]=null},"populateChunk"))}},"populateCollection"))}u(F,"populateLoki");function N(a,e,r,t){if(a.value=JSON.parse(t(a.value)),e&&r.isChunkKey(a.key)){let n=r.getCollectionNameForCiphertextChunkKey(a.key);a.value=e(n,a.value)}}u(N,"parseChunk");function E(){return Math.random().toString(36).substring(2)}u(E,"randomVersionId");function S(a,e){let r=a.key;return e.isChunkKey(r)?M(r):-1}u(S,"_getSortKey");function G(a,e){a.sort((r,t)=>{let n=S(r,e),o=S(t,e);return n<o?-1:n>o?1:0})}u(G,"sortChunksInPlace");function W(a,e){let r=Math.floor(a.length/e),t=[],n,o;for(let i=0;i<e;i+=1)n=a[r*i],o=a[r*(i+1)],i===0?t.push(IDBKeyRange.upperBound(o,!0)):i===e-1?t.push(IDBKeyRange.lowerBound(n)):t.push(IDBKeyRange.bound(n,o,!1,!0));return t}u(W,"createKeyRanges");function b(a,e,r){return a.onsuccess=t=>{try{return e(t)}catch(n){r(n)}},a.onerror=r,a}u(b,"idbReq");function J({objectStoreNames:a},e,r){let t=a;for(let n=0;n<t.length;n++)if(r(t[n])===e)return t[n];return null}u(J,"findIdbActualLokiObjectStoreName");function D(a){return typeof a=="function"}u(D,"isFunction");function $(a){return a}u($,"doNothing");function L(a,e){return function(...r){try{return a.apply(this,r)}catch(t){throw console.error(e(r),t),t}}}u(L,"makeExternalFunctionSafe");function I(a){let e=a.match(/^(.+)\.\d+$/);return e===null?null:e[1]}u(I,"getChunkKeyWithoutChunkId");function M(a){let e=a.match(/^.+\.(\d+)$/);return e===null?null:parseInt(e[1],10)}u(M,"extractChunkIdFromChunkKey");function P(a,e,r){let t=I(a);if(!t)return!1;let n=r(t);return A(n,e)}u(P,"isCiphertextChunkKey");function A(a,{chunk:e}){return a.length-a.lastIndexOf(`.${e}`)-`.${e}`.length===0}u(A,"isPlaintextChunkKeyWithoutChunkId");function U(a,e){let r=I(a);return!r===null?null:j(r,e)}u(U,"extractCollectionNameFromPlaintextChunkKey");function j(a,{chunk:e}){let r=a.lastIndexOf(`.${e}`);if(r===-1)throw new Error(`Malformed chunk key without chunk id: ${a}. Could not find chunk term (${e})`);return a.substring(0,r)}u(j,"extractCollectionNameFromPlaintextChunkKeyWithoutChunkId");function _(a,{metadata:e}){return a.length-a.lastIndexOf(`.${e}`)-`.${e}`.length===0}u(_,"isPlaintextMetadataKey");function O(a,{metadata:e}){return a.substring(0,a.lastIndexOf(`.${e}`))}u(O,"extractCollectionNameFromPlaintextMetadataKey");function q(a,e,r,t){return r?new Promise((o,i)=>{b(a.getAllKeys(),({target:l})=>{let k=l.result,p=null,s={},f={ciphertextCollectionMetadataKeys:{},metadataCiphertextToCollectionName:{},chunkCiphertextToCollectionName:{}};if(k.length===0)p=r(e.lokiKeyName);else for(let h=0;h<k.length;h++){let c=k[h];if(P(c,e,t)){let d=I(c);if(!d)throw Error(`Could not extract collection name from ciphertext chunk key: ${c}. It did not match the [ciphertext].[chunkId] pattern.`);let y=j(t(d),e);s[y]=d,f.chunkCiphertextToCollectionName[d]=y}else{let d=t(c);if(d===e.lokiKeyName)p=c;else if(_(d,e)){let y=O(d,e);f.ciphertextCollectionMetadataKeys[y]=c,f.metadataCiphertextToCollectionName[c]=y}else throw Error(`Error while loading keys from IDB: Unknown or malformed key (not chunk, loki or meta): ${c} - Plaintext: ${d}`)}}p?o({actualLokiKey:p,metadataCiphertextToCollectionName:f.metadataCiphertextToCollectionName,isLokiKey(h){return h===p},isMetadataKey(h){return!!f.metadataCiphertextToCollectionName[h]},isChunkKey(h){return P(h,e,t)},getCollectionNameForMetadataKey(h){return f.metadataCiphertextToCollectionName[h]},getOrGenerateCiphertextCollectionMetadataKey(h){if(!f.ciphertextCollectionMetadataKeys[h]){let c=r(`${h}.${e.metadata}`);f.ciphertextCollectionMetadataKeys[h]=c,f.metadataCiphertextToCollectionName[c]=h}return f.ciphertextCollectionMetadataKeys[h]},getCollectionNameForCiphertextChunkKey(h){let c=I(h);return f.chunkCiphertextToCollectionName[c]},getOrGenerateCiphertextCollectionChunkKey(h,c){if(!s[h]){let d=r(`${h}.${e.chunk}`);s[h]=d,f.chunkCiphertextToCollectionName[d]=h}return`${s[h]}.${c}`}}):i({message:`Failed to resolve keyResolver. DB was not empty, a loki key with name '${e.lokiKeyName}' is expected but was not found.`})},l=>{i({message:"Error on IDB getAllKeys request",e:l})})}):new Promise(o=>{o({actualLokiKey:e.lokiKeyName,isLokiKey(i){return i===e.lokiKeyName},isMetadataKey(i){return _(i,e)},isChunkKey(i){let l=I(i);return l?A(l,e):!1},getCollectionNameForMetadataKey(i){return O(i,e)},getOrGenerateCiphertextCollectionMetadataKey(i){return`${i}.${e.metadata}`},getCollectionNameForCiphertextChunkKey(i){return U(i,e)},getOrGenerateCiphertextCollectionChunkKey(i,l){return`${i}.${e.chunk}.${l}`}})})}u(q,"extractkeyResolver");window!==void 0&&Object.assign(window,{IncrementalIndexedDBAdapter:w});export{w as IncrementalIndexedDBAdapter};
//# sourceMappingURL=incremental-indexeddb-adapter.js.map
