var $=Object.defineProperty;var d=(r,t)=>$(r,"name",{value:t,configurable:!0});var p=(r,t,n)=>new Promise((i,s)=>{var o=a=>{try{c(n.next(a))}catch(k){s(k)}},e=a=>{try{c(n.throw(a))}catch(k){s(k)}},c=a=>a.done?i(a.value):Promise.resolve(a.value).then(o,e);c((n=n.apply(r,t)).next())});var m=typeof window!="undefined"&&!!window.__loki_incremental_idb_debug,P=class{constructor(t){this.saveDatabase=d((t,n,i)=>{let s=this;if(!this.idb){this._initializeIDBAsync(t).then(()=>{s.saveDatabase(t,n,i)}).catch(i);return}if(this.operationInProgress)throw new Error("Error while saving to database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0,m&&console.log("saveDatabase - begin"),m&&console.time("saveDatabase");function o(e){m&&e&&console.error(e),m&&console.timeEnd("saveDatabase"),s.operationInProgress=!1,i(e)}d(o,"finish");try{let e=d(()=>{console.error("Unexpected successful tx - cannot update previous version ids")},"updatePrevVersionIds"),c=!1,a=this.idb.transaction(["LokiIncrementalData"],"readwrite");a.oncomplete=()=>{e(),o(),c&&s.options.onDidOverwrite&&s.options.onDidOverwrite()},a.onerror=()=>{o(a.error)},a.onabort=()=>{o(a.error)};let k=a.objectStore("LokiIncrementalData"),u=d(h=>{try{let l=!h;s._putInChunksAsync(k,n(),l,h).then(g=>{e=d(()=>{s._prevLokiVersionId=g.lokiVersionId,g.collectionVersionIds.forEach(({name:f,versionId:C})=>{s._prevCollectionVersionIds[f]=C})},"updatePrevVersionIds"),a.commit&&a.commit()})}catch(l){console.error("idb performSave failed: ",l),a.abort()}},"performSave"),I=d(()=>{D(k.getAllKeys()).then(h=>{let l=O(h);u(l)}).catch(h=>{console.error("Getting all keys failed: ",h),a.abort()})},"getAllKeysThenSave");d(()=>{D(k.get("loki")).then(h=>{K(h)===s._prevLokiVersionId?u():(m&&console.warn("Another writer changed Loki IDB, using slow path..."),c=!0,I())}).catch(h=>{console.error("Getting loki chunk failed: ",h),a.abort()})},"getLokiThenSave")()}catch(e){o(e)}},"saveDatabase");if(this.mode="incremental",this.options=t||{},this.chunkSize=100,this.megachunkCount=this.options.megachunkCount||24,this.lazyCollections=this.options.lazyCollections||[],this.idb=null,this._prevLokiVersionId=null,this._prevCollectionVersionIds={},!(this.megachunkCount>=4&&this.megachunkCount%2===0))throw new Error("megachunkCount must be >=4 and divisible by 2");if(this.options.serializeChunk&&!this.options.deserializeChunk)throw new Error("serializeChunk requires deserializeChunk to be set as well");if([!!this.options.serializeChunkAsync,!!this.options.deserializeChunkAsync].filter(Boolean).length===1)throw new Error("serializeChunkAsync requires deserializeChunkAsync to be set as well");if(this.options.deserializeChunkAsync&&this.lazyCollections.length>0)throw new Error("deserializeChunkAsync is not supported if lazyCollections is set")}_getChunk(t,n){let i=n*this.chunkSize,s=i+this.chunkSize-1;t.ensureId();let o=t.idIndex,e=null,c=o.length-1,a=0,k;for(;o[a]<o[c];)k=a+c>>1,o[k]<i?a=k+1:c=k;if(c===a&&o[a]>=i&&o[a]<=s&&(e=a),e===null)return[];let u=null;for(let l=e+this.chunkSize-1;l>=e;l--)if(o[l]<=s){u=l;break}let I=t.data[e];if(!(I&&I.$loki>=i&&I.$loki<=s))throw new Error("broken invariant firstelement");let y=t.data[u];if(!(y&&y.$loki>=i&&y.$loki<=s))throw new Error("broken invariant lastElement");let h=t.data.slice(e,u+1);if(h.length>this.chunkSize)throw new Error("broken invariant - chunk size");return h}_putInChunksAsync(t,n,i,s){return p(this,null,function*(){let o=this,e=[],c=0,a=d((u,I)=>p(this,null,function*(){let y=new Set;i&&u.dirtyIds.forEach(l=>{let g=l/o.chunkSize|0;y.add(g)}),u.dirtyIds=[];let h=d(l=>p(this,null,function*(){let g=o._getChunk(u,l);o.options.serializeChunk?g=o.options.serializeChunk(u.name,g):o.options.serializeChunkAsync&&(g=yield o.options.serializeChunkAsync(u.name,g)),g=JSON.stringify(g),c+=g.length,m&&i&&console.log(`Saving: ${u.name}.chunk.${l}`),yield t.put({key:`${u.name}.chunk.${l}`,value:g})}),"prepareChunk");if(i)yield Promise.all([...y].map(h));else{let l=u.maxId/o.chunkSize|0;for(let f=0;f<=l;f+=1)yield h(f);let g=s[u.name]||0;for(let f=l+1;f<=g;f+=1){let C=`${u.name}.chunk.${f}`;yield t.delete(C),m&&console.warn(`Deleted chunk: ${C}`)}}if(u.dirty||y.size||!i){u.idIndex=[],u.data=[],u.idbVersionId=B(),e.push({name:u.name,versionId:u.idbVersionId});let l=JSON.stringify(u);c+=l.length,m&&i&&console.log(`Saving: ${u.name}.metadata`),yield t.put({key:`${u.name}.metadata`,value:l})}n.collections[I]={name:u.name}}),"prepareCollection");yield Promise.all(n.collections.map(a)),n.idbVersionId=B();let k=JSON.stringify(n);return c+=k.length,m&&i&&console.log("Saving: loki"),yield t.put({key:"loki",value:k}),m&&console.log(`saved size: ${c}`),{lokiVersionId:n.idbVersionId,collectionVersionIds:e}})}loadDatabase(t,n){let i=this;if(this.operationInProgress)throw new Error("Error while loading database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0,m&&console.log("loadDatabase - begin"),m&&console.time("loadDatabase");let s=d(o=>{m&&console.timeEnd("loadDatabase"),i.operationInProgress=!1,n(o)},"finish");this._getAllChunksAsync(t).then(o=>p(this,null,function*(){try{if(!Array.isArray(o))throw o;if(!o.length)return s(null);m&&console.log("Found chunks:",o.length);let e=M(o),c=e.loki;return e.loki=null,R(c,e.chunkMap,i.options.deserializeChunk,i.lazyCollections),e=null,i._prevLokiVersionId=c.idbVersionId||null,i._prevCollectionVersionIds={},c.collections.forEach(({name:a,idbVersionId:k})=>{i._prevCollectionVersionIds[a]=k||null}),s(c)}catch(e){return i._prevLokiVersionId=null,i._prevCollectionVersionIds={},s(e)}}))}_initializeIDBAsync(t){return p(this,null,function*(){return new Promise((n,i)=>{this._initializeIDB(t,i,n)})})}_initializeIDB(t,n,i){let s=this;if(m&&console.log("initializing idb"),this.idbInitInProgress)throw new Error("Cannot open IndexedDB because open is already in progress");this.idbInitInProgress=!0;let o=indexedDB.open(t,1);o.onupgradeneeded=({oldVersion:e})=>{let c=o.result;if(m&&console.log(`onupgradeneeded, old version: ${e}`),e<1)c.createObjectStore("LokiIncrementalData",{keyPath:"key"});else throw new Error(`Invalid old version ${e} for IndexedDB upgrade`)},o.onsuccess=()=>{s.idbInitInProgress=!1;let e=o.result;if(s.idb=e,!e.objectStoreNames.contains("LokiIncrementalData")){n(new Error("Missing LokiIncrementalData")),s.deleteDatabase(t);return}m&&console.log("init success"),e.onversionchange=c=>{s.idb===e&&(m&&console.log("IDB version change",c),s.idb.close(),s.idb=null,s.options.onversionchange&&s.options.onversionchange(c))},i()},o.onblocked=e=>{console.error("IndexedDB open is blocked",e),n(new Error("IndexedDB open is blocked by open connection"))},o.onerror=e=>{s.idbInitInProgress=!1,console.error("IndexedDB open error",e),n(e)}}_getAllChunksAsync(t){return p(this,null,function*(){let n=this;return new Promise((i,s)=>{if(!this.idb){this._initializeIDBAsync(t).then(()=>{n._getAllChunksAsync(t).then(h=>{i(h)})}).catch(s);return}let e=this.idb.transaction(["LokiIncrementalData"],"readonly").objectStore("LokiIncrementalData"),c=this.options.deserializeChunkAsync,a=this.options.deserializeChunk,k=this.lazyCollections;function u(h){return p(this,null,function*(){let l=n.megachunkCount,g=J(h,l),f=[],C=0;function L(b,z,v){return p(this,null,function*(){let w="processing chunk "+z+" ("+v.lower+" -- "+v.upper+")";m&&console.time(w);let x=b;for(let[N,_]of x.entries())yield V(_,c,a,k),f.push(_),x[N]=null;m&&console.timeEnd(w),C+=1,C===l&&i(f)})}d(L,"processMegachunkAsync");let A=2,S=l/A;function E(b,z){let v=g[b];D(e.getAll(v)).then(w=>p(this,null,function*(){z<A&&E(b+S,z+1),yield L(w,b,v)})).catch(w=>{s(w)})}d(E,"requestMegachunk");for(let b=0;b<S;b+=1)E(b,1)})}d(u,"getMegachunksAsync");function I(){return p(this,null,function*(){let l=yield D(e.getAll());for(let g of l)yield V(g,c,a,k);i(l)})}d(I,"getAllChunksAsync");function y(){return p(this,null,function*(){function h(l){return p(this,null,function*(){l.sort(),l.length>100?yield u(l):yield I()})}d(h,"onDidGetKeysAsync"),D(e.getAllKeys()).then(l=>p(this,null,function*(){yield h(l)})).catch(l=>{s(l)}),n.options.onFetchStart&&n.options.onFetchStart()})}d(y,"getAllKeysAsync"),y().then(()=>{})})})}deleteDatabase(t,n){if(this.operationInProgress)throw new Error("Error while deleting database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0;let i=this;m&&console.log("deleteDatabase - begin"),m&&console.time("deleteDatabase"),this._prevLokiVersionId=null,this._prevCollectionVersionIds={},this.idb&&(this.idb.close(),this.idb=null);let s=indexedDB.deleteDatabase(t);s.onsuccess=()=>{i.operationInProgress=!1,m&&console.timeEnd("deleteDatabase"),n({success:!0})},s.onerror=o=>{i.operationInProgress=!1,console.error("Error while deleting database",o),n({success:!1,error:s.error})},s.onblocked=o=>{console.error("Deleting database failed because it's blocked by another connection",o)}}};d(P,"IncrementalIndexedDBAdapter");function O(r){let t={};return r.forEach(n=>{let i=n.split(".");if(i.length===3&&i[1]==="chunk"){let s=i[0],o=parseInt(i[2])||0,e=t[s];(!e||o>e)&&(t[s]=o)}}),t}d(O,"getMaxChunkIds");function K(r){try{return r&&JSON.parse(r.value).idbVersionId||null}catch(t){return console.error("Error while parsing loki chunk",t),null}}d(K,"lokiChunkVersionId");function M(r){let t,n={};if(T(r),r.forEach(i=>{let s=i.type,o=i.value,e=i.collectionName;if(s==="loki")t=o;else if(s==="data")n[e]?n[e].dataChunks.push(o):n[e]={metadata:null,dataChunks:[o]};else if(s==="metadata")n[e]?n[e].metadata=o:n[e]={metadata:o,dataChunks:[]};else throw new Error("unreachable")}),!t)throw new Error("Corrupted database - missing database metadata");return{loki:t,chunkMap:n}}d(M,"chunksToMap");function R({collections:r},t,n,i){r.forEach(d(function(o,e){let c=o.name,a=t[c];if(a){if(!a.metadata)throw new Error(`Corrupted database - missing metadata chunk for ${c}`);let k=a.metadata;a.metadata=null,r[e]=k;let u=i.includes(c),I=d(()=>{m&&u&&console.log(`lazy loading ${c}`);let y=[],h=a.dataChunks;return h.forEach(d(function(g,f){u&&(g=JSON.parse(g),n&&(g=n(c,g))),g.forEach(C=>{y.push(C)}),h[f]=null},"populateChunk")),y},"lokiDeserializeCollectionChunks");k.getData=I}},"populateCollection"))}d(R,"populateLoki");function j(r){let t=r.key;if(t==="loki"){r.type="loki";return}else if(t.includes(".")){let n=t.split(".");if(n.length===3&&n[1]==="chunk"){r.type="data",r.collectionName=n[0],r.index=parseInt(n[2],10);return}else if(n.length===2&&n[1]==="metadata"){r.type="metadata",r.collectionName=n[0];return}}throw console.error(`Unknown chunk ${t}`),new Error("Corrupted database - unknown chunk found")}d(j,"classifyChunk");function V(r,t,n,i){return p(this,null,function*(){j(r);let s=r.type==="data",o=i.includes(r.collectionName);s&&o||(r.value=JSON.parse(r.value)),s&&!o&&(n?r.value=n(r.collectionName,r.value):t&&(r.value=yield t(r.collectionName,r.value)))})}d(V,"parseChunkAsync");function B(){return Math.random().toString(36).substring(2)}d(B,"randomVersionId");function T(r){r.sort(function(t,n){return(t.index||0)-(n.index||0)})}d(T,"sortChunksInPlace");function J(r,t){let n=Math.floor(r.length/t),i=[],s,o;for(let e=0;e<t;e+=1)s=r[n*e],o=r[n*(e+1)],e===0?i.push(IDBKeyRange.upperBound(o,!0)):e===t-1?i.push(IDBKeyRange.lowerBound(s)):i.push(IDBKeyRange.bound(s,o,!1,!0));return i}d(J,"createKeyRanges");function D(r){return p(this,null,function*(){return new Promise((t,n)=>{r.onsuccess=i=>{t(i.target.result)},r.onerror=()=>{n(r.error)}})})}d(D,"idbReqAsync");window!==void 0&&Object.assign(window,{IncrementalIndexedDBAdapter:P});export{P as IncrementalIndexedDBAdapter};
//# sourceMappingURL=incremental-indexeddb-adapter.js.map
