var $=Object.defineProperty;var d=(i,t)=>$(i,"name",{value:t,configurable:!0});var f=typeof window!="undefined"&&!!window.__loki_incremental_idb_debug,E=class{constructor(t){if(this.mode="incremental",this.options=t||{},this.chunkSize=100,this.megachunkCount=this.options.megachunkCount||24,this.lazyCollections=this.options.lazyCollections||[],this.idb=null,this._prevLokiVersionId=null,this._prevCollectionVersionIds={},!(this.megachunkCount>=4&&this.megachunkCount%2===0))throw new Error("megachunkCount must be >=4 and divisible by 2")}_getChunk(t,n){let o=n*this.chunkSize,r=o+this.chunkSize-1;t.ensureId();let e=t.idIndex,s=null,l=e.length-1,a=0,m;for(;e[a]<e[l];)m=a+l>>1,e[m]<o?a=m+1:l=m;if(l===a&&e[a]>=o&&e[a]<=r&&(s=a),s===null)return[];let c=null;for(let g=s+this.chunkSize-1;g>=s;g--)if(e[g]<=r){c=g;break}let k=t.data[s];if(!(k&&k.$loki>=o&&k.$loki<=r))throw new Error("broken invariant firstelement");let h=t.data[c];if(!(h&&h.$loki>=o&&h.$loki<=r))throw new Error("broken invariant lastElement");let u=t.data.slice(s,c+1);if(u.length>this.chunkSize)throw new Error("broken invariant - chunk size");return u}saveDatabase(t,n,o){let r=this;if(!this.idb){this._initializeIDB(t,o,()=>{r.saveDatabase(t,n,o)});return}if(this.operationInProgress)throw new Error("Error while saving to database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0,f&&console.log("saveDatabase - begin"),f&&console.time("saveDatabase");function e(s){f&&s&&console.error(s),f&&console.timeEnd("saveDatabase"),r.operationInProgress=!1,o(s)}d(e,"finish");try{let s=d(()=>{console.error("Unexpected successful tx - cannot update previous version ids")},"updatePrevVersionIds"),l=!1,a=this.idb.transaction(["LokiIncrementalData"],"readwrite");a.oncomplete=()=>{s(),e(),l&&r.options.onDidOverwrite&&r.options.onDidOverwrite()},a.onerror=u=>{e(u)},a.onabort=u=>{e(u)};let m=a.objectStore("LokiIncrementalData"),c=d(u=>{try{let g=!u,p=r._putInChunks(m,n(),g,u);s=d(()=>{r._prevLokiVersionId=p.lokiVersionId,p.collectionVersionIds.forEach(({name:I,versionId:b})=>{r._prevCollectionVersionIds[I]=b})},"updatePrevVersionIds"),a.commit&&a.commit()}catch(g){console.error("idb performSave failed: ",g),a.abort()}},"performSave"),k=d(()=>{w(m.getAllKeys(),({target:u})=>{let g=B(u.result);c(g)},u=>{console.error("Getting all keys failed: ",u),a.abort()})},"getAllKeysThenSave");d(()=>{w(m.get("loki"),({target:u})=>{N(u.result)===r._prevLokiVersionId?c():(f&&console.warn("Another writer changed Loki IDB, using slow path..."),l=!0,k())},u=>{console.error("Getting loki chunk failed: ",u),a.abort()})},"getLokiThenSave")()}catch(s){e(s)}}_putInChunks(t,n,o,r){let e=this,s=[],l=0,a=d((c,k)=>{let h=new Set;o&&c.dirtyIds.forEach(g=>{let p=g/e.chunkSize|0;h.add(p)}),c.dirtyIds=[];let u=d(g=>{let p=e._getChunk(c,g);e.options.serializeChunk&&(p=e.options.serializeChunk(c.name,p)),p=JSON.stringify(p),l+=p.length,f&&o&&console.log(`Saving: ${c.name}.chunk.${g}`),t.put({key:`${c.name}.chunk.${g}`,value:p})},"prepareChunk");if(o)h.forEach(u);else{let g=c.maxId/e.chunkSize|0;for(let I=0;I<=g;I+=1)u(I);let p=r[c.name]||0;for(let I=g+1;I<=p;I+=1){let b=`${c.name}.chunk.${I}`;t.delete(b),f&&console.warn(`Deleted chunk: ${b}`)}}if(c.dirty||h.size||!o){c.idIndex=[],c.data=[],c.idbVersionId=V(),s.push({name:c.name,versionId:c.idbVersionId});let g=JSON.stringify(c);l+=g.length,f&&o&&console.log(`Saving: ${c.name}.metadata`),t.put({key:`${c.name}.metadata`,value:g})}n.collections[k]={name:c.name}},"prepareCollection");n.collections.forEach(a),n.idbVersionId=V();let m=JSON.stringify(n);return l+=m.length,f&&o&&console.log("Saving: loki"),t.put({key:"loki",value:m}),f&&console.log(`saved size: ${l}`),{lokiVersionId:n.idbVersionId,collectionVersionIds:s}}loadDatabase(t,n){let o=this;if(this.operationInProgress)throw new Error("Error while loading database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0,f&&console.log("loadDatabase - begin"),f&&console.time("loadDatabase");let r=d(e=>{f&&console.timeEnd("loadDatabase"),o.operationInProgress=!1,n(e)},"finish");this._getAllChunks(t,e=>{try{if(!Array.isArray(e))throw e;if(!e.length)return r(null);f&&console.log("Found chunks:",e.length),e=M(e);let s=e.loki;return e.loki=null,A(s,e.chunkMap,o.options.deserializeChunk,o.lazyCollections),e=null,o._prevLokiVersionId=s.idbVersionId||null,o._prevCollectionVersionIds={},s.collections.forEach(({name:l,idbVersionId:a})=>{o._prevCollectionVersionIds[l]=a||null}),r(s)}catch(s){return o._prevLokiVersionId=null,o._prevCollectionVersionIds={},r(s)}})}_initializeIDB(t,n,o){let r=this;if(f&&console.log("initializing idb"),this.idbInitInProgress)throw new Error("Cannot open IndexedDB because open is already in progress");this.idbInitInProgress=!0;let e=indexedDB.open(t,1);e.onupgradeneeded=({target:s,oldVersion:l})=>{let a=s.result;if(f&&console.log(`onupgradeneeded, old version: ${l}`),l<1)a.createObjectStore("LokiIncrementalData",{keyPath:"key"});else throw new Error(`Invalid old version ${l} for IndexedDB upgrade`)},e.onsuccess=({target:s})=>{r.idbInitInProgress=!1;let l=s.result;if(r.idb=l,!l.objectStoreNames.contains("LokiIncrementalData")){n(new Error("Missing LokiIncrementalData")),r.deleteDatabase(t);return}f&&console.log("init success"),l.onversionchange=a=>{r.idb===l&&(f&&console.log("IDB version change",a),r.idb.close(),r.idb=null,r.options.onversionchange&&r.options.onversionchange(a))},o()},e.onblocked=s=>{console.error("IndexedDB open is blocked",s),n(new Error("IndexedDB open is blocked by open connection"))},e.onerror=s=>{r.idbInitInProgress=!1,console.error("IndexedDB open error",s),n(s)}}_getAllChunks(t,n){let o=this;if(!this.idb){this._initializeIDB(t,n,()=>{o._getAllChunks(t,n)});return}let e=this.idb.transaction(["LokiIncrementalData"],"readonly").objectStore("LokiIncrementalData"),s=this.options.deserializeChunk,l=this.lazyCollections;function a(k){let h=o.megachunkCount,u=R(k,h),g=[],p=0;function I({target:v},D,y){let C="processing chunk "+D+" ("+y.lower+" -- "+y.upper+")";f&&console.time(C);let _=v.result;_.forEach((P,L)=>{x(P,s,l),g.push(P),_[L]=null}),f&&console.timeEnd(C),p+=1,p===h&&n(g)}d(I,"processMegachunk");let b=2,S=h/b;function z(v,D){let y=u[v];w(e.getAll(y),C=>{D<b&&z(v+S,D+1),I(C,v,y)},C=>{n(C)})}d(z,"requestMegachunk");for(let v=0;v<S;v+=1)z(v,1)}d(a,"getMegachunks");function m(){w(e.getAll(),({target:k})=>{let h=k.result;h.forEach(u=>{x(u,s,l)}),n(h)},k=>{n(k)})}d(m,"getAllChunks");function c(){function k(h){h.sort(),h.length>100?a(h):m()}d(k,"onDidGetKeys"),w(e.getAllKeys(),({target:h})=>{k(h.result)},h=>{n(h)}),o.options.onFetchStart&&o.options.onFetchStart()}d(c,"getAllKeys"),c()}deleteDatabase(t,n){if(this.operationInProgress)throw new Error("Error while deleting database - another operation is already in progress. Please use throttledSaves=true option on Loki object");this.operationInProgress=!0;let o=this;f&&console.log("deleteDatabase - begin"),f&&console.time("deleteDatabase"),this._prevLokiVersionId=null,this._prevCollectionVersionIds={},this.idb&&(this.idb.close(),this.idb=null);let r=indexedDB.deleteDatabase(t);r.onsuccess=()=>{o.operationInProgress=!1,f&&console.timeEnd("deleteDatabase"),n({success:!0})},r.onerror=e=>{o.operationInProgress=!1,console.error("Error while deleting database",e),n({success:!1})},r.onblocked=e=>{console.error("Deleting database failed because it's blocked by another connection",e)}}};d(E,"IncrementalIndexedDBAdapter");function B(i){let t={};return i.forEach(n=>{let o=n.split(".");if(o.length===3&&o[1]==="chunk"){let r=o[0],e=parseInt(o[2])||0,s=t[r];(!s||e>s)&&(t[r]=e)}}),t}d(B,"getMaxChunkIds");function N(i){try{return i&&JSON.parse(i.value).idbVersionId||null}catch(t){return console.error("Error while parsing loki chunk",t),null}}d(N,"lokiChunkVersionId");function M(i){let t,n={};if(K(i),i.forEach(o=>{let r=o.type,e=o.value,s=o.collectionName;if(r==="loki")t=e;else if(r==="data")n[s]?n[s].dataChunks.push(e):n[s]={metadata:null,dataChunks:[e]};else if(r==="metadata")n[s]?n[s].metadata=e:n[s]={metadata:e,dataChunks:[]};else throw new Error("unreachable")}),!t)throw new Error("Corrupted database - missing database metadata");return{loki:t,chunkMap:n}}d(M,"chunksToMap");function A({collections:i},t,n,o){i.forEach(d(function(e,s){let l=e.name,a=t[l];if(a){if(!a.metadata)throw new Error(`Corrupted database - missing metadata chunk for ${l}`);let m=a.metadata;a.metadata=null,i[s]=m;let c=o.includes(l),k=d(()=>{f&&c&&console.log(`lazy loading ${l}`);let h=[],u=a.dataChunks;return u.forEach(d(function(p,I){c&&(p=JSON.parse(p),n&&(p=n(l,p))),p.forEach(b=>{h.push(b)}),u[I]=null},"populateChunk")),h},"lokiDeserializeCollectionChunks");m.getData=k}},"populateCollection"))}d(A,"populateLoki");function O(i){let t=i.key;if(t==="loki"){i.type="loki";return}else if(t.includes(".")){let n=t.split(".");if(n.length===3&&n[1]==="chunk"){i.type="data",i.collectionName=n[0],i.index=parseInt(n[2],10);return}else if(n.length===2&&n[1]==="metadata"){i.type="metadata",i.collectionName=n[0];return}}throw console.error(`Unknown chunk ${t}`),new Error("Corrupted database - unknown chunk found")}d(O,"classifyChunk");function x(i,t,n){O(i);let o=i.type==="data",r=n.includes(i.collectionName);o&&r||(i.value=JSON.parse(i.value)),t&&o&&!r&&(i.value=t(i.collectionName,i.value))}d(x,"parseChunk");function V(){return Math.random().toString(36).substring(2)}d(V,"randomVersionId");function K(i){i.sort(function(t,n){return(t.index||0)-(n.index||0)})}d(K,"sortChunksInPlace");function R(i,t){let n=Math.floor(i.length/t),o=[],r,e;for(let s=0;s<t;s+=1)r=i[n*s],e=i[n*(s+1)],s===0?o.push(IDBKeyRange.upperBound(e,!0)):s===t-1?o.push(IDBKeyRange.lowerBound(r)):o.push(IDBKeyRange.bound(r,e,!1,!0));return o}d(R,"createKeyRanges");function w(i,t,n){return i.onsuccess=o=>{try{return t(o)}catch(r){n(r)}},i.onerror=n,i}d(w,"idbReq");typeof window!="undefined"&&Object.assign(window,{IncrementalIndexedDBAdapter:E});export{E as IncrementalIndexedDBAdapter};
//# sourceMappingURL=incremental-indexeddb-adapter.js.map
