{
  "version": 3,
  "sources": ["../../src/storage-adapter/src/utils/string-encryption-utils.ts", "../../src/storage-adapter/src/indexeddb-adapter/idb-catalog.ts", "../../src/storage-adapter/indexeddb-adapter.ts", "../../src/storage-adapter/crypted-indexeddb-adapter.ts"],
  "sourcesContent": ["export function base64ToBytes(str: string) {\n  if (str.length % 4 !== 0) {\n    throw new Error(\"Unable to parse base64 string (invalid length).\");\n  }\n  const index = str.indexOf(\"=\");\n  if (index !== -1 && index < str.length - 2) {\n    throw new Error(\"Unable to parse base64 string (octets).\");\n  }\n  const missingOctets = str.endsWith(\"==\") ? 2 : str.endsWith(\"=\") ? 1 : 0,\n    n = str.length,\n    result = new Uint8Array(3 * (n / 4));\n  let buffer;\n  for (let i = 0, j = 0; i < n; i += 4, j += 3) {\n    buffer =\n      (getBase64Code(str.charCodeAt(i)) << 18) |\n      (getBase64Code(str.charCodeAt(i + 1)) << 12) |\n      (getBase64Code(str.charCodeAt(i + 2)) << 6) |\n      getBase64Code(str.charCodeAt(i + 3));\n    result[j] = buffer >> 16;\n    result[j + 1] = (buffer >> 8) & 255;\n    result[j + 2] = buffer & 255;\n  }\n  return result.subarray(0, result.length - missingOctets);\n}\n\nconst base64abc = [\n  \"A\",\n  \"B\",\n  \"C\",\n  \"D\",\n  \"E\",\n  \"F\",\n  \"G\",\n  \"H\",\n  \"I\",\n  \"J\",\n  \"K\",\n  \"L\",\n  \"M\",\n  \"N\",\n  \"O\",\n  \"P\",\n  \"Q\",\n  \"R\",\n  \"S\",\n  \"T\",\n  \"U\",\n  \"V\",\n  \"W\",\n  \"X\",\n  \"Y\",\n  \"Z\",\n  \"a\",\n  \"b\",\n  \"c\",\n  \"d\",\n  \"e\",\n  \"f\",\n  \"g\",\n  \"h\",\n  \"i\",\n  \"j\",\n  \"k\",\n  \"l\",\n  \"m\",\n  \"n\",\n  \"o\",\n  \"p\",\n  \"q\",\n  \"r\",\n  \"s\",\n  \"t\",\n  \"u\",\n  \"v\",\n  \"w\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"0\",\n  \"1\",\n  \"2\",\n  \"3\",\n  \"4\",\n  \"5\",\n  \"6\",\n  \"7\",\n  \"8\",\n  \"9\",\n  \"_\",\n  \"-\",\n];\n\nexport const base64codes = (() => {\n  const l = 256;\n  const base64codes = new Uint8Array(l);\n  for (let i = 0; i < l; ++i) {\n    base64codes[i] = 255; // invalid character\n  }\n  base64abc.forEach((char, index) => {\n    base64codes[char.charCodeAt(0)] = index;\n  });\n  base64codes[\"=\".charCodeAt(0)] = 0; // ignored anyway, so we just need to prevent an error\n  return base64codes;\n})();\n\nexport function getBase64Code(charCode: number) {\n  if (charCode >= base64codes.length) {\n    throw new Error(\"Unable to parse base64 string (code beyond length).\");\n  }\n  const code = base64codes[charCode]!;\n  if (code === 255) {\n    throw new Error(\"Unable to parse base64 string (invalid code).\");\n  }\n  return code;\n}\n\nexport function bytesToBase64(bytes: Uint8Array) {\n  let result = \"\",\n    i,\n    l = bytes.length;\n  for (i = 2; i < l; i += 3) {\n    result += base64abc[bytes[i - 2]! >> 2];\n    result += base64abc[((bytes[i - 2]! & 0x03) << 4) | (bytes[i - 1]! >> 4)];\n    result += base64abc[((bytes[i - 1]! & 0x0f) << 2) | (bytes[i]! >> 6)];\n    result += base64abc[bytes[i]! & 0x3f];\n  }\n  if (i === l + 1) {\n    // 1 octet yet to write\n    result += base64abc[bytes[i - 2]! >> 2];\n    result += base64abc[(bytes[i - 2]! & 0x03) << 4];\n    result += \"==\";\n  }\n  if (i === l) {\n    // 2 octets yet to write\n    result += base64abc[bytes[i - 2]! >> 2];\n    result += base64abc[((bytes[i - 2]! & 0x03) << 4) | (bytes[i - 1]! >> 4)];\n    result += base64abc[(bytes[i - 1]! & 0x0f) << 2];\n    result += \"=\";\n  }\n  return result;\n}\n\nexport function base64encode(str: string, encoder = new TextEncoder()) {\n  return bytesToBase64(encoder.encode(str));\n}\n\nexport function base64decode(str: string, decoder = new TextDecoder()) {\n  return decoder.decode(base64ToBytes(str));\n}\n\nexport const getPasswordKey = (password) => {\n  const enc = new TextEncoder();\n  return window.crypto.subtle.importKey(\n    \"raw\",\n    enc.encode(password),\n    \"PBKDF2\",\n    false,\n    [\"deriveKey\"],\n  );\n};\n\nexport const deriveKey = (passwordKey, salt, keyUsage) =>\n  window.crypto.subtle.deriveKey(\n    {\n      name: \"PBKDF2\",\n      salt: salt,\n      iterations: 250000,\n      hash: \"SHA-256\",\n    },\n    passwordKey,\n    { name: \"AES-GCM\", length: 256 },\n    false,\n    keyUsage,\n  );\n\nexport async function encryptData(secretData, password) {\n  try {\n    const salt = window.crypto.getRandomValues(new Uint8Array(16));\n    const iv = window.crypto.getRandomValues(new Uint8Array(12));\n    const passwordKey = await getPasswordKey(password);\n    const aesKey = await deriveKey(passwordKey, salt, [\"encrypt\"]);\n    const encryptedContent = await window.crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv: iv,\n      },\n      aesKey,\n      new TextEncoder().encode(secretData),\n    );\n\n    const encryptedContentArr = new Uint8Array(encryptedContent);\n    const buff = new Uint8Array(\n      salt.byteLength + iv.byteLength + encryptedContentArr.byteLength,\n    );\n    buff.set(salt, 0);\n    buff.set(iv, salt.byteLength);\n    buff.set(encryptedContentArr, salt.byteLength + iv.byteLength);\n    const base64Buff = bytesToBase64(buff);\n    return base64Buff;\n  } catch (e) {\n    console.log(`Encryption Error - ${e}`);\n    throw e;\n  }\n}\n\nexport async function decryptData(encryptedData, password) {\n  try {\n    const encryptedDataBuff = base64ToBytes(encryptedData);\n    const salt = encryptedDataBuff.slice(0, 16);\n    const iv = encryptedDataBuff.slice(16, 16 + 12);\n    const data = encryptedDataBuff.slice(16 + 12);\n    const passwordKey = await getPasswordKey(password);\n\n    const aesKey = await deriveKey(passwordKey, salt, [\"decrypt\"]);\n    const decryptedContent = await window.crypto.subtle.decrypt(\n      {\n        name: \"AES-GCM\",\n        iv: iv,\n      },\n      aesKey,\n      data,\n    );\n    return new TextDecoder().decode(decryptedContent);\n  } catch (e) {\n    console.log(`Decryption Error - ${e}`);\n    throw e;\n  }\n}\n", "import { ResultType } from \"../models/result-type\";\n\n/**\n * IDBCatalog - underlying App/Key/Value catalog persistence\n *    This non-interface class implements the actual persistence\n *    using IndexedDBAdapter.\n */\nexport class IDBCatalog {\n  db?: IDBDatabase;\n  constructor() {\n    this.db = null;\n  }\n\n  /**\n   * Asynchronously initializes the catalog the database after creation. Must be run after the database is constructed but before using the database.\n   */\n  initialize(): Promise<IDBCatalog> {\n    return new Promise((resolve, reject) => {\n      this.#initializeCatalog()\n        .then((res) => {\n          resolve(res);\n        })\n        .catch((err) => {\n          console.log(err);\n          reject(err);\n        });\n    });\n  }\n\n  #openCatalog() {\n    const openRequest = indexedDB.open(\"IDBCatalog\", 1);\n\n    openRequest.onupgradeneeded = ({ target }) => {\n      const thisDB = (target as any).result;\n      if (thisDB.objectStoreNames.contains(\"IDBAKV\")) {\n        thisDB.deleteObjectStore(\"IDBAKV\");\n      }\n\n      if (!thisDB.objectStoreNames.contains(\"IDBAKV\")) {\n        const objectStore = thisDB.createObjectStore(\"IDBAKV\", {\n          keyPath: \"id\",\n          autoIncrement: true,\n        });\n        objectStore.createIndex(\"app\", \"app\", { unique: false });\n        objectStore.createIndex(\"key\", \"key\", { unique: false });\n        objectStore.createIndex(\"appkey\", \"appkey\", { unique: true });\n      }\n    };\n\n    return openRequest;\n  }\n\n  #initializeCatalog = async (): Promise<IDBCatalog> => {\n    const openRequest = this.#openCatalog();\n\n    return new Promise((resolve, reject) => {\n      openRequest.onsuccess = ({ target }) => {\n        this.db = (target as any).result;\n        resolve(this);\n      };\n\n      openRequest.onerror = (e) => {\n        reject(e);\n      };\n    });\n  };\n\n  async getAppKeyAsync(\n    app,\n    key,\n  ): Promise<\n    | {\n        app: string;\n        appkey: string;\n        id: number;\n        key: string;\n        val: string;\n      }\n    | {\n        id: 0;\n        success: false;\n      }\n  > {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"appkey\");\n    const appkey = `${app},${key}`;\n    const request = index.get(appkey);\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = ({ target }) => {\n        let lres = (target as any).result;\n\n        if (lres === null || typeof lres === \"undefined\") {\n          lres = {\n            id: 0,\n            success: false,\n          };\n        }\n\n        resolve(lres);\n      };\n\n      request.onerror = (e) => {\n        reject(e);\n      };\n    });\n  }\n\n  async setAppKeyAsync(app, key, val): Promise<ResultType> {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readwrite\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"appkey\");\n    const appkey = `${app},${key}`;\n    const request = index.get(appkey);\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = ({ target }) => {\n        let res = (target as any).result;\n\n        if (res === null || res === undefined) {\n          res = {\n            app,\n            key,\n            appkey: `${app},${key}`,\n            val,\n          };\n        } else {\n          res.val = val;\n        }\n\n        const requestPut = store.put(res);\n\n        requestPut.onerror = () => {\n          reject({ success: false, error: requestPut.error });\n          console.error(\"IDBCatalog.setAppKey (set) onerror\");\n          console.error(request.error);\n        };\n\n        requestPut.onsuccess = () => {\n          resolve({ success: true });\n        };\n      };\n\n      request.onerror = () => {\n        reject({ success: false, error: request.error });\n        console.error(\"IDBCatalog.setAppKey (get) onerror\");\n        console.error(request.error);\n      };\n    });\n  }\n\n  deleteAppKeyAsync(id): Promise<ResultType> {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readwrite\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const request = store.delete(id);\n\n    return new Promise((resolve, reject) => {\n      request.onsuccess = () => {\n        resolve({ success: true });\n      };\n\n      request.onerror = (e) => {\n        reject({ success: false, error: e });\n        console.error(\"IDBCatalog.deleteAppKey raised onerror\");\n        console.error(request.error);\n      };\n    });\n  }\n\n  async getAppKeysAsync(app): Promise<{ key: string }[]> {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const index = store.index(\"app\");\n\n    // We want cursor to all values matching our (single) app param\n    const singleKeyRange = IDBKeyRange.only(app);\n\n    // To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n    const cursor = index.openCursor(singleKeyRange);\n\n    // cursor internally, pushing results into this.data[] and return\n    // this.data[] when done (similar to service)\n    const localdata = [];\n\n    return new Promise((resolve, reject) => {\n      cursor.onsuccess = () => {\n        const cur = cursor.result;\n        if (cur) {\n          const currObject = cur.value;\n\n          localdata.push(currObject);\n\n          cur.continue();\n        } else {\n          resolve(localdata);\n        }\n      };\n\n      cursor.onerror = (e) => {\n        reject(e);\n      };\n    });\n  }\n\n  // Hide 'cursoring' and return array of { id: id, key: key }\n  getAllKeys(callback) {\n    const transaction = this.db.transaction([\"IDBAKV\"], \"readonly\");\n    const store = transaction.objectStore(\"IDBAKV\");\n    const cursor = store.openCursor();\n\n    const localdata = [];\n\n    cursor.onsuccess = (\n      (data, callback) =>\n      ({ target }) => {\n        const cursor = (target as any).result;\n        if (cursor) {\n          const currObject = cursor.value;\n\n          data.push(currObject);\n\n          cursor.continue();\n        } else {\n          if (typeof callback === \"function\") {\n            callback(data);\n          } else {\n            console.log(data);\n          }\n        }\n      }\n    )(localdata, callback);\n\n    cursor.onerror = ((usercallback) => (e) => {\n      if (typeof usercallback === \"function\") usercallback(null);\n    })(callback);\n  }\n}\n", "/**\n  Sylvie IndexedDb Adapter (need to include this script to use it)\n*/\nimport { IDBCatalog } from \"./src/indexeddb-adapter/idb-catalog\";\nimport { NormalPersistenceAdapter } from \"./src/models/persistence-adapter\";\nimport { NormalAsyncPersistenceAdapter } from \"./src/models/async-persistence-adapter\";\n\n// @ts-ignore\nconst DEBUG = typeof window !== \"undefined\" && !!window.__loki_idb_debug;\n\nif (DEBUG) {\n  console.log(\"DEBUG: Running indexeddb-adapter in DEBUG mode\");\n}\n\ntype IndexedDBAdapterOptions = {\n  // (Optional) Application name context can be used to distinguish subdomains, 'sylvie' by default\n  appname: string;\n  // Whether the indexedDB database should be closed after saving.\n  closeAfterSave: boolean;\n  /**\n   * An optional function hook that is called before the database is written to IndexedDB. Use this to modify the raw string before it is written to disk. If you use this, you must also pass beforeRead.\n   * @param databaseSerialized - The serialized string dump from Sylvie.\n   * @returns The raw string to be written to IndexedDB.\n   */\n  beforeWriteToIDB: (databaseSerialized: string) => Promise<string>;\n  /**\n   *  An optional function hook that is called after the database is read from IndexedDB but before it is loaded into Sylvie. Use this to deserialize the string if you used the beforeWrite hook.\n   * @param rawString The raw string read from IndexedDB.\n   * @returns The deserialized string to be loaded into Sylvie.\n   */\n  beforeReadFromIDB: (rawString: string) => Promise<string>;\n};\n\n/**\n * Loki/Sylvie encrypted persistence adapter class for indexedDb.\n *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n *     Utilizes the included SylvieCatalog app/key/value database for actual database persistence.\n *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n *     allow separate contexts for separate apps within a domain.\n *\n * @example\n * var idbAdapter = new IndexedDBAdapter('finance');\n *\n */\nexport class IndexedDBAdapter\n  implements NormalPersistenceAdapter, NormalAsyncPersistenceAdapter\n{\n  isAsync: true;\n  app: string;\n  options: Partial<IndexedDBAdapterOptions>;\n  catalog: IDBCatalog;\n  mode: \"normal\";\n\n  /**\n   * Create a IndexedDBAdapter.\n   * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, 'sylvie' by default\n   * @param {object=} options - (Optional) configuration options for adapter\n   * @param {boolean} [options.closeAfterSave=false] - (Optional) whether the indexedDB database should be closed after saving.\n   * @param {function} [options.beforeWriteToIDB] - (Optional) an optional function hook that is called before the database is written to IndexedDB. Use this to modify the raw string before it is written to disk. If you use this, you must also pass beforeRead.\n   * @param {function} [options.beforeReadFromIDB] - (Optional) an optional function hook that is called after the database is read from IndexedDB but before it is loaded into Sylvie. Use this to deserialize the string if you used the beforeWrite hook.\n   */\n  constructor(options?: Partial<IndexedDBAdapterOptions>) {\n    DEBUG && console.log(\"Initialized crypted-indexeddb-adapter\");\n    this.app = \"sylvie\";\n    this.options = options || {};\n\n    if (typeof options?.appname !== \"undefined\") {\n      this.app = options?.appname;\n    }\n\n    // keep reference to catalog class for base AKV operations\n    this.catalog = null;\n\n    if (!this.#checkIDBAvailability()) {\n      throw new Error(\n        \"IndexedDB does not seem to be supported for your environment\",\n      );\n    }\n  }\n\n  /**\n   * Used for closing the indexeddb database.\n   */\n  #closeDatabase = () => {\n    if (this.catalog && this.catalog.db) {\n      this.catalog.db.close();\n      this.catalog.db = null;\n    }\n  };\n\n  /**\n   * Used to check if adapter is available\n   *\n   * @returns {boolean} true if indexeddb is available, false if not.\n   */\n  #checkIDBAvailability(): boolean {\n    if (typeof indexedDB !== \"undefined\" && indexedDB) return true;\n    return false;\n  }\n\n  /**\n   * Retrieves a serialized db string from the catalog.\n   *\n   * @example\n   * // LOAD\n   * var idbAdapter = new SylvieIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   *   db.loadDatabase(function(result) {\n   *   console.log('done');\n   * });\n   *\n   * @param {string} dbname - the name of the database to retrieve.\n   * @param {function} callback - callback should accept string param containing serialized db string.\n   */\n  loadDatabase = (\n    dbname: string,\n    callback: (serialized: string | null) => void,\n  ): void => {\n    DEBUG && console.debug(\"loading database\");\n\n    // lazy open/create db reference so dont -need- callback in constructor\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog().initialize().then((catalog) => {\n        this.catalog = catalog;\n        this.loadDatabase(dbname, callback);\n        return;\n      });\n      return;\n    }\n\n    // lookup up dbstring in AKV db\n    this.catalog\n      .getAppKeyAsync(this.app, dbname)\n      .then((props) => {\n        const { success } = props as { success: boolean };\n        if (success === false) {\n          callback(null);\n        } else {\n          const { val: unserializedString } = props as { val: string };\n          if (this.options.beforeReadFromIDB) {\n            this.options\n              .beforeReadFromIDB(unserializedString)\n              .then((deserializedString) => {\n                DEBUG &&\n                  console.debug(`DESERIALIZED STRING: ${deserializedString}`);\n                callback(deserializedString);\n              })\n              .catch((err) => {\n                console.error(err);\n                callback(err);\n              });\n          } else {\n            callback(unserializedString);\n          }\n        }\n      })\n      .catch((err) => {\n        console.error(err);\n        callback(err);\n      });\n  };\n\n  /**\n   * Retrieves a serialized db string from the catalog, returns a promise to a string of the serialized database.\n   * @param dbname\n   * @returns {Promise<string>} A promise to a string of the serialized database.\n   * @example\n   * const db = new Sylvie(TEST_DB_NAME, {\n   *  adapter: new IndexedDBAdapter();\n   * });\n   * await db.loadDatabaseAsync({});\n   * // db is now ready to use\n   * // you can also chain the promises\n   * await db.loadDatabaseAsync({}).then(() => {\n   * // db is now ready to use\n   * });\n   * // or use async await syntax\n   * await db.loadDatabaseAsync({});\n   * // db is now ready to use\n   * @memberof IndexedDBAdapter\n   * @throws {Error} If the database is not found.\n   * @throws {Error} If the database is not decrypted successfully.\n   * @throws {Error} If the database is not deserialized successfully.\n   */\n  loadDatabaseAsync = async (dbname: string): Promise<string> => {\n    DEBUG && console.debug(\"loading database\");\n\n    return new Promise((resolve, reject) => {\n      const doLoad = () =>\n        this.catalog.getAppKeyAsync(this.app, dbname).then((props) => {\n          const { success } = props as { success: boolean };\n          if (success === false) {\n            reject(null);\n          } else {\n            const { val } = props as { val: string };\n            const unserializedString = val;\n            if (this.options.beforeReadFromIDB) {\n              this.options\n                .beforeReadFromIDB(unserializedString)\n                .then((deserializedString) => {\n                  DEBUG &&\n                    console.debug(`DESERIALIZED STRING: ${deserializedString}`);\n                  resolve(deserializedString);\n                })\n                .catch((err) => {\n                  reject(err);\n                });\n            } else {\n              resolve(unserializedString);\n            }\n          }\n        });\n\n      // lazy open/create db reference so dont -need- callback in constructor\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            doLoad();\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog was already initialized, so just lookup object and delete by id\n        doLoad();\n      }\n    });\n  };\n\n  /**\n   * Saves a serialized db to the catalog.\n   *\n   * @example\n   * // SAVE : will save App/Key/Val as 'finance'/'test'/{serializedDb}\n   * var idbAdapter = new SylvieIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   * var coll = db.addCollection('testColl');\n   * coll.insert({test: 'val'});\n   * db.saveDatabase();  // could pass callback if needed for async complete\n   *\n   * @param {string} dbname - the name to give the serialized database within the catalog.\n   * @param {string} dbstring - the serialized db string to save.\n   * @param {function} callback - (Optional) callback passed obj.success with true or false\n   */\n  saveDatabase = (\n    dbname: string,\n    dbstring: string,\n    callback?: (\n      err: Error | { success: true } | { success: false; error: Error },\n    ) => void,\n  ) => {\n    DEBUG &&\n      console.debug(`in saveDatabase(${dbname}, ${dbstring}, ${callback})`);\n\n    const doSave = () => {\n      if (this.options.beforeWriteToIDB) {\n        this.options\n          .beforeWriteToIDB(dbstring)\n          .then((serializedString) => {\n            // lazy open/create db reference so dont -need- callback in constructor\n            DEBUG && console.debug(`SERIALIZED STRING: ${serializedString}`);\n            // set (add/update) entry to AKV database\n            this.catalog\n              .setAppKeyAsync(this.app, dbname, serializedString)\n              .then((res) => {\n                callback(res);\n              })\n              .catch((err) => {\n                callback(err);\n              });\n          })\n          .catch((err) => {\n            callback(err);\n          });\n      } else {\n        DEBUG && console.debug(`SERIALIZED STRING: ${dbstring}`);\n        this.catalog\n          .setAppKeyAsync(this.app, dbname, dbstring)\n          .then((res) => {\n            callback(res);\n          })\n          .catch((err) => {\n            callback(err);\n          });\n      }\n    };\n\n    if (this.catalog === null || this.catalog.db === null) {\n      // catalog not initialized yet\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.saveDatabaseAsync(dbname, dbstring)\n            .then(() => {\n              callback(undefined);\n            })\n            .catch((err) => {\n              callback(new Error(\"Error saving database: \" + err));\n            })\n            .finally(() => {\n              if (this.options.closeAfterSave === true) {\n                this.#closeDatabase();\n              }\n            });\n        })\n        .catch((err) => {\n          callback(new Error(\"Error saving database: \" + err));\n        });\n    } else {\n      // catalog was already initialized, so just lookup object and delete by id\n      doSave();\n    }\n  };\n\n  async saveDatabaseAsync(dbname: string, dbstring: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const doSave = () => {\n        if (this.options.beforeWriteToIDB) {\n          this.options\n            .beforeWriteToIDB(dbstring)\n            .then((encryptedDbString) => {\n              // lazy open/create db reference so dont -need- callback in constructor\n              DEBUG && console.debug(`ENCRYPTED STRING: ${encryptedDbString}`);\n              // set (add/update) entry to AKV database\n              this.catalog\n                .setAppKeyAsync(this.app, dbname, encryptedDbString)\n                .then((res) => {\n                  if (res.success === true) {\n                    resolve();\n                  } else {\n                    reject(res);\n                  }\n                })\n                .catch((err) => {\n                  reject(err);\n                });\n            })\n            .catch((err) => {\n              reject(err);\n            });\n        } else {\n          DEBUG && console.debug(`SERIALIZED STRING: ${dbstring}`);\n          this.catalog\n            .setAppKeyAsync(this.app, dbname, dbstring)\n            .then((res) => {\n              if (res.success === true) {\n                resolve();\n              } else {\n                reject(res);\n              }\n            })\n            .catch((err) => {\n              reject(err);\n            });\n        }\n      };\n\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            // Now that catalog is initialized, try again\n            this.saveDatabaseAsync(dbname, dbstring)\n              .then(resolve)\n              .catch((error) => {\n                reject(new Error(\"Error saving database: \" + error));\n              })\n              .finally(() => {\n                if (this.options.closeAfterSave === true) {\n                  this.#closeDatabase();\n                }\n              });\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog was already initialized, so just lookup object and delete by id\n        doSave();\n      }\n    });\n  }\n\n  /**\n   * Deletes a serialized db from the catalog.\n   *\n   * @example\n   * // DELETE DATABASE\n   * // delete 'finance'/'test' value from catalog\n   * idbAdapter.deleteDatabase('test', function {\n   *   // database deleted\n   * });\n   *\n   * @param {string} dbname - the name of the database to delete from the catalog.\n   * @param {function=} callback - (Optional) executed on database delete\n   * @memberof SylvieIndexedAdapter\n   */\n  deleteDatabase = (\n    dbname: string,\n    callback?: (\n      _: Error | { success: true } | { success: false; error: Error },\n    ) => any,\n  ) => {\n    // lazy open/create db reference and pass callback ahead\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.deleteDatabase(dbname, callback);\n        })\n        .catch((err) => {\n          callback(new Error(\"Error deleting database: \" + err));\n        });\n\n      return;\n    }\n\n    // catalog was already initialized, so just lookup object and delete by id\n    this.catalog\n      .getAppKeyAsync(this.app, dbname)\n      .then((result) => {\n        const id = result.id;\n        if (id !== 0) {\n          this.catalog\n            .deleteAppKeyAsync(id)\n            .then((res) => {\n              if (typeof callback === \"function\") {\n                callback(res);\n              }\n            })\n            .catch((err) => {\n              if (typeof callback === \"function\") {\n                callback({ success: false, error: err });\n              }\n            });\n        }\n      })\n      .catch((err) => {\n        if (typeof callback === \"function\") {\n          callback({ success: false, error: err });\n        }\n      });\n  };\n\n  async deleteDatabaseAsync(dbname: string): Promise<void> {\n    // lazy open/create db reference and pass callback ahead\n    return new Promise((resolve, reject) => {\n      const doDelete = () =>\n        this.catalog\n          .getAppKeyAsync(this.app, dbname)\n          .then((result) => {\n            const id = result.id;\n            if (id !== 0) {\n              this.catalog\n                .deleteAppKeyAsync(id)\n                .then((res) => {\n                  if (res.success === true) {\n                    resolve();\n                  } else {\n                    reject(res);\n                  }\n                })\n                .catch((err) => {\n                  reject(err);\n                });\n            }\n          })\n          .catch((err) => {\n            reject(err);\n          });\n\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            doDelete();\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog was already initialized, so just lookup object and delete by id\n        doDelete();\n      }\n    });\n  }\n\n  /**\n   * Removes all database partitions and pages with the base filename passed in.\n   * This utility method does not (yet) guarantee async deletions will be completed before returning\n   *\n   * @param {string} dbname - the base filename which container, partitions, or pages are derived\n   * @memberof SylvieIndexedAdapter\n   */\n  deleteDatabasePartitions = (dbname) => {\n    this.getDatabaseList((result) => {\n      if (result instanceof Error) {\n        throw result;\n      }\n      result.forEach((str) => {\n        if (str.startsWith(dbname)) {\n          this.deleteDatabase(str);\n        }\n      });\n    });\n  };\n\n  /**\n   * Retrieves object array of catalog entries for current app.\n   *\n   * @example\n   * idbAdapter.getDatabaseList(function(result) {\n   *   // result is array of string names for that appcontext ('finance')\n   *   result.forEach(function(str) {\n   *     console.log(str);\n   *   });\n   * });\n   *\n   * @param {function} callback - should accept array of database names in the catalog for current app.\n   * @memberof SylvieIndexedAdapter\n   */\n  getDatabaseList = (callback: (_: string[] | Error) => void) => {\n    // lazy open/create db reference so dont -need- callback in constructor\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.getDatabaseList(callback);\n        })\n        .catch((err) => {\n          callback(new Error(\"Error getting database list: \" + err));\n        });\n\n      return;\n    }\n\n    // catalog already initialized\n    // get all keys for current appName, and transpose results so just string array\n    this.catalog\n      .getAppKeysAsync(this.app)\n      .then((results) => {\n        const names = [];\n\n        for (let idx = 0; idx < results.length; idx++) {\n          names.push(results[idx].key);\n        }\n\n        if (typeof callback === \"function\") {\n          callback(names);\n        }\n      })\n      .catch((err) => {\n        callback(err);\n      });\n  };\n\n  getDatabaseListAsync = (): Promise<string[]> => {\n    return new Promise((resolve, reject) => {\n      // lazy open/create db reference\n      if (this.catalog === null || this.catalog.db === null) {\n        // catalog not initialized yet\n        new IDBCatalog()\n          .initialize()\n          .then((catalog) => {\n            this.catalog = catalog;\n            this.catalog\n              .getAppKeysAsync(this.app)\n              .then((results) => {\n                const names: string[] = results.map((result) => result.key);\n                resolve(names);\n              })\n              .catch((err) => {\n                reject(err);\n              });\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      } else {\n        // catalog already initialized\n        // get all keys for current appName, and transpose results so just string array\n        this.catalog\n          .getAppKeysAsync(this.app)\n          .then((results) => {\n            const names: string[] = results.map((result) => result.key);\n            resolve(names);\n          })\n          .catch((err) => {\n            reject(err);\n          });\n      }\n    });\n  };\n\n  /**\n   * Allows retrieval of list of all keys in catalog along with size\n   *\n   * @param {function} callback - (Optional) callback to accept result array.\n   * @memberof LokiIndexedAdapter\n   */\n  getCatalogSummary = (callback) => {\n    // lazy open/create db reference\n    if (this.catalog === null || this.catalog.db === null) {\n      new IDBCatalog()\n        .initialize()\n        .then((catalog) => {\n          this.catalog = catalog;\n          this.getCatalogSummary(callback);\n        })\n        .catch((err) => {\n          callback(new Error(\"Error getting database list: \" + err));\n        });\n\n      return;\n    }\n\n    // catalog already initialized\n    // get all keys for current appName, and transpose results so just string array\n    this.catalog.getAllKeys((results) => {\n      const entries = [];\n      let obj;\n      let size;\n      let oapp;\n      let okey;\n      let oval;\n\n      for (let idx = 0; idx < results.length; idx++) {\n        obj = results[idx];\n        oapp = obj.app || \"\";\n        okey = obj.key || \"\";\n        oval = obj.val || \"\";\n\n        // app and key are composited into an appkey column so we will mult by 2\n        size = oapp.length * 2 + okey.length * 2 + oval.length + 1;\n\n        entries.push({ app: obj.app, key: obj.key, size: size });\n      }\n\n      if (typeof callback === \"function\") {\n        callback(entries);\n      }\n    });\n  };\n}\n\nif (typeof window !== \"undefined\") {\n  Object.assign(window, {\n    IndexedDBAdapter: IndexedDBAdapter,\n  });\n}\n", "/**\n  Sylvie encrypted IndexedDb Adapter (need to include this script to use it)\n*/\nimport { decryptData, encryptData } from \"./src/utils/string-encryption-utils\";\nimport { NormalPersistenceAdapter } from \"./src/models/persistence-adapter\";\nimport { NormalAsyncPersistenceAdapter } from \"./src/models/async-persistence-adapter\";\nimport { IndexedDBAdapter } from \"./indexeddb-adapter\";\nimport { PersistenceAdapterCallback } from \"./src/models/persistence-adapter-callback\";\n\n// @ts-ignore\nconst DEBUG = typeof window !== \"undefined\" && !!window.__loki_idb_debug;\n\nif (DEBUG) {\n  console.log(\"DEBUG: Running crypted-indexeddb-adapter in DEBUG mode\");\n}\n\nif (!window.crypto.subtle) {\n  alert(\"Required crypto lib is not available, are you using SSL?\");\n  throw new Error(\"Required crypto lib is not available\");\n}\n\nexport interface CryptedIndexedDBAdapterOptions {\n  appname: string;\n  closeAfterSave: boolean;\n  secret: string;\n}\n\n/**\n * Loki/Sylvie encrypted persistence adapter class for indexedDb.\n *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n *     Utilizes the included SylvieCatalog app/key/value database for actual database persistence.\n *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n *     allow separate contexts for separate apps within a domain.\n *\n * @example\n * var idbAdapter = new CryptedIndexedDBAdapter('finance', {\n *  secret: \"pass\"\n * });\n *\n */\nexport class CryptedIndexedDBAdapter\n  implements NormalPersistenceAdapter, NormalAsyncPersistenceAdapter\n{\n  isAsync: true;\n  app: string;\n  options: Partial<CryptedIndexedDBAdapterOptions>;\n  mode: \"normal\";\n  #secret: string;\n  idbAdapter: IndexedDBAdapter;\n\n  /**\n   * Create a CryptedIndexedDBAdapter.\n   * @param {CryptedIndexedDBAdapterOptions} options Configuration options for the adapter\n   * @param {string} options.appname - (Optional) Application name context can be used to distinguish subdomains, 'sylvie' by default\n   * @param {boolean} options.closeAfterSave Whether the indexedDB database should be closed after saving.\n   * @param {boolean} options.secret The password to encrypt with.\n   */\n  constructor(options?: Partial<CryptedIndexedDBAdapterOptions>) {\n    DEBUG && console.log(\"Initialized crypted-indexeddb-adapter\");\n    this.app = \"sylvie\";\n\n    if (typeof options?.appname !== \"undefined\") {\n      this.app = options?.appname;\n    }\n\n    if (options.secret) {\n      this.#secret = options.secret || \"\";\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this; // Required since constructors cannot be arrow functions\n\n    this.idbAdapter = new IndexedDBAdapter({\n      ...options,\n      beforeReadFromIDB(rawString) {\n        return decryptData(rawString, self.#secret);\n      },\n      beforeWriteToIDB(dbString) {\n        return encryptData(dbString, self.#secret);\n      },\n    });\n  }\n\n  /**\n   * Sets a password for use on future load and save of the database.\n   * Note that this does not re-encrypt the database with the new password. Use changePassword() for that.\n   * @param secret\n   * @example\n   * const db = new Sylvie(TEST_DB_NAME, {\n   *   adapter: new CryptedIndexedDBAdapter();\n   * });\n   *\n   * adapter.usePassword(\"newpassword\");\n   *\n   * await newDb.loadDatabaseAsync({});\n   */\n  usePassword(secret: string) {\n    this.#secret = secret;\n  }\n\n  /**\n   * Retrieves a serialized db string from the catalog.\n   *\n   * @example\n   * // LOAD\n   * var idbAdapter = new SylvieIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   *   db.loadDatabase(function(result) {\n   *   console.log('done');\n   * });\n   *\n   * @param {string} dbname - the name of the database to retrieve.\n   * @param {function} callback - callback should accept string param containing serialized db string.\n   */\n  loadDatabase = (\n    dbname: string,\n    callback: (serialized: string) => void,\n  ): void => {\n    this.idbAdapter.loadDatabase(dbname, callback);\n  };\n\n  /**\n   * Retrieves a serialized db string from the catalog, returns a promise to a string of the serialized database.\n   * @param dbname\n   * @returns {Promise<string>} A promise to a string of the serialized database.\n   * @example\n   * const db = new Sylvie(TEST_DB_NAME, {\n   *  adapter: new CryptedIndexedDBAdapter();\n   * });\n   * await db.loadDatabaseAsync({});\n   * // db is now ready to use\n   * // you can also chain the promises\n   * await db.loadDatabaseAsync({}).then(() => {\n   * // db is now ready to use\n   * });\n   * // or use async await syntax\n   * await db.loadDatabaseAsync({});\n   * // db is now ready to use\n   * @memberof CryptedIndexedDBAdapter\n   * @throws {Error} If the database is not found.\n   * @throws {Error} If the database is not decrypted successfully.\n   * @throws {Error} If the database is not deserialized successfully.\n   */\n  loadDatabaseAsync = async (dbname: string): Promise<string> => {\n    return this.idbAdapter.loadDatabaseAsync(dbname);\n  };\n\n  /**\n   * Saves a serialized db to the catalog.\n   *\n   * @example\n   * // SAVE : will save App/Key/Val as 'finance'/'test'/{serializedDb}\n   * var idbAdapter = new SylvieIndexedAdapter('finance');\n   * var db = new loki('test', { adapter: idbAdapter });\n   * var coll = db.addCollection('testColl');\n   * coll.insert({test: 'val'});\n   * db.saveDatabase();  // could pass callback if needed for async complete\n   *\n   * @param {string} dbname - the name to give the serialized database within the catalog.\n   * @param {string} dbstring - the serialized db string to save.\n   * @param {function} callback - (Optional) callback passed obj.success with true or false\n   */\n  saveDatabase = (\n    dbname: string,\n    dbstring: string,\n    callback?: PersistenceAdapterCallback,\n  ) => {\n    return this.idbAdapter.saveDatabase(dbname, dbstring, callback);\n  };\n\n  async saveDatabaseAsync(dbname: string, dbstring: string): Promise<void> {\n    return this.idbAdapter.saveDatabaseAsync(dbname, dbstring);\n  }\n\n  /**\n   * Deletes a serialized db from the catalog.\n   *\n   * @example\n   * // DELETE DATABASE\n   * // delete 'finance'/'test' value from catalog\n   * idbAdapter.deleteDatabase('test', function {\n   *   // database deleted\n   * });\n   *\n   * @param {string} dbname - the name of the database to delete from the catalog.\n   * @param {function=} callback - (Optional) executed on database delete\n   * @memberof SylvieIndexedAdapter\n   */\n  deleteDatabase = (dbname: string, callback?: PersistenceAdapterCallback) => {\n    return this.idbAdapter.deleteDatabase(dbname, callback);\n  };\n\n  async deleteDatabaseAsync(dbname: string): Promise<void> {\n    return this.idbAdapter.deleteDatabaseAsync(dbname);\n  }\n\n  /**\n   * Changes the password of a database and re-encrypts the database with the new password.\n   * @param {string} dbName The name of the database to change the password of.\n   * @param {string} newPassword The new password to encrypt the database with.\n   * @memberof CryptedIndexedDBAdapter\n   * @returns {Promise<void>} A promise that resolves when the password has been changed.\n   * @throws {Error} If the adapter is not open.\n   * @example\n   * await adapter.changePassword(\"mydb\", \"newpassword\");\n   * // The database \"mydb\" is now encrypted with the password \"newpassword\".\n   * // The old password will no longer work.\n   */\n  async changePassword(dbname: string, newPassword: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.loadDatabase(dbname, (serializedDbString) => {\n        const oldPassword = this.#secret;\n        this.#secret = newPassword;\n        this.saveDatabase(dbname, serializedDbString, (responseString) => {\n          if (responseString) {\n            this.#secret = oldPassword;\n            if ((responseString as { success: boolean }).success === true) {\n              resolve();\n            } else {\n              reject(responseString);\n            }\n          }\n          resolve();\n        });\n      });\n    });\n  }\n\n  /**\n   * Removes all database partitions and pages with the base filename passed in.\n   * This utility method does not (yet) guarantee async deletions will be completed before returning\n   *\n   * @param {string} dbname - the base filename which container, partitions, or pages are derived\n   * @memberof SylvieIndexedAdapter\n   */\n  deleteDatabasePartitions = (dbname) => {\n    this.idbAdapter.deleteDatabasePartitions(dbname);\n  };\n\n  /**\n   * Retrieves object array of catalog entries for current app.\n   *\n   * @example\n   * idbAdapter.getDatabaseList(function(result) {\n   *   // result is array of string names for that appcontext ('finance')\n   *   result.forEach(function(str) {\n   *     console.log(str);\n   *   });\n   * });\n   *\n   * @param {function} callback - should accept array of database names in the catalog for current app.\n   * @memberof SylvieIndexedAdapter\n   */\n  getDatabaseList = (callback: (_: string[] | Error) => void): void => {\n    this.idbAdapter.getDatabaseList(callback);\n  };\n\n  getDatabaseListAsync = (): Promise<string[]> => {\n    return this.idbAdapter.getDatabaseListAsync();\n  };\n}\n\nif (typeof window !== \"undefined\") {\n  Object.assign(window, {\n    CryptedIndexedDBAdapter: CryptedIndexedDBAdapter,\n  });\n}\n"],
  "mappings": "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",
  "names": ["base64ToBytes", "str", "index", "missingOctets", "n", "result", "buffer", "i", "j", "getBase64Code", "__name", "base64abc", "base64codes", "char", "charCode", "code", "bytesToBase64", "bytes", "l", "getPasswordKey", "__name", "password", "enc", "deriveKey", "passwordKey", "salt", "keyUsage", "encryptData", "secretData", "__async", "iv", "aesKey", "encryptedContent", "encryptedContentArr", "buff", "bytesToBase64", "e", "decryptData", "encryptedData", "encryptedDataBuff", "base64ToBytes", "data", "decryptedContent", "_openCatalog", "openCatalog_fn", "_initializeCatalog", "IDBCatalog", "__privateAdd", "__name", "__async", "openRequest", "__privateMethod", "resolve", "reject", "target", "e", "__privateGet", "res", "err", "app", "key", "index", "appkey", "request", "lres", "val", "store", "requestPut", "id", "singleKeyRange", "cursor", "localdata", "cur", "currObject", "callback", "data", "usercallback", "thisDB", "objectStore", "DEBUG", "_closeDatabase", "_checkIDBAvailability", "checkIDBAvailability_fn", "IndexedDBAdapter", "options", "__privateAdd", "__name", "dbname", "callback", "IDBCatalog", "catalog", "props", "success", "unserializedString", "deserializedString", "err", "__async", "resolve", "reject", "doLoad", "val", "dbstring", "doSave", "serializedString", "res", "__privateGet", "result", "id", "str", "results", "names", "idx", "entries", "obj", "size", "oapp", "okey", "oval", "__privateMethod", "encryptedDbString", "error", "doDelete", "DEBUG", "_secret", "CryptedIndexedDBAdapter", "options", "__privateAdd", "__name", "dbname", "callback", "__async", "dbstring", "__privateSet", "self", "IndexedDBAdapter", "__spreadProps", "__spreadValues", "rawString", "decryptData", "__privateGet", "dbString", "encryptData", "secret", "newPassword", "resolve", "reject", "serializedDbString", "oldPassword", "responseString"]
}
